"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/Clone.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Clone.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clone: () => (/* binding */ Clone)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\");\n\n\n\n\n\nfunction createSpread(child, {\n  keys = ['near', 'far', 'color', 'distance', 'decay', 'penumbra', 'angle', 'intensity', 'skeleton', 'visible', 'castShadow', 'receiveShadow', 'morphTargetDictionary', 'morphTargetInfluences', 'name', 'geometry', 'material', 'position', 'rotation', 'scale', 'up', 'userData', 'bindMode', 'bindMatrix', 'bindMatrixInverse', 'skeleton'],\n  deep,\n  inject,\n  castShadow,\n  receiveShadow\n}) {\n  let spread = {};\n  for (const key of keys) {\n    spread[key] = child[key];\n  }\n  if (deep) {\n    if (spread.geometry && deep !== 'materialsOnly') spread.geometry = spread.geometry.clone();\n    if (spread.material && deep !== 'geometriesOnly') spread.material = spread.material.clone();\n  }\n  if (inject) {\n    if (typeof inject === 'function') spread = {\n      ...spread,\n      children: inject(child)\n    };else if (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(inject)) spread = {\n      ...spread,\n      children: inject\n    };else spread = {\n      ...spread,\n      ...inject\n    };\n  }\n  if (child instanceof three__WEBPACK_IMPORTED_MODULE_2__.Mesh) {\n    if (castShadow) spread.castShadow = true;\n    if (receiveShadow) spread.receiveShadow = true;\n  }\n  return spread;\n}\nconst Clone = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  isChild = false,\n  object,\n  children,\n  deep,\n  castShadow,\n  receiveShadow,\n  inject,\n  keys,\n  ...props\n}, forwardRef) => {\n  const config = {\n    keys,\n    deep,\n    inject,\n    castShadow,\n    receiveShadow\n  };\n  object = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    if (isChild === false && !Array.isArray(object)) {\n      let isSkinned = false;\n      object.traverse(object => {\n        if (object.isSkinnedMesh) isSkinned = true;\n      });\n      if (isSkinned) return three_stdlib__WEBPACK_IMPORTED_MODULE_3__.SkeletonUtils.clone(object);\n    }\n    return object;\n  }, [object, isChild]);\n\n  // Deal with arrayed clones\n  if (Array.isArray(object)) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n      ref: forwardRef\n    }), object.map(o => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: o.uuid,\n      object: o\n    }, config))), children);\n  }\n\n  // Singleton clones\n  const {\n    children: injectChildren,\n    ...spread\n  } = createSpread(object, config);\n  const Element = object.type[0].toLowerCase() + object.type.slice(1);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Element, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, spread, props, {\n    ref: forwardRef\n  }), object.children.map(child => {\n    if (child.type === 'Bone') return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config));\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: child.uuid,\n      object: child\n    }, config, {\n      isChild: true\n    }));\n  }), children, injectChildren);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9DbG9uZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQkFBc0IsaURBQW9CO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEIsdURBQWE7QUFDekM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHdCQUF3QixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQ2hFO0FBQ0EsS0FBSyxnQ0FBZ0MsZ0RBQW1CLFFBQVEsOEVBQVE7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQixnREFBbUIsVUFBVSw4RUFBUSxHQUFHO0FBQzlEO0FBQ0EsR0FBRztBQUNILG1EQUFtRCxnREFBbUIsY0FBYyw4RUFBUTtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixnREFBbUIsUUFBUSw4RUFBUTtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVnQiIsInNvdXJjZXMiOlsiRDpcXE5nb2RzXFxyZXBvZ2l0aHViXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZHJlaVxcY29yZVxcQ2xvbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU2tlbGV0b25VdGlscyB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwcmVhZChjaGlsZCwge1xuICBrZXlzID0gWyduZWFyJywgJ2ZhcicsICdjb2xvcicsICdkaXN0YW5jZScsICdkZWNheScsICdwZW51bWJyYScsICdhbmdsZScsICdpbnRlbnNpdHknLCAnc2tlbGV0b24nLCAndmlzaWJsZScsICdjYXN0U2hhZG93JywgJ3JlY2VpdmVTaGFkb3cnLCAnbW9ycGhUYXJnZXREaWN0aW9uYXJ5JywgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsICduYW1lJywgJ2dlb21ldHJ5JywgJ21hdGVyaWFsJywgJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3NjYWxlJywgJ3VwJywgJ3VzZXJEYXRhJywgJ2JpbmRNb2RlJywgJ2JpbmRNYXRyaXgnLCAnYmluZE1hdHJpeEludmVyc2UnLCAnc2tlbGV0b24nXSxcbiAgZGVlcCxcbiAgaW5qZWN0LFxuICBjYXN0U2hhZG93LFxuICByZWNlaXZlU2hhZG93XG59KSB7XG4gIGxldCBzcHJlYWQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHNwcmVhZFtrZXldID0gY2hpbGRba2V5XTtcbiAgfVxuICBpZiAoZGVlcCkge1xuICAgIGlmIChzcHJlYWQuZ2VvbWV0cnkgJiYgZGVlcCAhPT0gJ21hdGVyaWFsc09ubHknKSBzcHJlYWQuZ2VvbWV0cnkgPSBzcHJlYWQuZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBpZiAoc3ByZWFkLm1hdGVyaWFsICYmIGRlZXAgIT09ICdnZW9tZXRyaWVzT25seScpIHNwcmVhZC5tYXRlcmlhbCA9IHNwcmVhZC5tYXRlcmlhbC5jbG9uZSgpO1xuICB9XG4gIGlmIChpbmplY3QpIHtcbiAgICBpZiAodHlwZW9mIGluamVjdCA9PT0gJ2Z1bmN0aW9uJykgc3ByZWFkID0ge1xuICAgICAgLi4uc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IGluamVjdChjaGlsZClcbiAgICB9O2Vsc2UgaWYgKC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChpbmplY3QpKSBzcHJlYWQgPSB7XG4gICAgICAuLi5zcHJlYWQsXG4gICAgICBjaGlsZHJlbjogaW5qZWN0XG4gICAgfTtlbHNlIHNwcmVhZCA9IHtcbiAgICAgIC4uLnNwcmVhZCxcbiAgICAgIC4uLmluamVjdFxuICAgIH07XG4gIH1cbiAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgIGlmIChjYXN0U2hhZG93KSBzcHJlYWQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgaWYgKHJlY2VpdmVTaGFkb3cpIHNwcmVhZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc3ByZWFkO1xufVxuY29uc3QgQ2xvbmUgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGlzQ2hpbGQgPSBmYWxzZSxcbiAgb2JqZWN0LFxuICBjaGlsZHJlbixcbiAgZGVlcCxcbiAgY2FzdFNoYWRvdyxcbiAgcmVjZWl2ZVNoYWRvdyxcbiAgaW5qZWN0LFxuICBrZXlzLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZFJlZikgPT4ge1xuICBjb25zdCBjb25maWcgPSB7XG4gICAga2V5cyxcbiAgICBkZWVwLFxuICAgIGluamVjdCxcbiAgICBjYXN0U2hhZG93LFxuICAgIHJlY2VpdmVTaGFkb3dcbiAgfTtcbiAgb2JqZWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGlzQ2hpbGQgPT09IGZhbHNlICYmICFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIGxldCBpc1NraW5uZWQgPSBmYWxzZTtcbiAgICAgIG9iamVjdC50cmF2ZXJzZShvYmplY3QgPT4ge1xuICAgICAgICBpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2gpIGlzU2tpbm5lZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc1NraW5uZWQpIHJldHVybiBTa2VsZXRvblV0aWxzLmNsb25lKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sIFtvYmplY3QsIGlzQ2hpbGRdKTtcblxuICAvLyBEZWFsIHdpdGggYXJyYXllZCBjbG9uZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiBmb3J3YXJkUmVmXG4gICAgfSksIG9iamVjdC5tYXAobyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDbG9uZSwgX2V4dGVuZHMoe1xuICAgICAga2V5OiBvLnV1aWQsXG4gICAgICBvYmplY3Q6IG9cbiAgICB9LCBjb25maWcpKSksIGNoaWxkcmVuKTtcbiAgfVxuXG4gIC8vIFNpbmdsZXRvbiBjbG9uZXNcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuOiBpbmplY3RDaGlsZHJlbixcbiAgICAuLi5zcHJlYWRcbiAgfSA9IGNyZWF0ZVNwcmVhZChvYmplY3QsIGNvbmZpZyk7XG4gIGNvbnN0IEVsZW1lbnQgPSBvYmplY3QudHlwZVswXS50b0xvd2VyQ2FzZSgpICsgb2JqZWN0LnR5cGUuc2xpY2UoMSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbGVtZW50LCBfZXh0ZW5kcyh7fSwgc3ByZWFkLCBwcm9wcywge1xuICAgIHJlZjogZm9yd2FyZFJlZlxuICB9KSwgb2JqZWN0LmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09ICdCb25lJykgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIF9leHRlbmRzKHtcbiAgICAgIGtleTogY2hpbGQudXVpZCxcbiAgICAgIG9iamVjdDogY2hpbGRcbiAgICB9LCBjb25maWcpKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvbmUsIF9leHRlbmRzKHtcbiAgICAgIGtleTogY2hpbGQudXVpZCxcbiAgICAgIG9iamVjdDogY2hpbGRcbiAgICB9LCBjb25maWcsIHtcbiAgICAgIGlzQ2hpbGQ6IHRydWVcbiAgICB9KSk7XG4gIH0pLCBjaGlsZHJlbiwgaW5qZWN0Q2hpbGRyZW4pO1xufSk7XG5cbmV4cG9ydCB7IENsb25lIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Clone.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      texture.dispose();\n    };\n  }, [texture]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 0.1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.gl);\n  const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.scene);\n  const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n  const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      fbo.dispose();\n    };\n  }, [fbo]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (frames === 1) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n    }\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)(() => {\n    if (frames === Infinity || count < frames) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n      count++;\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.o)(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n  const texture = props.map || textureDefault;\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n    GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n  }), []);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => {\n      textureDefault.dispose();\n    };\n  }, [textureDefault]);\n  const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n    map: texture\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMyRDtBQUN0QjtBQUNsQjtBQUNHOztBQUVyRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscURBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLHFEQUFRO0FBQy9CLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0Isa0VBQWM7QUFDaEMsdUJBQXVCLHFEQUFRO0FBQy9CLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWEscURBQVE7QUFDckIsdUJBQXVCLHFEQUFRO0FBQy9CLGlCQUFpQix5Q0FBWTtBQUM3Qix5QkFBeUIsMkNBQWMsV0FBVyx3Q0FBSztBQUN2RCxjQUFjLDBDQUFhO0FBQzNCLG9CQUFvQix3REFBcUI7QUFDekMsdUJBQXVCLGdEQUFhO0FBQ3BDO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxFQUFFLHFEQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLFFBQVEscURBQVksY0FBYyxnREFBbUIsQ0FBQywyQ0FBYywrQkFBK0IsZ0RBQW1CO0FBQzlLO0FBQ0E7QUFDQSxHQUFHLGtDQUFrQyxnREFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLGdEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFjO0FBQ3ZDO0FBQ0EsRUFBRSwwQ0FBYSxPQUFPLHFEQUFNO0FBQzVCLDRCQUE0Qiw0REFBa0I7QUFDOUMsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsMENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLHFCQUFxQixnREFBbUIsaUJBQWlCLDhFQUFRLEdBQUc7QUFDNUg7QUFDQSxHQUFHLGlCQUFpQixnREFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFDQUFxQyxnREFBbUIsc0RBQXNELGdEQUFtQix3REFBd0QsZ0RBQW1CLDBDQUEwQyxnREFBbUI7QUFDelE7O0FBRTJFIiwic291cmNlcyI6WyJEOlxcTmdvZHNcXHJlcG9naXRodWJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxFbnZpcm9ubWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUsIGNyZWF0ZVBvcnRhbCwgYXBwbHlQcm9wcywgZXh0ZW5kIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IFNjZW5lLCBXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIEhhbGZGbG9hdFR5cGUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBHcm91bmRQcm9qZWN0ZWRFbnYgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgdXNlRW52aXJvbm1lbnQgfSBmcm9tICcuL3VzZUVudmlyb25tZW50LmpzJztcblxuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqLmN1cnJlbnQgJiYgb2JqLmN1cnJlbnQuaXNTY2VuZTtcbmNvbnN0IHJlc29sdmVTY2VuZSA9IHNjZW5lID0+IGlzUmVmKHNjZW5lKSA/IHNjZW5lLmN1cnJlbnQgOiBzY2VuZTtcbmZ1bmN0aW9uIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIHRleHR1cmUsIHNjZW5lUHJvcHMgPSB7fSkge1xuICB2YXIgX3RhcmdldCRiYWNrZ3JvdW5kUm90LCBfdGFyZ2V0JGJhY2tncm91bmRSb3QyLCBfdGFyZ2V0JGVudmlyb25tZW50Um8sIF90YXJnZXQkZW52aXJvbm1lbnRSbzI7XG4gIC8vIGRlZmF1bHRzXG4gIHNjZW5lUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IDAsXG4gICAgYmFja2dyb3VuZEludGVuc2l0eTogMSxcbiAgICBiYWNrZ3JvdW5kUm90YXRpb246IFswLCAwLCAwXSxcbiAgICBlbnZpcm9ubWVudEludGVuc2l0eTogMSxcbiAgICBlbnZpcm9ubWVudFJvdGF0aW9uOiBbMCwgMCwgMF0sXG4gICAgLi4uc2NlbmVQcm9wc1xuICB9O1xuICBjb25zdCB0YXJnZXQgPSByZXNvbHZlU2NlbmUoc2NlbmUgfHwgZGVmYXVsdFNjZW5lKTtcbiAgY29uc3Qgb2xkYmcgPSB0YXJnZXQuYmFja2dyb3VuZDtcbiAgY29uc3Qgb2xkZW52ID0gdGFyZ2V0LmVudmlyb25tZW50O1xuICBjb25zdCBvbGRTY2VuZVByb3BzID0ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5OiB0YXJnZXQuYmFja2dyb3VuZEludGVuc2l0eSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYmFja2dyb3VuZFJvdGF0aW9uOiAoX3RhcmdldCRiYWNrZ3JvdW5kUm90ID0gKF90YXJnZXQkYmFja2dyb3VuZFJvdDIgPSB0YXJnZXQuYmFja2dyb3VuZFJvdGF0aW9uKSA9PSBudWxsIHx8IF90YXJnZXQkYmFja2dyb3VuZFJvdDIuY2xvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkYmFja2dyb3VuZFJvdDIuY2xvbmUoKSkgIT09IG51bGwgJiYgX3RhcmdldCRiYWNrZ3JvdW5kUm90ICE9PSB2b2lkIDAgPyBfdGFyZ2V0JGJhY2tncm91bmRSb3QgOiBbMCwgMCwgMF0sXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVudmlyb25tZW50SW50ZW5zaXR5OiB0YXJnZXQuZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVudmlyb25tZW50Um90YXRpb246IChfdGFyZ2V0JGVudmlyb25tZW50Um8gPSAoX3RhcmdldCRlbnZpcm9ubWVudFJvMiA9IHRhcmdldC5lbnZpcm9ubWVudFJvdGF0aW9uKSA9PSBudWxsIHx8IF90YXJnZXQkZW52aXJvbm1lbnRSbzIuY2xvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkZW52aXJvbm1lbnRSbzIuY2xvbmUoKSkgIT09IG51bGwgJiYgX3RhcmdldCRlbnZpcm9ubWVudFJvICE9PSB2b2lkIDAgPyBfdGFyZ2V0JGVudmlyb25tZW50Um8gOiBbMCwgMCwgMF1cbiAgfTtcbiAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gdGV4dHVyZTtcbiAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gdGV4dHVyZTtcbiAgYXBwbHlQcm9wcyh0YXJnZXQsIHNjZW5lUHJvcHMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChiYWNrZ3JvdW5kICE9PSAnb25seScpIHRhcmdldC5lbnZpcm9ubWVudCA9IG9sZGVudjtcbiAgICBpZiAoYmFja2dyb3VuZCkgdGFyZ2V0LmJhY2tncm91bmQgPSBvbGRiZztcbiAgICBhcHBseVByb3BzKHRhcmdldCwgb2xkU2NlbmVQcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudE1hcCh7XG4gIHNjZW5lLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIG1hcCxcbiAgLi4uY29uZmlnXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwKSByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgbWFwLCBjb25maWcpO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudEN1YmUoe1xuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIHNjZW5lLFxuICBibHVyLFxuICBiYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICBlbnZpcm9ubWVudEludGVuc2l0eSxcbiAgZW52aXJvbm1lbnRSb3RhdGlvbixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCB0ZXh0dXJlID0gdXNlRW52aXJvbm1lbnQocmVzdCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwge1xuICAgICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IGJsdXIgIT09IG51bGwgJiYgYmx1ciAhPT0gdm9pZCAwID8gYmx1ciA6IGJhY2tncm91bmRCbHVycmluZXNzLFxuICAgICAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgICAgIGJhY2tncm91bmRSb3RhdGlvbixcbiAgICAgIGVudmlyb25tZW50SW50ZW5zaXR5LFxuICAgICAgZW52aXJvbm1lbnRSb3RhdGlvblxuICAgIH0pO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgfSwgW3RleHR1cmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudFBvcnRhbCh7XG4gIGNoaWxkcmVuLFxuICBuZWFyID0gMC4xLFxuICBmYXIgPSAxMDAwLFxuICByZXNvbHV0aW9uID0gMjU2LFxuICBmcmFtZXMgPSAxLFxuICBtYXAsXG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgYmx1cixcbiAgYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gIGJhY2tncm91bmRJbnRlbnNpdHksXG4gIGJhY2tncm91bmRSb3RhdGlvbixcbiAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gIGVudmlyb25tZW50Um90YXRpb24sXG4gIHNjZW5lLFxuICBmaWxlcyxcbiAgcGF0aCxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBleHRlbnNpb25zXG59KSB7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIGNvbnN0IGNhbWVyYSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3ZpcnR1YWxTY2VuZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgU2NlbmUoKSk7XG4gIGNvbnN0IGZibyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGZibyA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQocmVzb2x1dGlvbik7XG4gICAgZmJvLnRleHR1cmUudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgcmV0dXJuIGZibztcbiAgfSwgW3Jlc29sdXRpb25dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZmJvLmRpc3Bvc2UoKTtcbiAgICB9O1xuICB9LCBbZmJvXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gMSkge1xuICAgICAgY29uc3QgYXV0b0NsZWFyID0gZ2wuYXV0b0NsZWFyO1xuICAgICAgZ2wuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICAgIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICAgIGdsLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcbiAgICB9XG4gICAgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGZiby50ZXh0dXJlLCB7XG4gICAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogYmx1ciAhPT0gbnVsbCAmJiBibHVyICE9PSB2b2lkIDAgPyBibHVyIDogYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gICAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICAgICAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICAgICAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gICAgICBlbnZpcm9ubWVudFJvdGF0aW9uXG4gICAgfSk7XG4gIH0sIFtjaGlsZHJlbiwgdmlydHVhbFNjZW5lLCBmYm8udGV4dHVyZSwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgYmFja2dyb3VuZCwgZnJhbWVzLCBnbF0pO1xuICBsZXQgY291bnQgPSAxO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpIHtcbiAgICAgIGNvbnN0IGF1dG9DbGVhciA9IGdsLmF1dG9DbGVhcjtcbiAgICAgIGdsLmF1dG9DbGVhciA9IHRydWU7XG4gICAgICBjYW1lcmEuY3VycmVudC51cGRhdGUoZ2wsIHZpcnR1YWxTY2VuZSk7XG4gICAgICBnbC5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY3JlYXRlUG9ydGFsKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIsIHtcbiAgICByZWY6IGNhbWVyYSxcbiAgICBhcmdzOiBbbmVhciwgZmFyLCBmYm9dXG4gIH0pLCBmaWxlcyB8fCBwcmVzZXQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIGZpbGVzOiBmaWxlcyxcbiAgICBwcmVzZXQ6IHByZXNldCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBtYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgbWFwOiBtYXAsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG51bGwpLCB2aXJ0dWFsU2NlbmUpKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50R3JvdW5kKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkZ3JvdW5kLCBfcHJvcHMkZ3JvdW5kMiwgX3NjYWxlLCBfcHJvcHMkZ3JvdW5kMztcbiAgY29uc3QgdGV4dHVyZURlZmF1bHQgPSB1c2VFbnZpcm9ubWVudChwcm9wcyk7XG4gIGNvbnN0IHRleHR1cmUgPSBwcm9wcy5tYXAgfHwgdGV4dHVyZURlZmF1bHQ7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBHcm91bmRQcm9qZWN0ZWRFbnZJbXBsOiBHcm91bmRQcm9qZWN0ZWRFbnZcbiAgfSksIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGV4dHVyZURlZmF1bHQuZGlzcG9zZSgpO1xuICAgIH07XG4gIH0sIFt0ZXh0dXJlRGVmYXVsdF0pO1xuICBjb25zdCBhcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiBbdGV4dHVyZV0sIFt0ZXh0dXJlXSk7XG4gIGNvbnN0IGhlaWdodCA9IChfcHJvcHMkZ3JvdW5kID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZC5oZWlnaHQ7XG4gIGNvbnN0IHJhZGl1cyA9IChfcHJvcHMkZ3JvdW5kMiA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQyLnJhZGl1cztcbiAgY29uc3Qgc2NhbGUgPSAoX3NjYWxlID0gKF9wcm9wcyRncm91bmQzID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZDMuc2NhbGUpICE9PSBudWxsICYmIF9zY2FsZSAhPT0gdm9pZCAwID8gX3NjYWxlIDogMTAwMDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgbWFwOiB0ZXh0dXJlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91bmRQcm9qZWN0ZWRFbnZJbXBsXCIsIHtcbiAgICBhcmdzOiBhcmdzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByYWRpdXM6IHJhZGl1c1xuICB9KSk7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuZ3JvdW5kID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRHcm91bmQsIHByb3BzKSA6IHByb3BzLm1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCBwcm9wcykgOiBwcm9wcy5jaGlsZHJlbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50UG9ydGFsLCBwcm9wcykgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHByb3BzKTtcbn1cblxuZXhwb3J0IHsgRW52aXJvbm1lbnQsIEVudmlyb25tZW50Q3ViZSwgRW52aXJvbm1lbnRNYXAsIEVudmlyb25tZW50UG9ydGFsIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Gltf.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Gltf.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gltf: () => (/* binding */ Gltf),\n/* harmony export */   useGLTF: () => (/* binding */ useGLTF)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var _Clone_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Clone.js */ \"(ssr)/./node_modules/@react-three/drei/core/Clone.js\");\n\n\n\n\n\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco = true, useMeshopt = true, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_2__.DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder === 'function' ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_3__.MeshoptDecoder);\n    }\n  };\n}\nconst useGLTF = (path, useDraco, useMeshopt, extendLoader) => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G)(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.preload = (path, useDraco, useMeshopt, extendLoader) => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.clear = path => _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.G.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader, path);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Clone_js__WEBPACK_IMPORTED_MODULE_6__.Clone, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HbHRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDd0M7QUFDeEI7QUFDWjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQWMsa0JBQWtCLDREQUFjLEtBQUssd0RBQWM7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFEQUFTLENBQUMsb0RBQVU7QUFDbEYsZ0VBQWdFLGlEQUFTLFNBQVMsb0RBQVU7QUFDNUYsd0JBQXdCLGlEQUFTLE9BQU8sb0RBQVU7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qiw2Q0FBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixnREFBbUIsQ0FBQyw0Q0FBSyxFQUFFLDhFQUFRO0FBQ3pEO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRXdCIiwic291cmNlcyI6WyJEOlxcTmdvZHNcXHJlcG9naXRodWJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxHbHRmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEdMVEZMb2FkZXIsIERSQUNPTG9hZGVyLCBNZXNob3B0RGVjb2RlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgQ2xvbmUgfSBmcm9tICcuL0Nsb25lLmpzJztcblxubGV0IGRyYWNvTG9hZGVyID0gbnVsbDtcbmxldCBkZWNvZGVyUGF0aCA9ICdodHRwczovL3d3dy5nc3RhdGljLmNvbS9kcmFjby92ZXJzaW9uZWQvZGVjb2RlcnMvMS41LjUvJztcbmZ1bmN0aW9uIGV4dGVuc2lvbnModXNlRHJhY28gPSB0cnVlLCB1c2VNZXNob3B0ID0gdHJ1ZSwgZXh0ZW5kTG9hZGVyKSB7XG4gIHJldHVybiBsb2FkZXIgPT4ge1xuICAgIGlmIChleHRlbmRMb2FkZXIpIHtcbiAgICAgIGV4dGVuZExvYWRlcihsb2FkZXIpO1xuICAgIH1cbiAgICBpZiAodXNlRHJhY28pIHtcbiAgICAgIGlmICghZHJhY29Mb2FkZXIpIHtcbiAgICAgICAgZHJhY29Mb2FkZXIgPSBuZXcgRFJBQ09Mb2FkZXIoKTtcbiAgICAgIH1cbiAgICAgIGRyYWNvTG9hZGVyLnNldERlY29kZXJQYXRoKHR5cGVvZiB1c2VEcmFjbyA9PT0gJ3N0cmluZycgPyB1c2VEcmFjbyA6IGRlY29kZXJQYXRoKTtcbiAgICAgIGxvYWRlci5zZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcik7XG4gICAgfVxuICAgIGlmICh1c2VNZXNob3B0KSB7XG4gICAgICBsb2FkZXIuc2V0TWVzaG9wdERlY29kZXIodHlwZW9mIE1lc2hvcHREZWNvZGVyID09PSAnZnVuY3Rpb24nID8gTWVzaG9wdERlY29kZXIoKSA6IE1lc2hvcHREZWNvZGVyKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCB1c2VHTFRGID0gKHBhdGgsIHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpID0+IHVzZUxvYWRlcihHTFRGTG9hZGVyLCBwYXRoLCBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpKTtcbnVzZUdMVEYucHJlbG9hZCA9IChwYXRoLCB1c2VEcmFjbywgdXNlTWVzaG9wdCwgZXh0ZW5kTG9hZGVyKSA9PiB1c2VMb2FkZXIucHJlbG9hZChHTFRGTG9hZGVyLCBwYXRoLCBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpKTtcbnVzZUdMVEYuY2xlYXIgPSBwYXRoID0+IHVzZUxvYWRlci5jbGVhcihHTFRGTG9hZGVyLCBwYXRoKTtcbnVzZUdMVEYuc2V0RGVjb2RlclBhdGggPSBwYXRoID0+IHtcbiAgZGVjb2RlclBhdGggPSBwYXRoO1xufTtcblxuLy9cblxuY29uc3QgR2x0ZiA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgc3JjLFxuICB1c2VEcmFjbyxcbiAgdXNlTWVzaE9wdCxcbiAgZXh0ZW5kTG9hZGVyLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzY2VuZVxuICB9ID0gdXNlR0xURihzcmMsIHVzZURyYWNvLCB1c2VNZXNoT3B0LCBleHRlbmRMb2FkZXIpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvbmUsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcywge1xuICAgIG9iamVjdDogc2NlbmVcbiAgfSkpO1xufSk7XG5cbmV4cG9ydCB7IEdsdGYsIHVzZUdMVEYgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Gltf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Lightformer.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Lightformer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lightformer: () => (/* binding */ Lightformer)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n\n\n\nconst Lightformer = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  light,\n  args,\n  map,\n  toneMapped = false,\n  color = 'white',\n  form: Form = 'rect',\n  intensity = 1,\n  scale = 1,\n  target = [0, 0, 0],\n  children,\n  ...props\n}, forwardRef) => {\n  // Apply emissive power\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardRef, () => ref.current, []);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (!children && !props.material) {\n      (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.s)(ref.current.material, {\n        color\n      });\n      ref.current.material.color.multiplyScalar(intensity);\n    }\n  }, [color, intensity, children, props.material]);\n\n  // Target light\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    if (!props.rotation) ref.current.quaternion.identity();\n    if (target && !props.rotation) {\n      'boolean' === typeof target ? ref.current.lookAt(0, 0, 0) : ref.current.lookAt(Array.isArray(target) ? new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(...target) : target);\n    }\n  }, [target, props.rotation]);\n\n  // Fix 2-dimensional scale\n  scale = Array.isArray(scale) && scale.length === 2 ? [scale[0], scale[1], 1] : scale;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: ref,\n    scale: scale\n  }, props), Form === 'circle' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"ringGeometry\", {\n    args: args ? args : [0, 0.5, 64]\n  }) : Form === 'ring' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"ringGeometry\", {\n    args: args ? args : [0.25, 0.5, 64]\n  }) : Form === 'rect' || Form === 'plane' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", {\n    args: args ? args : [1, 1]\n  }) : Form === 'box' ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"boxGeometry\", {\n    args: args ? args : [1, 1, 1]\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Form, {\n    args: args\n  }), children ? children : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n    toneMapped: toneMapped,\n    map: map,\n    side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide\n  }), light && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"pointLight\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    castShadow: true\n  }, light)));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9MaWdodGZvcm1lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDVjtBQUNqQjtBQUNBOztBQUUvQixtQ0FBbUMsNkNBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLHlDQUFZO0FBQzFCLEVBQUUsc0RBQXlCO0FBQzNCLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0EsTUFBTSxxREFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQSxpSEFBaUgsMENBQWE7QUFDOUg7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CLFNBQVMsOEVBQVE7QUFDMUQ7QUFDQTtBQUNBLEdBQUcsMkNBQTJDLGdEQUFtQjtBQUNqRTtBQUNBLEdBQUcsbUNBQW1DLGdEQUFtQjtBQUN6RDtBQUNBLEdBQUcsdURBQXVELGdEQUFtQjtBQUM3RTtBQUNBLEdBQUcsa0NBQWtDLGdEQUFtQjtBQUN4RDtBQUNBLEdBQUcsaUJBQWlCLGdEQUFtQjtBQUN2QztBQUNBLEdBQUcsc0NBQXNDLGdEQUFtQjtBQUM1RDtBQUNBO0FBQ0EsVUFBVSw2Q0FBZ0I7QUFDMUIsR0FBRyx5QkFBeUIsZ0RBQW1CLGVBQWUsOEVBQVE7QUFDdEU7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFc0IiLCJzb3VyY2VzIjpbIkQ6XFxOZ29kc1xccmVwb2dpdGh1Ylxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGNvcmVcXExpZ2h0Zm9ybWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IGFwcGx5UHJvcHMgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5jb25zdCBMaWdodGZvcm1lciA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgbGlnaHQsXG4gIGFyZ3MsXG4gIG1hcCxcbiAgdG9uZU1hcHBlZCA9IGZhbHNlLFxuICBjb2xvciA9ICd3aGl0ZScsXG4gIGZvcm06IEZvcm0gPSAncmVjdCcsXG4gIGludGVuc2l0eSA9IDEsXG4gIHNjYWxlID0gMSxcbiAgdGFyZ2V0ID0gWzAsIDAsIDBdLFxuICBjaGlsZHJlbixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRSZWYpID0+IHtcbiAgLy8gQXBwbHkgZW1pc3NpdmUgcG93ZXJcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRSZWYsICgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGlsZHJlbiAmJiAhcHJvcHMubWF0ZXJpYWwpIHtcbiAgICAgIGFwcGx5UHJvcHMocmVmLmN1cnJlbnQubWF0ZXJpYWwsIHtcbiAgICAgICAgY29sb3JcbiAgICAgIH0pO1xuICAgICAgcmVmLmN1cnJlbnQubWF0ZXJpYWwuY29sb3IubXVsdGlwbHlTY2FsYXIoaW50ZW5zaXR5KTtcbiAgICB9XG4gIH0sIFtjb2xvciwgaW50ZW5zaXR5LCBjaGlsZHJlbiwgcHJvcHMubWF0ZXJpYWxdKTtcblxuICAvLyBUYXJnZXQgbGlnaHRcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXByb3BzLnJvdGF0aW9uKSByZWYuY3VycmVudC5xdWF0ZXJuaW9uLmlkZW50aXR5KCk7XG4gICAgaWYgKHRhcmdldCAmJiAhcHJvcHMucm90YXRpb24pIHtcbiAgICAgICdib29sZWFuJyA9PT0gdHlwZW9mIHRhcmdldCA/IHJlZi5jdXJyZW50Lmxvb2tBdCgwLCAwLCAwKSA6IHJlZi5jdXJyZW50Lmxvb2tBdChBcnJheS5pc0FycmF5KHRhcmdldCkgPyBuZXcgVEhSRUUuVmVjdG9yMyguLi50YXJnZXQpIDogdGFyZ2V0KTtcbiAgICB9XG4gIH0sIFt0YXJnZXQsIHByb3BzLnJvdGF0aW9uXSk7XG5cbiAgLy8gRml4IDItZGltZW5zaW9uYWwgc2NhbGVcbiAgc2NhbGUgPSBBcnJheS5pc0FycmF5KHNjYWxlKSAmJiBzY2FsZS5sZW5ndGggPT09IDIgPyBbc2NhbGVbMF0sIHNjYWxlWzFdLCAxXSA6IHNjYWxlO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBzY2FsZTogc2NhbGVcbiAgfSwgcHJvcHMpLCBGb3JtID09PSAnY2lyY2xlJyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicmluZ0dlb21ldHJ5XCIsIHtcbiAgICBhcmdzOiBhcmdzID8gYXJncyA6IFswLCAwLjUsIDY0XVxuICB9KSA6IEZvcm0gPT09ICdyaW5nJyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicmluZ0dlb21ldHJ5XCIsIHtcbiAgICBhcmdzOiBhcmdzID8gYXJncyA6IFswLjI1LCAwLjUsIDY0XVxuICB9KSA6IEZvcm0gPT09ICdyZWN0JyB8fCBGb3JtID09PSAncGxhbmUnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsIHtcbiAgICBhcmdzOiBhcmdzID8gYXJncyA6IFsxLCAxXVxuICB9KSA6IEZvcm0gPT09ICdib3gnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJib3hHZW9tZXRyeVwiLCB7XG4gICAgYXJnczogYXJncyA/IGFyZ3MgOiBbMSwgMSwgMV1cbiAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtLCB7XG4gICAgYXJnczogYXJnc1xuICB9KSwgY2hpbGRyZW4gPyBjaGlsZHJlbiA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIiwge1xuICAgIHRvbmVNYXBwZWQ6IHRvbmVNYXBwZWQsXG4gICAgbWFwOiBtYXAsXG4gICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZVxuICB9KSwgbGlnaHQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2ludExpZ2h0XCIsIF9leHRlbmRzKHtcbiAgICBjYXN0U2hhZG93OiB0cnVlXG4gIH0sIGxpZ2h0KSkpO1xufSk7XG5cbmV4cG9ydCB7IExpZ2h0Zm9ybWVyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Lightformer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Texture.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Texture.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsObject: () => (/* binding */ IsObject),\n/* harmony export */   Texture: () => (/* binding */ Texture),\n/* harmony export */   useTexture: () => (/* binding */ useTexture)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n\n\n\n\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input, onLoad) {\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.C)(state => state.gl);\n  const textures = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G)(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, IsObject(input) ? Object.values(input) : input);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    onLoad == null || onLoad(textures);\n  }, [onLoad]);\n\n  // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n  // NOTE: only available for WebGLRenderer\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if ('initTexture' in gl) {\n      let textureArray = [];\n      if (Array.isArray(textures)) {\n        textureArray = textures;\n      } else if (textures instanceof three__WEBPACK_IMPORTED_MODULE_2__.Texture) {\n        textureArray = [textures];\n      } else if (IsObject(textures)) {\n        textureArray = Object.values(textures);\n      }\n      textureArray.forEach(texture => {\n        if (texture instanceof three__WEBPACK_IMPORTED_MODULE_2__.Texture) {\n          gl.initTexture(texture);\n        }\n      });\n    }\n  }, [gl, textures]);\n  const mappedTextures = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (IsObject(input)) {\n      const keyed = {};\n      let i = 0;\n      for (const key in input) keyed[key] = textures[i++];\n      return keyed;\n    } else {\n      return textures;\n    }\n  }, [input, textures]);\n  return mappedTextures;\n}\nuseTexture.preload = url => _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G.preload(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, url);\nuseTexture.clear = input => _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.G.clear(three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader, input);\n\n//\n\nconst Texture = ({\n  children,\n  input,\n  onLoad\n}) => {\n  const ret = useTexture(input, onLoad);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children == null ? void 0 : children(ret));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9UZXh0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDNkI7QUFDQTtBQUNIOztBQUV6RDtBQUNBO0FBQ0EsYUFBYSxxREFBUTtBQUNyQixtQkFBbUIscURBQVMsQ0FBQyxnREFBYTtBQUMxQyxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZCQUE2QiwwQ0FBUztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQVM7QUFDeEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsOENBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVMsU0FBUyxnREFBYTtBQUMzRCw0QkFBNEIsaURBQVMsT0FBTyxnREFBYTs7QUFFekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQkFBc0IsZ0RBQW1CLENBQUMsMkNBQWM7QUFDeEQ7O0FBRXlDIiwic291cmNlcyI6WyJEOlxcTmdvZHNcXHJlcG9naXRodWJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFxUZXh0dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGV4dHVyZUxvYWRlciwgVGV4dHVyZSBhcyBUZXh0dXJlJDEgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlTG9hZGVyIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcblxuY29uc3QgSXNPYmplY3QgPSB1cmwgPT4gdXJsID09PSBPYmplY3QodXJsKSAmJiAhQXJyYXkuaXNBcnJheSh1cmwpICYmIHR5cGVvZiB1cmwgIT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiB1c2VUZXh0dXJlKGlucHV0LCBvbkxvYWQpIHtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IHRleHR1cmVzID0gdXNlTG9hZGVyKFRleHR1cmVMb2FkZXIsIElzT2JqZWN0KGlucHV0KSA/IE9iamVjdC52YWx1ZXMoaW5wdXQpIDogaW5wdXQpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG9uTG9hZCA9PSBudWxsIHx8IG9uTG9hZCh0ZXh0dXJlcyk7XG4gIH0sIFtvbkxvYWRdKTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMjY5NlxuICAvLyBVcGxvYWQgdGhlIHRleHR1cmUgdG8gdGhlIEdQVSBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gTk9URTogb25seSBhdmFpbGFibGUgZm9yIFdlYkdMUmVuZGVyZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoJ2luaXRUZXh0dXJlJyBpbiBnbCkge1xuICAgICAgbGV0IHRleHR1cmVBcnJheSA9IFtdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dHVyZXMpKSB7XG4gICAgICAgIHRleHR1cmVBcnJheSA9IHRleHR1cmVzO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0dXJlcyBpbnN0YW5jZW9mIFRleHR1cmUkMSkge1xuICAgICAgICB0ZXh0dXJlQXJyYXkgPSBbdGV4dHVyZXNdO1xuICAgICAgfSBlbHNlIGlmIChJc09iamVjdCh0ZXh0dXJlcykpIHtcbiAgICAgICAgdGV4dHVyZUFycmF5ID0gT2JqZWN0LnZhbHVlcyh0ZXh0dXJlcyk7XG4gICAgICB9XG4gICAgICB0ZXh0dXJlQXJyYXkuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgaWYgKHRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlJDEpIHtcbiAgICAgICAgICBnbC5pbml0VGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZ2wsIHRleHR1cmVzXSk7XG4gIGNvbnN0IG1hcHBlZFRleHR1cmVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKElzT2JqZWN0KGlucHV0KSkge1xuICAgICAgY29uc3Qga2V5ZWQgPSB7fTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSBrZXllZFtrZXldID0gdGV4dHVyZXNbaSsrXTtcbiAgICAgIHJldHVybiBrZXllZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHR1cmVzO1xuICAgIH1cbiAgfSwgW2lucHV0LCB0ZXh0dXJlc10pO1xuICByZXR1cm4gbWFwcGVkVGV4dHVyZXM7XG59XG51c2VUZXh0dXJlLnByZWxvYWQgPSB1cmwgPT4gdXNlTG9hZGVyLnByZWxvYWQoVGV4dHVyZUxvYWRlciwgdXJsKTtcbnVzZVRleHR1cmUuY2xlYXIgPSBpbnB1dCA9PiB1c2VMb2FkZXIuY2xlYXIoVGV4dHVyZUxvYWRlciwgaW5wdXQpO1xuXG4vL1xuXG5jb25zdCBUZXh0dXJlID0gKHtcbiAgY2hpbGRyZW4sXG4gIGlucHV0LFxuICBvbkxvYWRcbn0pID0+IHtcbiAgY29uc3QgcmV0ID0gdXNlVGV4dHVyZShpbnB1dCwgb25Mb2FkKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4ocmV0KSk7XG59O1xuXG5leHBvcnQgeyBJc09iamVjdCwgVGV4dHVyZSwgdXNlVGV4dHVyZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Texture.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @monogrid/gainmap-js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nconst defaultFiles = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'];\nfunction useEnvironment({\n  files = defaultFiles,\n  path = '',\n  preset = undefined,\n  colorSpace = undefined,\n  extensions\n} = {}) {\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  // Everything else\n  const multiFile = isArray(files);\n  const {\n    extension,\n    isCubemap\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(state => state.gl);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    // Only required for gainmap\n    if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;\n    function clearGainmapTexture() {\n      _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.clear(loader, multiFile ? [files] : files);\n    }\n    gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {\n      once: true\n    });\n  }, [files, gl.domElement]);\n  const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G)(loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      // @ts-expect-error\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? three__WEBPACK_IMPORTED_MODULE_3__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;\n  texture.colorSpace = colorSpace !== null && colorSpace !== void 0 ? colorSpace : isCubemap ? 'srgb' : 'srgb-linear';\n  return texture;\n}\nconst preloadDefaultOptions = {\n  files: defaultFiles,\n  path: '',\n  preset: undefined,\n  extensions: undefined\n};\nuseEnvironment.preload = preloadOptions => {\n  const options = {\n    ...preloadDefaultOptions,\n    ...preloadOptions\n  };\n  let {\n    files,\n    path = ''\n  } = options;\n  const {\n    preset,\n    extensions\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const {\n    extension\n  } = getExtension(files);\n  if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n    throw new Error('useEnvironment: Preloading gainmaps is not supported');\n  }\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.preload(loader, isArray(files) ? [files] : files, loader => {\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n};\nconst clearDefaultOptins = {\n  files: defaultFiles,\n  preset: undefined\n};\nuseEnvironment.clear = clearOptions => {\n  const options = {\n    ...clearDefaultOptins,\n    ...clearOptions\n  };\n  let {\n    files\n  } = options;\n  const {\n    preset\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n  }\n  const {\n    extension\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.G.clear(loader, isArray(files) ? [files] : files);\n};\nfunction validatePreset(preset) {\n  if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj).join(', '));\n}\nfunction getExtension(files) {\n  var _firstEntry$split$pop;\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  const extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  return {\n    extension,\n    isCubemap,\n    isGainmap\n  };\n}\nfunction getLoader(extension) {\n  const loader = extension === 'cube' ? three__WEBPACK_IMPORTED_MODULE_3__.CubeTextureLoader : extension === 'hdr' ? three_stdlib__WEBPACK_IMPORTED_MODULE_4__.RGBELoader : extension === 'exr' ? three_stdlib__WEBPACK_IMPORTED_MODULE_5__.EXRLoader : extension === 'jpg' || extension === 'jpeg' ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__.HDRJPGLoader : extension === 'webp' ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_6__.GainMapLoader : null;\n  return loader;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDMEM7QUFDOUM7QUFDYztBQUNMO0FBQ3RCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0EsWUFBWSxzRUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWEscURBQVE7QUFDckIsRUFBRSxzREFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCx1QkFBdUIscURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3REFBcUIsR0FBRyxtRUFBZ0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksc0VBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaURBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFlBQVksc0VBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFLGlEQUFTO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQixzRUFBVSwyREFBMkQsc0VBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBaUIseUJBQXlCLG9EQUFVLHlCQUF5QixtREFBUyxpREFBaUQsOERBQVksMEJBQTBCLCtEQUFhO0FBQ2xPO0FBQ0E7O0FBRTBCIiwic291cmNlcyI6WyJEOlxcTmdvZHNcXHJlcG9naXRodWJcXG5vZGVfbW9kdWxlc1xcQHJlYWN0LXRocmVlXFxkcmVpXFxjb3JlXFx1c2VFbnZpcm9ubWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VUaHJlZSwgdXNlTG9hZGVyIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IEN1YmVSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVUZXh0dXJlTG9hZGVyIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUkdCRUxvYWRlciwgRVhSTG9hZGVyIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IEhEUkpQR0xvYWRlciwgR2Fpbk1hcExvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJztcbmltcG9ydCB7IHByZXNldHNPYmogfSBmcm9tICcuLi9oZWxwZXJzL2Vudmlyb25tZW50LWFzc2V0cy5qcyc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IENVQkVNQVBfUk9PVCA9ICdodHRwczovL3Jhdy5naXRoYWNrLmNvbS9wbW5kcnMvZHJlaS1hc3NldHMvNDU2MDYwYTI2YmJlYjhmZGY3OTMyNmYyMjRiNmQ5OWI4YmNjZTczNi9oZHJpLyc7XG5jb25zdCBpc0FycmF5ID0gYXJyID0+IEFycmF5LmlzQXJyYXkoYXJyKTtcbmNvbnN0IGRlZmF1bHRGaWxlcyA9IFsnL3B4LnBuZycsICcvbngucG5nJywgJy9weS5wbmcnLCAnL255LnBuZycsICcvcHoucG5nJywgJy9uei5wbmcnXTtcbmZ1bmN0aW9uIHVzZUVudmlyb25tZW50KHtcbiAgZmlsZXMgPSBkZWZhdWx0RmlsZXMsXG4gIHBhdGggPSAnJyxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBjb2xvclNwYWNlID0gdW5kZWZpbmVkLFxuICBleHRlbnNpb25zXG59ID0ge30pIHtcbiAgaWYgKHByZXNldCkge1xuICAgIHZhbGlkYXRlUHJlc2V0KHByZXNldCk7XG4gICAgZmlsZXMgPSBwcmVzZXRzT2JqW3ByZXNldF07XG4gICAgcGF0aCA9IENVQkVNQVBfUk9PVDtcbiAgfVxuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZVxuICBjb25zdCBtdWx0aUZpbGUgPSBpc0FycmF5KGZpbGVzKTtcbiAgY29uc3Qge1xuICAgIGV4dGVuc2lvbixcbiAgICBpc0N1YmVtYXBcbiAgfSA9IGdldEV4dGVuc2lvbihmaWxlcyk7XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihleHRlbnNpb24pO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBPbmx5IHJlcXVpcmVkIGZvciBnYWlubWFwXG4gICAgaWYgKGV4dGVuc2lvbiAhPT0gJ3dlYnAnICYmIGV4dGVuc2lvbiAhPT0gJ2pwZycgJiYgZXh0ZW5zaW9uICE9PSAnanBlZycpIHJldHVybjtcbiAgICBmdW5jdGlvbiBjbGVhckdhaW5tYXBUZXh0dXJlKCkge1xuICAgICAgdXNlTG9hZGVyLmNsZWFyKGxvYWRlciwgbXVsdGlGaWxlID8gW2ZpbGVzXSA6IGZpbGVzKTtcbiAgICB9XG4gICAgZ2wuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgY2xlYXJHYWlubWFwVGV4dHVyZSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbZmlsZXMsIGdsLmRvbUVsZW1lbnRdKTtcbiAgY29uc3QgbG9hZGVyUmVzdWx0ID0gdXNlTG9hZGVyKGxvYWRlciwgbXVsdGlGaWxlID8gW2ZpbGVzXSA6IGZpbGVzLCBsb2FkZXIgPT4ge1xuICAgIC8vIEdhaW5tYXAgcmVxdWlyZXMgYSByZW5kZXJlclxuICAgIGlmIChleHRlbnNpb24gPT09ICd3ZWJwJyB8fCBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBsb2FkZXIuc2V0UmVuZGVyZXIoZ2wpO1xuICAgIH1cbiAgICBsb2FkZXIuc2V0UGF0aCA9PSBudWxsIHx8IGxvYWRlci5zZXRQYXRoKHBhdGgpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICB9KTtcbiAgbGV0IHRleHR1cmUgPSBtdWx0aUZpbGUgP1xuICAvLyBAdHMtaWdub3JlXG4gIGxvYWRlclJlc3VsdFswXSA6IGxvYWRlclJlc3VsdDtcbiAgaWYgKGV4dGVuc2lvbiA9PT0gJ2pwZycgfHwgZXh0ZW5zaW9uID09PSAnanBlZycgfHwgZXh0ZW5zaW9uID09PSAnd2VicCcpIHtcbiAgICB2YXIgX3JlbmRlclRhcmdldDtcbiAgICB0ZXh0dXJlID0gKF9yZW5kZXJUYXJnZXQgPSB0ZXh0dXJlLnJlbmRlclRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgfVxuICB0ZXh0dXJlLm1hcHBpbmcgPSBpc0N1YmVtYXAgPyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgdGV4dHVyZS5jb2xvclNwYWNlID0gY29sb3JTcGFjZSAhPT0gbnVsbCAmJiBjb2xvclNwYWNlICE9PSB2b2lkIDAgPyBjb2xvclNwYWNlIDogaXNDdWJlbWFwID8gJ3NyZ2InIDogJ3NyZ2ItbGluZWFyJztcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5jb25zdCBwcmVsb2FkRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZpbGVzOiBkZWZhdWx0RmlsZXMsXG4gIHBhdGg6ICcnLFxuICBwcmVzZXQ6IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uczogdW5kZWZpbmVkXG59O1xudXNlRW52aXJvbm1lbnQucHJlbG9hZCA9IHByZWxvYWRPcHRpb25zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5wcmVsb2FkRGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ucHJlbG9hZE9wdGlvbnNcbiAgfTtcbiAgbGV0IHtcbiAgICBmaWxlcyxcbiAgICBwYXRoID0gJydcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHtcbiAgICBwcmVzZXQsXG4gICAgZXh0ZW5zaW9uc1xuICB9ID0gb3B0aW9ucztcbiAgaWYgKHByZXNldCkge1xuICAgIHZhbGlkYXRlUHJlc2V0KHByZXNldCk7XG4gICAgZmlsZXMgPSBwcmVzZXRzT2JqW3ByZXNldF07XG4gICAgcGF0aCA9IENVQkVNQVBfUk9PVDtcbiAgfVxuICBjb25zdCB7XG4gICAgZXh0ZW5zaW9uXG4gIH0gPSBnZXRFeHRlbnNpb24oZmlsZXMpO1xuICBpZiAoZXh0ZW5zaW9uID09PSAnd2VicCcgfHwgZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJykge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlRW52aXJvbm1lbnQ6IFByZWxvYWRpbmcgZ2Fpbm1hcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihleHRlbnNpb24pO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICB1c2VMb2FkZXIucHJlbG9hZChsb2FkZXIsIGlzQXJyYXkoZmlsZXMpID8gW2ZpbGVzXSA6IGZpbGVzLCBsb2FkZXIgPT4ge1xuICAgIGxvYWRlci5zZXRQYXRoID09IG51bGwgfHwgbG9hZGVyLnNldFBhdGgocGF0aCk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gIH0pO1xufTtcbmNvbnN0IGNsZWFyRGVmYXVsdE9wdGlucyA9IHtcbiAgZmlsZXM6IGRlZmF1bHRGaWxlcyxcbiAgcHJlc2V0OiB1bmRlZmluZWRcbn07XG51c2VFbnZpcm9ubWVudC5jbGVhciA9IGNsZWFyT3B0aW9ucyA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uY2xlYXJEZWZhdWx0T3B0aW5zLFxuICAgIC4uLmNsZWFyT3B0aW9uc1xuICB9O1xuICBsZXQge1xuICAgIGZpbGVzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB7XG4gICAgcHJlc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAocHJlc2V0KSB7XG4gICAgdmFsaWRhdGVQcmVzZXQocHJlc2V0KTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgfVxuICBjb25zdCB7XG4gICAgZXh0ZW5zaW9uXG4gIH0gPSBnZXRFeHRlbnNpb24oZmlsZXMpO1xuICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoZXh0ZW5zaW9uKTtcbiAgaWYgKCFsb2FkZXIpIHRocm93IG5ldyBFcnJvcigndXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogJyArIGZpbGVzKTtcbiAgdXNlTG9hZGVyLmNsZWFyKGxvYWRlciwgaXNBcnJheShmaWxlcykgPyBbZmlsZXNdIDogZmlsZXMpO1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJlc2V0KHByZXNldCkge1xuICBpZiAoIShwcmVzZXQgaW4gcHJlc2V0c09iaikpIHRocm93IG5ldyBFcnJvcignUHJlc2V0IG11c3QgYmUgb25lIG9mOiAnICsgT2JqZWN0LmtleXMocHJlc2V0c09iaikuam9pbignLCAnKSk7XG59XG5mdW5jdGlvbiBnZXRFeHRlbnNpb24oZmlsZXMpIHtcbiAgdmFyIF9maXJzdEVudHJ5JHNwbGl0JHBvcDtcbiAgY29uc3QgaXNDdWJlbWFwID0gaXNBcnJheShmaWxlcykgJiYgZmlsZXMubGVuZ3RoID09PSA2O1xuICBjb25zdCBpc0dhaW5tYXAgPSBpc0FycmF5KGZpbGVzKSAmJiBmaWxlcy5sZW5ndGggPT09IDMgJiYgZmlsZXMuc29tZShmaWxlID0+IGZpbGUuZW5kc1dpdGgoJ2pzb24nKSk7XG4gIGNvbnN0IGZpcnN0RW50cnkgPSBpc0FycmF5KGZpbGVzKSA/IGZpbGVzWzBdIDogZmlsZXM7XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlXG4gIGNvbnN0IGV4dGVuc2lvbiA9IGlzQ3ViZW1hcCA/ICdjdWJlJyA6IGlzR2Fpbm1hcCA/ICd3ZWJwJyA6IGZpcnN0RW50cnkuc3RhcnRzV2l0aCgnZGF0YTphcHBsaWNhdGlvbi9leHInKSA/ICdleHInIDogZmlyc3RFbnRyeS5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2hkcicpID8gJ2hkcicgOiBmaXJzdEVudHJ5LnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UvanBlZycpID8gJ2pwZycgOiAoX2ZpcnN0RW50cnkkc3BsaXQkcG9wID0gZmlyc3RFbnRyeS5zcGxpdCgnLicpLnBvcCgpKSA9PSBudWxsIHx8IChfZmlyc3RFbnRyeSRzcGxpdCRwb3AgPSBfZmlyc3RFbnRyeSRzcGxpdCRwb3Auc3BsaXQoJz8nKSkgPT0gbnVsbCB8fCAoX2ZpcnN0RW50cnkkc3BsaXQkcG9wID0gX2ZpcnN0RW50cnkkc3BsaXQkcG9wLnNoaWZ0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZmlyc3RFbnRyeSRzcGxpdCRwb3AudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb24sXG4gICAgaXNDdWJlbWFwLFxuICAgIGlzR2Fpbm1hcFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0TG9hZGVyKGV4dGVuc2lvbikge1xuICBjb25zdCBsb2FkZXIgPSBleHRlbnNpb24gPT09ICdjdWJlJyA/IEN1YmVUZXh0dXJlTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnaGRyJyA/IFJHQkVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdleHInID8gRVhSTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJyA/IEhEUkpQR0xvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ3dlYnAnID8gR2Fpbk1hcExvYWRlciA6IG51bGw7XG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmV4cG9ydCB7IHVzZUVudmlyb25tZW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0IiLCJzb3VyY2VzIjpbIkQ6XFxOZ29kc1xccmVwb2dpdGh1Ylxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGRyZWlcXGhlbHBlcnNcXGVudmlyb25tZW50LWFzc2V0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcmVzZXRzT2JqID0ge1xuICBhcGFydG1lbnQ6ICdsZWJvbWJvXzFrLmhkcicsXG4gIGNpdHk6ICdwb3RzZGFtZXJfcGxhdHpfMWsuaGRyJyxcbiAgZGF3bjogJ2tpYXJhXzFfZGF3bl8xay5oZHInLFxuICBmb3Jlc3Q6ICdmb3Jlc3Rfc2xvcGVfMWsuaGRyJyxcbiAgbG9iYnk6ICdzdF9mYWdhbnNfaW50ZXJpb3JfMWsuaGRyJyxcbiAgbmlnaHQ6ICdkaWtob2xvbG9fbmlnaHRfMWsuaGRyJyxcbiAgcGFyazogJ3Jvb2l0b3VfcGFya18xay5oZHInLFxuICBzdHVkaW86ICdzdHVkaW9fc21hbGxfMDNfMWsuaGRyJyxcbiAgc3Vuc2V0OiAndmVuaWNlX3N1bnNldF8xay5oZHInLFxuICB3YXJlaG91c2U6ICdlbXB0eV93YXJlaG91c2VfMDFfMWsuaGRyJ1xufTtcblxuZXhwb3J0IHsgcHJlc2V0c09iaiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useStore),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useThree),\n/* harmony export */   D: () => (/* binding */ useFrame),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useGraph),\n/* harmony export */   G: () => (/* binding */ useLoader),\n/* harmony export */   _: () => (/* binding */ _roots),\n/* harmony export */   a: () => (/* binding */ useMutableCallback),\n/* harmony export */   b: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   c: () => (/* binding */ createRoot),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createPointerEvents),\n/* harmony export */   g: () => (/* binding */ createEvents),\n/* harmony export */   h: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ addEffect),\n/* harmony export */   k: () => (/* binding */ addAfterEffect),\n/* harmony export */   l: () => (/* binding */ addTail),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ createPortal),\n/* harmony export */   p: () => (/* binding */ flushSync),\n/* harmony export */   q: () => (/* binding */ context),\n/* harmony export */   r: () => (/* binding */ reconciler),\n/* harmony export */   s: () => (/* binding */ applyProps),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useBridge),\n/* harmony export */   v: () => (/* binding */ getRootState),\n/* harmony export */   w: () => (/* binding */ dispose),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ useInstanceHandle)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\n/**\n * Returns the instance's initial (outmost) root.\n */\nfunction findInitialRoot(instance) {\n  let root = instance.root;\n  while (root.getState().previousRoot) root = root.getState().previousRoot;\n  return root;\n}\n/**\n * Safely flush async effects when testing, simulating a legacy root.\n * @deprecated Import from React instead. import { act } from 'react'\n */\n// Reference with computed key to break Webpack static analysis\n// https://github.com/webpack/webpack/issues/14814\nconst act = react__WEBPACK_IMPORTED_MODULE_0__['act' + ''];\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\nconst isColorRepresentation = value => value != null && (typeof value === 'string' || typeof value === 'number' || value.isColor);\n\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\nconst useIsomorphicLayoutEffect = /* @__PURE__ */((_window$document, _window$navigator) => typeof window !== 'undefined' && (((_window$document = window.document) == null ? void 0 : _window$document.createElement) || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative'))() ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\n/**\n * Bridges renderer Context and StrictMode from a primary renderer.\n */\nfunction useBridge() {\n  const fiber = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useFiber)();\n  const ContextBridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_5__.useContextBridge)();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    children\n  }) => {\n    const strict = !!(0,its_fine__WEBPACK_IMPORTED_MODULE_5__.traverseFiber)(fiber, true, node => node.type === react__WEBPACK_IMPORTED_MODULE_0__.StrictMode);\n    const Root = strict ? react__WEBPACK_IMPORTED_MODULE_0__.StrictMode : react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ContextBridge, {\n        children: children\n      })\n    });\n  }, [fiber, ContextBridge]);\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\n\n// NOTE: static members get down-level transpiled to mutations which break tree-shaking\nconst ErrorBoundary = /* @__PURE__ */(_ErrorBoundary => (_ErrorBoundary = class ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}, _ErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n}), _ErrorBoundary))();\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\n * Returns instance root state\n */\nfunction getRootState(obj) {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n}\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  nul: a => a === null,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {},\n    meshes: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n      if (obj.isMesh && !data.meshes[obj.name]) data.meshes[obj.name] = obj;\n    });\n  }\n  return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.type !== 'Scene') obj.dispose == null ? void 0 : obj.dispose();\n  for (const p in obj) {\n    const prop = obj[p];\n    if ((prop == null ? void 0 : prop.type) !== 'Scene') prop == null ? void 0 : prop.dispose == null ? void 0 : prop.dispose();\n  }\n}\nconst REACT_INTERNAL_PROPS = ['children', 'key', 'ref'];\n\n// Gets only instance props from reconciler fibers\nfunction getInstanceProps(queue) {\n  const props = {};\n  for (const key in queue) {\n    if (!REACT_INTERNAL_PROPS.includes(key)) props[key] = queue[key];\n  }\n  return props;\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(target, root, type, props) {\n  const object = target;\n\n  // Create instance descriptor\n  let instance = object == null ? void 0 : object.__r3f;\n  if (!instance) {\n    instance = {\n      root,\n      type,\n      parent: null,\n      children: [],\n      props: getInstanceProps(props),\n      object,\n      eventCount: 0,\n      handlers: {},\n      isHidden: false\n    };\n    if (object) object.__r3f = instance;\n  }\n  return instance;\n}\nfunction resolve(root, key) {\n  let target = root[key];\n  if (!key.includes('-')) return {\n    root,\n    key,\n    target\n  };\n\n  // Resolve pierced target\n  target = root;\n  for (const part of key.split('-')) {\n    var _target;\n    key = part;\n    root = target;\n    target = (_target = target) == null ? void 0 : _target[key];\n  }\n\n  // TODO: change key to 'foo-bar' if target is undefined?\n\n  return {\n    root,\n    key,\n    target\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child) {\n  if (is.str(child.props.attach)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(child.props.attach)) {\n      const index = child.props.attach.replace(INDEX_REGEX, '');\n      const {\n        root,\n        key\n      } = resolve(parent.object, index);\n      if (!Array.isArray(root[key])) root[key] = [];\n    }\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    child.previousAttach = root[key];\n    root[key] = child.object;\n  } else if (is.fun(child.props.attach)) {\n    child.previousAttach = child.props.attach(parent.object, child.object);\n  }\n}\nfunction detach(parent, child) {\n  if (is.str(child.props.attach)) {\n    const {\n      root,\n      key\n    } = resolve(parent.object, child.props.attach);\n    const previous = child.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete root[key];\n    // Otherwise set the previous value\n    else root[key] = previous;\n  } else {\n    child.previousAttach == null ? void 0 : child.previousAttach(parent.object, child.object);\n  }\n  delete child.previousAttach;\n}\nconst RESERVED_PROPS = [...REACT_INTERNAL_PROPS,\n// Instance props\n'args', 'dispose', 'attach', 'object', 'onUpdate',\n// Behavior flags\n'dispose'];\nconst MEMOIZED_PROTOTYPES = new Map();\nfunction getMemoizedPrototype(root) {\n  let ctor = MEMOIZED_PROTOTYPES.get(root.constructor);\n  try {\n    if (!ctor) {\n      ctor = new root.constructor();\n      MEMOIZED_PROTOTYPES.set(root.constructor, ctor);\n    }\n  } catch (e) {\n    // ...\n  }\n  return ctor;\n}\n\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, newProps) {\n  const changedProps = {};\n\n  // Sort through props\n  for (const prop in newProps) {\n    // Skip reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n    // Skip if props match\n    if (is.equ(newProps[prop], instance.props[prop])) continue;\n\n    // Props changed, add them\n    changedProps[prop] = newProps[prop];\n\n    // Reset pierced props\n    for (const other in newProps) {\n      if (other.startsWith(`${prop}-`)) changedProps[other] = newProps[other];\n    }\n  }\n\n  // Reset removed props for HMR\n  for (const prop in instance.props) {\n    if (RESERVED_PROPS.includes(prop) || newProps.hasOwnProperty(prop)) continue;\n    const {\n      root,\n      key\n    } = resolve(instance.object, prop);\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (root.constructor && root.constructor.length === 0) {\n      // create a blank slate of the instance and copy the particular parameter.\n      const ctor = getMemoizedPrototype(root);\n      if (!is.und(ctor)) changedProps[key] = ctor[key];\n    } else {\n      // instance does not have constructor, just set it to 0\n      changedProps[key] = 0;\n    }\n  }\n  return changedProps;\n}\n\n// https://github.com/mrdoob/three.js/pull/27042\n// https://github.com/mrdoob/three.js/pull/22748\nconst colorMaps = ['map', 'emissiveMap', 'sheenColorMap', 'specularColorMap', 'envMap'];\nconst EVENT_REGEX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;\n// This function applies a set of changes to the instance\nfunction applyProps(object, props) {\n  var _instance$object;\n  const instance = object.__r3f;\n  const rootState = instance && findInitialRoot(instance).getState();\n  const prevHandlers = instance == null ? void 0 : instance.eventCount;\n  for (const prop in props) {\n    let value = props[prop];\n\n    // Don't mutate reserved keys\n    if (RESERVED_PROPS.includes(prop)) continue;\n\n    // Deal with pointer events, including removing them if undefined\n    if (instance && EVENT_REGEX.test(prop)) {\n      if (typeof value === 'function') instance.handlers[prop] = value;else delete instance.handlers[prop];\n      instance.eventCount = Object.keys(instance.handlers).length;\n      continue;\n    }\n\n    // Ignore setting undefined props\n    // https://github.com/pmndrs/react-three-fiber/issues/274\n    if (value === undefined) continue;\n    let {\n      root,\n      key,\n      target\n    } = resolve(object, prop);\n\n    // Layers must be written to the mask property\n    if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_6__.Layers) {\n      target.mask = value.mask;\n    }\n    // Set colors if valid color representation for automatic conversion (copy)\n    else if (target instanceof three__WEBPACK_IMPORTED_MODULE_6__.Color && isColorRepresentation(value)) {\n      target.set(value);\n    }\n    // Copy if properties match signatures and implement math interface (likely read-only)\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof target.copy === 'function' && value != null && value.constructor && target.constructor === value.constructor) {\n      target.copy(value);\n    }\n    // Set array types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && Array.isArray(value)) {\n      if (typeof target.fromArray === 'function') target.fromArray(value);else target.set(...value);\n    }\n    // Set literal types\n    else if (target !== null && typeof target === 'object' && typeof target.set === 'function' && typeof value === 'number') {\n      // Allow setting array scalars\n      if (typeof target.setScalar === 'function') target.setScalar(value);\n      // Otherwise just set single value\n      else target.set(value);\n    }\n    // Else, just overwrite the value\n    else {\n      var _root$key;\n      root[key] = value;\n\n      // Auto-convert sRGB texture parameters for built-in materials\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      // https://github.com/mrdoob/three.js/pull/25857\n      if (rootState && !rootState.linear && colorMaps.includes(key) && (_root$key = root[key]) != null && _root$key.isTexture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      root[key].format === three__WEBPACK_IMPORTED_MODULE_6__.RGBAFormat && root[key].type === three__WEBPACK_IMPORTED_MODULE_6__.UnsignedByteType) {\n        // NOTE: this cannot be set from the renderer (e.g. sRGB source textures rendered to P3)\n        root[key].colorSpace = three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n      }\n    }\n  }\n\n  // Register event handlers\n  if (instance != null && instance.parent && rootState != null && rootState.internal && (_instance$object = instance.object) != null && _instance$object.isObject3D && prevHandlers !== instance.eventCount) {\n    const object = instance.object;\n    // Pre-emptively remove the instance from the interaction manager\n    const index = rootState.internal.interaction.indexOf(object);\n    if (index > -1) rootState.internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (instance.eventCount && object.raycast !== null) {\n      rootState.internal.interaction.push(object);\n    }\n  }\n\n  // Auto-attach geometries and materials\n  if (instance && instance.props.attach === undefined) {\n    if (instance.object.isBufferGeometry) instance.props.attach = 'geometry';else if (instance.object.isMaterial) instance.props.attach = 'material';\n  }\n\n  // Instance was updated, request a frame\n  if (instance) invalidateInstance(instance);\n  return object;\n}\nfunction invalidateInstance(instance) {\n  var _instance$root;\n  if (!instance.parent) return;\n  instance.props.onUpdate == null ? void 0 : instance.props.onUpdate(instance.object);\n  const state = (_instance$root = instance.root) == null ? void 0 : _instance$root.getState == null ? void 0 : _instance$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateCamera(camera, size) {\n  // Do not mess with the camera if it belongs to the user\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  if (camera.manual) return;\n  if (isOrthographicCamera(camera)) {\n    camera.left = size.width / -2;\n    camera.right = size.width / 2;\n    camera.top = size.height / 2;\n    camera.bottom = size.height / -2;\n  } else {\n    camera.aspect = size.width / size.height;\n  }\n  camera.updateProjectionMatrix();\n}\nconst isObject3D = object => object == null ? void 0 : object.isObject3D;\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        let state = getRootState(hit.object);\n\n        // If the object is not managed by R3F, it might be parented to an element which is.\n        // Traverse upwards until we find a managed parent and use its state instead.\n        if (!state) {\n          hit.object.traverseAncestors(obj => {\n            const parentState = getRootState(obj);\n            if (parentState) {\n              state = parentState;\n              return false;\n            }\n          });\n        }\n        if (state) {\n          const {\n            raycaster,\n            pointer,\n            camera,\n            internal\n          } = state;\n          const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n          const hasPointerCapture = id => {\n            var _internal$capturedMap, _internal$capturedMap2;\n            return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n          };\n          const setPointerCapture = id => {\n            const captureData = {\n              intersection: hit,\n              target: event.target\n            };\n            if (internal.capturedMap.has(id)) {\n              // if the pointerId was previously captured, we add the hit to the\n              // event capturedMap.\n              internal.capturedMap.get(id).set(hit.eventObject, captureData);\n            } else {\n              // if the pointerId was not previously captured, we create a map\n              // containing the hitObject, and the hit. hitObject is used for\n              // faster access.\n              internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n            }\n            event.target.setPointerCapture(id);\n          };\n          const releasePointerCapture = id => {\n            const captures = internal.capturedMap.get(id);\n            if (captures) {\n              releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n            }\n          };\n\n          // Add native event props\n          let extractEventProps = {};\n          // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n          for (let prop in event) {\n            let property = event[prop];\n            // Only copy over atomics, leave functions alone as these should be\n            // called as event.nativeEvent.fn()\n            if (typeof property !== 'function') extractEventProps[prop] = property;\n          }\n          let raycastEvent = {\n            ...hit,\n            ...extractEventProps,\n            pointer,\n            intersections,\n            stopped: localState.stopped,\n            delta,\n            unprojectedPoint,\n            ray: raycaster.ray,\n            camera: camera,\n            // Hijack stopPropagation, which just sets a flag\n            stopPropagation() {\n              // https://github.com/pmndrs/react-three-fiber/issues/596\n              // Events are not allowed to stop propagation if the pointer has been captured\n              const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n              // We only authorize stopPropagation...\n              if (\n              // ...if this pointer hasn't been captured\n              !capturesForPointer ||\n              // ... or if the hit object is capturing the pointer\n              capturesForPointer.has(hit.eventObject)) {\n                raycastEvent.stopped = localState.stopped = true;\n                // Propagation is stopped, remove all other hover records\n                // An event handler is only allowed to flush other handlers if it is hovered itself\n                if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                  // Objects cannot flush out higher up objects that have already caught the event\n                  const higher = intersections.slice(0, intersections.indexOf(hit));\n                  cancelPointer([...higher, hit]);\n                }\n              }\n            },\n            // there should be a distinction between target and currentTarget\n            target: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            currentTarget: {\n              hasPointerCapture,\n              setPointerCapture,\n              releasePointerCapture\n            },\n            nativeEvent: event\n          };\n\n          // Call subscribers\n          callback(raycastEvent);\n          // Event bubbling may be interrupted by stopPropagation\n          if (localState.stopped === true) break;\n        }\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          const handlers = instance.handlers;\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n        const handlers = instance.handlers;\n\n        /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootStore = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => {\n    const position = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    const tempTarget = new three__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target.isVector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new three__WEBPACK_IMPORTED_MODULE_6__.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      scene: null,\n      xr: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new three__WEBPACK_IMPORTED_MODULE_6__.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, top = 0, left = 0) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top,\n          left\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        // Events\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        lastEvent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n        // Updates\n        active: false,\n        frames: 0,\n        priority: 0,\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootStore.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootStore.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootStore.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      if (viewport.dpr > 0) gl.setPixelRatio(viewport.dpr);\n      const updateStyle = typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootStore.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootStore;\n};\n\n/**\n * Exposes an object's {@link Instance}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */\nfunction useInstanceHandle(ref) {\n  const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(instance, () => ref.current.__r3f, [ref]);\n  return instance;\n}\n\n/**\n * Returns the R3F Canvas' Zustand store. Useful for [transient updates](https://github.com/pmndrs/zustand#transient-updates-for-often-occurring-state-changes).\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usestore\n */\nfunction useStore() {\n  const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */\nfunction useGraph(object) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nconst isConstructor$1 = value => {\n  var _value$prototype;\n  return typeof value === 'function' && (value == null ? void 0 : (_value$prototype = value.prototype) == null ? void 0 : _value$prototype.constructor) === value;\n};\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    let loader;\n\n    // Construct and cache loader if constructor was passed\n    if (isConstructor$1(Proto)) {\n      loader = memoizedLoaders.get(Proto);\n      if (!loader) {\n        loader = new Proto();\n        memoizedLoaders.set(Proto, loader);\n      }\n    } else {\n      loader = Proto;\n    }\n\n    // Apply loader extensions\n    if (extensions) extensions(loader);\n\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (isObject3D(data == null ? void 0 : data.scene)) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n  };\n}\n\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */\nfunction useLoader(loader, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.suspend)(loadingFn(extensions, onProgress), [loader, ...keys], {\n    equal: is.equ\n  });\n  // Return the object(s)\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\n * Preloads an asset into cache as a side-effect.\n */\nuseLoader.preload = function (loader, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.preload)(loadingFn(extensions), [loader, ...keys]);\n};\n\n/**\n * Removes a loaded asset from cache.\n */\nuseLoader.clear = function (loader, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return (0,suspend_react__WEBPACK_IMPORTED_MODULE_8__.clear)([loader, ...keys]);\n};\n\n// TODO: upstream to DefinitelyTyped for React 19\n// https://github.com/facebook/react/issues/28956\n\nfunction createReconciler(config) {\n  const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()(config);\n  reconciler.injectIntoDevTools({\n    bundleType: typeof process !== 'undefined' && \"development\" !== 'production' ? 1 : 0,\n    rendererPackageName: '@react-three/fiber',\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n  });\n  return reconciler;\n}\nconst NoEventPriority = 0;\n\n// TODO: handle constructor overloads\n// https://github.com/pmndrs/react-three-fiber/pull/2931\n// https://github.com/microsoft/TypeScript/issues/37079\n\nconst catalogue = {};\nconst PREFIX_REGEX = /^three(?=[A-Z])/;\nconst toPascalCase = type => `${type[0].toUpperCase()}${type.slice(1)}`;\nlet i = 0;\nconst isConstructor = object => typeof object === 'function';\nfunction extend(objects) {\n  if (isConstructor(objects)) {\n    const Component = `${i++}`;\n    catalogue[Component] = objects;\n    return Component;\n  } else {\n    Object.assign(catalogue, objects);\n  }\n}\nfunction validateInstance(type, props) {\n  // Get target from catalogue\n  const name = toPascalCase(type);\n  const target = catalogue[name];\n\n  // Validate element target\n  if (type !== 'primitive' && !target) throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n\n  // Validate primitives\n  if (type === 'primitive' && !props.object) throw new Error(`R3F: Primitives without 'object' are invalid!`);\n\n  // Throw if an object or literal was passed for args\n  if (props.args !== undefined && !Array.isArray(props.args)) throw new Error('R3F: The args prop must be an array!');\n}\nfunction createInstance(type, props, root) {\n  var _props$object;\n  // Remove three* prefix from elements if native element not present\n  type = toPascalCase(type) in catalogue ? type : type.replace(PREFIX_REGEX, '');\n  validateInstance(type, props);\n\n  // Regenerate the R3F instance for primitives to simulate a new object\n  if (type === 'primitive' && (_props$object = props.object) != null && _props$object.__r3f) delete props.object.__r3f;\n  return prepare(props.object, root, type, props);\n}\nfunction hideInstance(instance) {\n  if (!instance.isHidden) {\n    var _instance$parent;\n    if (instance.props.attach && (_instance$parent = instance.parent) != null && _instance$parent.object) {\n      detach(instance.parent, instance);\n    } else if (isObject3D(instance.object)) {\n      instance.object.visible = false;\n    }\n    instance.isHidden = true;\n    invalidateInstance(instance);\n  }\n}\nfunction unhideInstance(instance) {\n  if (instance.isHidden) {\n    var _instance$parent2;\n    if (instance.props.attach && (_instance$parent2 = instance.parent) != null && _instance$parent2.object) {\n      attach(instance.parent, instance);\n    } else if (isObject3D(instance.object) && instance.props.visible !== false) {\n      instance.object.visible = true;\n    }\n    instance.isHidden = false;\n    invalidateInstance(instance);\n  }\n}\n\n// https://github.com/facebook/react/issues/20271\n// This will make sure events and attach are only handled once when trees are complete\nfunction handleContainerEffects(parent, child, beforeChild) {\n  // Bail if tree isn't mounted or parent is not a container.\n  // This ensures that the tree is finalized and React won't discard results to Suspense\n  const state = child.root.getState();\n  if (!parent.parent && parent.object !== state.scene) return;\n\n  // Create & link object on first run\n  if (!child.object) {\n    var _child$props$object, _child$props$args;\n    // Get target from catalogue\n    const target = catalogue[toPascalCase(child.type)];\n\n    // Create object\n    child.object = (_child$props$object = child.props.object) != null ? _child$props$object : new target(...((_child$props$args = child.props.args) != null ? _child$props$args : []));\n    child.object.__r3f = child;\n  }\n\n  // Set initial props\n  applyProps(child.object, child.props);\n\n  // Append instance\n  if (child.props.attach) {\n    attach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    const childIndex = parent.object.children.indexOf(beforeChild == null ? void 0 : beforeChild.object);\n    if (beforeChild && childIndex !== -1) {\n      // If the child is already in the parent's children array, move it to the new position\n      // Otherwise, just insert it at the target position\n      const existingIndex = parent.object.children.indexOf(child.object);\n      if (existingIndex !== -1) {\n        parent.object.children.splice(existingIndex, 1);\n        const adjustedIndex = existingIndex < childIndex ? childIndex - 1 : childIndex;\n        parent.object.children.splice(adjustedIndex, 0, child.object);\n      } else {\n        child.object.parent = parent.object;\n        parent.object.children.splice(childIndex, 0, child.object);\n        child.object.dispatchEvent({\n          type: 'added'\n        });\n        parent.object.dispatchEvent({\n          type: 'childadded',\n          child: child.object\n        });\n      }\n    } else {\n      parent.object.add(child.object);\n    }\n  }\n\n  // Link subtree\n  for (const childInstance of child.children) handleContainerEffects(child, childInstance);\n\n  // Tree was updated, request a frame\n  invalidateInstance(child);\n}\nfunction appendChild(parent, child) {\n  if (!child) return;\n\n  // Link instances\n  child.parent = parent;\n  parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child);\n}\nfunction insertBefore(parent, child, beforeChild) {\n  if (!child || !beforeChild) return;\n\n  // Link instances\n  child.parent = parent;\n  const childIndex = parent.children.indexOf(beforeChild);\n  if (childIndex !== -1) parent.children.splice(childIndex, 0, child);else parent.children.push(child);\n\n  // Attach tree once complete\n  handleContainerEffects(parent, child, beforeChild);\n}\nfunction disposeOnIdle(object) {\n  if (typeof object.dispose === 'function') {\n    const handleDispose = () => {\n      try {\n        object.dispose();\n      } catch {\n        // no-op\n      }\n    };\n\n    // In a testing environment, cleanup immediately\n    if (typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined') handleDispose();\n    // Otherwise, using a real GPU so schedule cleanup to prevent stalls\n    else (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, handleDispose);\n  }\n}\nfunction removeChild(parent, child, dispose) {\n  if (!child) return;\n\n  // Unlink instances\n  child.parent = null;\n  const childIndex = parent.children.indexOf(child);\n  if (childIndex !== -1) parent.children.splice(childIndex, 1);\n\n  // Eagerly tear down tree\n  if (child.props.attach) {\n    detach(parent, child);\n  } else if (isObject3D(child.object) && isObject3D(parent.object)) {\n    parent.object.remove(child.object);\n    removeInteractivity(findInitialRoot(child), child.object);\n  }\n\n  // Allow objects to bail out of unmount disposal with dispose={null}\n  const shouldDispose = child.props.dispose !== null && dispose !== false;\n\n  // Recursively remove instance children\n  for (let i = child.children.length - 1; i >= 0; i--) {\n    const node = child.children[i];\n    removeChild(child, node, shouldDispose);\n  }\n  child.children.length = 0;\n\n  // Unlink instance object\n  delete child.object.__r3f;\n\n  // Dispose object whenever the reconciler feels like it.\n  // Never dispose of primitives because their state may be kept outside of React!\n  // In order for an object to be able to dispose it\n  //   - has a dispose method\n  //   - cannot be a <primitive object={...} />\n  //   - cannot be a THREE.Scene, because three has broken its own API\n  if (shouldDispose && child.type !== 'primitive' && child.object.type !== 'Scene') {\n    disposeOnIdle(child.object);\n  }\n\n  // Tree was updated, request a frame for top-level instance\n  if (dispose === undefined) invalidateInstance(child);\n}\nfunction setFiberRef(fiber, publicInstance) {\n  for (const _fiber of [fiber, fiber.alternate]) {\n    if (_fiber !== null) {\n      if (typeof _fiber.ref === 'function') {\n        _fiber.refCleanup == null ? void 0 : _fiber.refCleanup();\n        const cleanup = _fiber.ref(publicInstance);\n        if (typeof cleanup === 'function') _fiber.refCleanup = cleanup;\n      } else if (_fiber.ref) {\n        _fiber.ref.current = publicInstance;\n      }\n    }\n  }\n}\nconst reconstructed = [];\nfunction swapInstances() {\n  // Detach instance\n  for (const [instance] of reconstructed) {\n    const parent = instance.parent;\n    if (parent) {\n      if (instance.props.attach) {\n        detach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.remove(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          detach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.remove(child.object);\n        }\n      }\n    }\n\n    // If the old instance is hidden, we need to unhide it.\n    // React assumes it can discard instances since they're pure for DOM.\n    // This isn't true for us since our lifetimes are impure and longliving.\n    // So, we manually check if an instance was hidden and unhide it.\n    if (instance.isHidden) unhideInstance(instance);\n\n    // Dispose of old object if able\n    if (instance.object.__r3f) delete instance.object.__r3f;\n    if (instance.type !== 'primitive') disposeOnIdle(instance.object);\n  }\n\n  // Update instance\n  for (const [instance, props, fiber] of reconstructed) {\n    instance.props = props;\n    const parent = instance.parent;\n    if (parent) {\n      var _instance$props$objec, _instance$props$args;\n      // Get target from catalogue\n      const target = catalogue[toPascalCase(instance.type)];\n\n      // Create object\n      instance.object = (_instance$props$objec = instance.props.object) != null ? _instance$props$objec : new target(...((_instance$props$args = instance.props.args) != null ? _instance$props$args : []));\n      instance.object.__r3f = instance;\n      setFiberRef(fiber, instance.object);\n\n      // Set initial props\n      applyProps(instance.object, instance.props);\n      if (instance.props.attach) {\n        attach(parent, instance);\n      } else if (isObject3D(instance.object) && isObject3D(parent.object)) {\n        parent.object.add(instance.object);\n      }\n      for (const child of instance.children) {\n        if (child.props.attach) {\n          attach(instance, child);\n        } else if (isObject3D(child.object) && isObject3D(instance.object)) {\n          instance.object.add(child.object);\n        }\n      }\n\n      // Tree was updated, request a frame\n      invalidateInstance(instance);\n    }\n  }\n  reconstructed.length = 0;\n}\n\n// Don't handle text instances, make it no-op\nconst handleTextInstance = () => {};\nconst NO_CONTEXT = {};\nlet currentUpdatePriority = NoEventPriority;\n\n// https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberFlags.js\nconst NoFlags = 0;\nconst Update = 4;\nconst reconciler = /* @__PURE__ */createReconciler({\n  isPrimaryRenderer: false,\n  warnsIfNotActing: false,\n  supportsMutation: true,\n  supportsPersistence: false,\n  supportsHydration: false,\n  createInstance,\n  removeChild,\n  appendChild,\n  appendInitialChild: appendChild,\n  insertBefore,\n  appendChildToContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    appendChild(scene, child);\n  },\n  removeChildFromContainer(container, child) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !scene) return;\n    removeChild(scene, child);\n  },\n  insertInContainerBefore(container, child, beforeChild) {\n    const scene = container.getState().scene.__r3f;\n    if (!child || !beforeChild || !scene) return;\n    insertBefore(scene, child, beforeChild);\n  },\n  getRootHostContext: () => NO_CONTEXT,\n  getChildHostContext: () => NO_CONTEXT,\n  commitUpdate(instance, type, oldProps, newProps, fiber) {\n    var _newProps$args, _oldProps$args, _newProps$args2;\n    validateInstance(type, newProps);\n    let reconstruct = false;\n\n    // Reconstruct primitives if object prop changes\n    if (instance.type === 'primitive' && oldProps.object !== newProps.object) reconstruct = true;\n    // Reconstruct instance if args were added or removed\n    else if (((_newProps$args = newProps.args) == null ? void 0 : _newProps$args.length) !== ((_oldProps$args = oldProps.args) == null ? void 0 : _oldProps$args.length)) reconstruct = true;\n    // Reconstruct instance if args were changed\n    else if ((_newProps$args2 = newProps.args) != null && _newProps$args2.some((value, index) => {\n      var _oldProps$args2;\n      return value !== ((_oldProps$args2 = oldProps.args) == null ? void 0 : _oldProps$args2[index]);\n    })) reconstruct = true;\n\n    // Reconstruct when args or <primitive object={...} have changes\n    if (reconstruct) {\n      reconstructed.push([instance, {\n        ...newProps\n      }, fiber]);\n    } else {\n      // Create a diff-set, flag if there are any changes\n      const changedProps = diffProps(instance, newProps);\n      if (Object.keys(changedProps).length) {\n        Object.assign(instance.props, changedProps);\n        applyProps(instance.object, changedProps);\n      }\n    }\n\n    // Flush reconstructed siblings when we hit the last updated child in a sequence\n    const isTailSibling = fiber.sibling === null || (fiber.flags & Update) === NoFlags;\n    if (isTailSibling) swapInstances();\n  },\n  finalizeInitialChildren: () => false,\n  commitMount() {},\n  getPublicInstance: instance => instance == null ? void 0 : instance.object,\n  prepareForCommit: () => null,\n  preparePortalMount: container => prepare(container.getState().scene, container, '', {}),\n  resetAfterCommit: () => {},\n  shouldSetTextContent: () => false,\n  clearContainer: () => false,\n  hideInstance,\n  unhideInstance,\n  createTextInstance: handleTextInstance,\n  hideTextInstance: handleTextInstance,\n  unhideTextInstance: handleTextInstance,\n  scheduleTimeout: typeof setTimeout === 'function' ? setTimeout : undefined,\n  cancelTimeout: typeof clearTimeout === 'function' ? clearTimeout : undefined,\n  noTimeout: -1,\n  getInstanceFromNode: () => null,\n  beforeActiveInstanceBlur() {},\n  afterActiveInstanceBlur() {},\n  detachDeletedInstance() {},\n  prepareScopeUpdate() {},\n  getInstanceFromScope: () => null,\n  shouldAttemptEagerTransition: () => false,\n  trackSchedulerEvent: () => {},\n  resolveEventType: () => null,\n  resolveEventTimeStamp: () => -1.1,\n  requestPostPaintCallback() {},\n  maySuspendCommit: () => false,\n  preloadInstance: () => true,\n  // true indicates already loaded\n  startSuspendingCommit() {},\n  suspendInstance() {},\n  waitForCommitToBeReady: () => null,\n  NotPendingTransition: null,\n  HostTransitionContext: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),\n  setCurrentUpdatePriority(newPriority) {\n    currentUpdatePriority = newPriority;\n  },\n  getCurrentUpdatePriority() {\n    return currentUpdatePriority;\n  },\n  resolveUpdatePriority() {\n    var _window$event;\n    if (currentUpdatePriority !== NoEventPriority) return currentUpdatePriority;\n    switch (typeof window !== 'undefined' && ((_window$event = window.event) == null ? void 0 : _window$event.type)) {\n      case 'click':\n      case 'contextmenu':\n      case 'dblclick':\n      case 'pointercancel':\n      case 'pointerdown':\n      case 'pointerup':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n      case 'pointermove':\n      case 'pointerout':\n      case 'pointerover':\n      case 'pointerenter':\n      case 'pointerleave':\n      case 'wheel':\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n      default:\n        return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n  },\n  resetFormInstance() {}\n});\n\nconst _roots = new Map();\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nfunction computeInitialSize(canvas, size) {\n  if (!size && typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left\n    };\n  } else if (!size && typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    ...size\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = _roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store,\n  // container\n  react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot,\n  // tag\n  null,\n  // hydration callbacks\n  false,\n  // isStrictMode\n  null,\n  // concurrentUpdatesByDefaultOverride\n  '',\n  // identifierPrefix\n  logRecoverableError,\n  // onUncaughtError\n  logRecoverableError,\n  // onCaughtError\n  logRecoverableError,\n  // onRecoverableError\n  null // transitionCallbacks\n  );\n  // Map it\n  if (!prevRoot) _roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let lastCamera;\n  let configured = false;\n  let pending = null;\n  return {\n    async configure(props = {}) {\n      let resolve;\n      pending = new Promise(_resolve => resolve = _resolve);\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) {\n        const defaultProps = {\n          canvas: canvas,\n          powerPreference: 'high-performance',\n          antialias: true,\n          alpha: true\n        };\n        const customRenderer = typeof glConfig === 'function' ? await glConfig(defaultProps) : glConfig;\n        if (isRenderer(customRenderer)) {\n          gl = customRenderer;\n        } else {\n          gl = new three__WEBPACK_IMPORTED_MODULE_6__.WebGLRenderer({\n            ...defaultProps,\n            ...glConfig\n          });\n        }\n        state.set({\n          gl\n        });\n      }\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions == null ? void 0 : cameraOptions.isCamera;\n        const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_6__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_6__.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) {\n            applyProps(camera, cameraOptions);\n            // Preserve user-defined frustum if possible\n            // https://github.com/pmndrs/react-three-fiber/issues/3160\n            if (!camera.manual) {\n              if ('aspect' in cameraOptions || 'left' in cameraOptions || 'right' in cameraOptions || 'bottom' in cameraOptions || 'top' in cameraOptions) {\n                camera.manual = true;\n                camera.updateProjectionMatrix();\n              }\n            }\n          }\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions != null && sceneOptions.isScene) {\n          scene = sceneOptions;\n          prepare(scene, store, '', {});\n        } else {\n          scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();\n          prepare(scene, store, '', {});\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene\n        });\n      }\n\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: three__WEBPACK_IMPORTED_MODULE_6__.BasicShadowMap,\n            percentage: three__WEBPACK_IMPORTED_MODULE_6__.PCFShadowMap,\n            soft: three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap,\n            variance: three__WEBPACK_IMPORTED_MODULE_6__.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_6__.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n      three__WEBPACK_IMPORTED_MODULE_6__.ColorManagement.enabled = !legacy;\n\n      // Set color space and tonemapping preferences\n      if (!configured) {\n        gl.outputColorSpace = linear ? three__WEBPACK_IMPORTED_MODULE_6__.LinearSRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_6__.SRGBColorSpace;\n        gl.toneMapping = flat ? three__WEBPACK_IMPORTED_MODULE_6__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_6__.ACESFilmicToneMapping;\n      }\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      resolve();\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured && !pending) this.configure();\n      pending.then(() => {\n        reconciler.updateContainer( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Provider, {\n          store: store,\n          children: children,\n          onCreated: onCreated,\n          rootElement: canvas\n        }), fiber, null, () => undefined);\n      });\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notify that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n    value: store,\n    children: children\n  });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = _roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state.scene);\n            _roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Portal, {\n    children: children,\n    container: container,\n    state: state\n  });\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Raycaster());\n  const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new three__WEBPACK_IMPORTED_MODULE_6__.Vector2());\n  const inject = useMutableCallback((rootState, injectState) => {\n    let viewport = undefined;\n    if (injectState.camera && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_6__.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...rootState,\n      ...injectState,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...injectState.events,\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      // Layers are allowed to override events\n      setEvents: events => injectState.set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    };\n  });\n  const usePortalStore = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const store = (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_7__.createWithEqualityFn)((set, get) => ({\n      ...rest,\n      set,\n      get\n    }));\n\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const onMutate = prev => store.setState(state => inject.current(prev, state));\n    onMutate(previousRoot.getState());\n    previousRoot.subscribe(onMutate);\n    return store;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [previousRoot, container]);\n  return (\n    /*#__PURE__*/\n    // @ts-ignore, reconciler types are not maintained\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n      children: reconciler.createPortal( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(context.Provider, {\n        value: usePortalStore,\n        children: children\n      }), usePortalStore, null)\n    })\n  );\n}\n\n/**\n * Force React to flush any updates inside the provided callback synchronously and immediately.\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\n * having to revert to a non-React solution.\n */\nfunction flushSync(fn) {\n  return reconciler.flushSync(fn);\n}\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nconst globalEffects = new Set();\nconst globalAfterEffects = new Set();\nconst globalTailEffects = new Set();\n\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction update(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (let i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nlet running = false;\nlet useFrameInProgress = false;\nlet repeat;\nlet frame;\nlet state;\nfunction loop(timestamp) {\n  frame = requestAnimationFrame(loop);\n  running = true;\n  repeat = 0;\n\n  // Run effects\n  flushGlobalEffects('before', timestamp);\n\n  // Render all roots\n  useFrameInProgress = true;\n  for (const root of _roots.values()) {\n    var _state$gl$xr;\n    state = root.store.getState();\n\n    // If the frameloop is invalidated, do not run another frame\n    if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n      repeat += update(timestamp, state);\n    }\n  }\n  useFrameInProgress = false;\n\n  // Run after-effects\n  flushGlobalEffects('after', timestamp);\n\n  // Stop the loop if nothing invalidates it\n  if (repeat === 0) {\n    // Tail call effects, they are called when rendering stops\n    flushGlobalEffects('tail', timestamp);\n\n    // Flag end of operation\n    running = false;\n    return cancelAnimationFrame(frame);\n  }\n}\n\n/**\n * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n */\nfunction invalidate(state, frames = 1) {\n  var _state$gl$xr2;\n  if (!state) return _roots.forEach(root => invalidate(root.store.getState(), frames));\n  if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n  if (frames > 1) {\n    // legacy support for people using frames parameters\n    // Increase frames, do not go higher than 60\n    state.internal.frames = Math.min(60, state.internal.frames + frames);\n  } else {\n    if (useFrameInProgress) {\n      //called from within a useFrame, it means the user wants an additional frame\n      state.internal.frames = 2;\n    } else {\n      //the user need a new frame, no need to increment further than 1\n      state.internal.frames = 1;\n    }\n  }\n\n  // If the render-loop isn't active, start it\n  if (!running) {\n    running = true;\n    requestAnimationFrame(loop);\n  }\n}\n\n/**\n * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n */\nfunction advance(timestamp, runGlobalEffects = true, state, frame) {\n  if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n  if (!state) for (const root of _roots.values()) update(timestamp, root.store.getState());else update(timestamp, state, frame);\n  if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n}\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      if (events.handlers) {\n        for (const name in events.handlers) {\n          const event = events.handlers[name];\n          const [eventName, passive] = DOM_EVENTS[name];\n          target.addEventListener(eventName, event, {\n            passive\n          });\n        }\n      }\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        if (events.handlers) {\n          for (const name in events.handlers) {\n            const event = events.handlers[name];\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        }\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLWNmNTdiMjIwLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDdkU7QUFDakI7QUFDbUM7QUFDckI7QUFDTjtBQUNtQjs7QUFFckU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFLO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1VUFBdVUsa0RBQXFCLEdBQUcsNENBQWU7QUFDOVc7QUFDQSxjQUFjLHlDQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFRO0FBQ3hCLHdCQUF3QiwwREFBZ0I7QUFDeEMsU0FBUywwQ0FBYTtBQUN0QjtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsdURBQWEsb0NBQW9DLDZDQUFnQjtBQUN0RiwwQkFBMEIsNkNBQWdCLEdBQUcsMkNBQWM7QUFDM0Qsd0JBQXdCLHNEQUFHO0FBQzNCLDZCQUE2QixzREFBRztBQUNoQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHNHQUFzRyw0Q0FBZTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSwwQkFBMEIseUNBQVkscUJBQXFCLHlDQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFnQix1QkFBdUIsbURBQXNCO0FBQ3hGO0FBQ0EsK0JBQStCLGlEQUFvQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFX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RTtBQUNqRTs7QUFFQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRW1tQiIsInNvdXJjZXMiOlsiRDpcXE5nb2RzXFxyZXBvZ2l0aHViXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXGRpc3RcXGV2ZW50cy1jZjU3YjIyMC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlRmliZXIsIHVzZUNvbnRleHRCcmlkZ2UsIHRyYXZlcnNlRmliZXIgfSBmcm9tICdpdHMtZmluZSc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlJ3MgaW5pdGlhbCAob3V0bW9zdCkgcm9vdC5cbiAqL1xuZnVuY3Rpb24gZmluZEluaXRpYWxSb290KGluc3RhbmNlKSB7XG4gIGxldCByb290ID0gaW5zdGFuY2Uucm9vdDtcbiAgd2hpbGUgKHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3QpIHJvb3QgPSByb290LmdldFN0YXRlKCkucHJldmlvdXNSb290O1xuICByZXR1cm4gcm9vdDtcbn1cbi8qKlxuICogU2FmZWx5IGZsdXNoIGFzeW5jIGVmZmVjdHMgd2hlbiB0ZXN0aW5nLCBzaW11bGF0aW5nIGEgbGVnYWN5IHJvb3QuXG4gKiBAZGVwcmVjYXRlZCBJbXBvcnQgZnJvbSBSZWFjdCBpbnN0ZWFkLiBpbXBvcnQgeyBhY3QgfSBmcm9tICdyZWFjdCdcbiAqL1xuLy8gUmVmZXJlbmNlIHdpdGggY29tcHV0ZWQga2V5IHRvIGJyZWFrIFdlYnBhY2sgc3RhdGljIGFuYWx5c2lzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy8xNDgxNFxuY29uc3QgYWN0ID0gUmVhY3RbJ2FjdCcgKyAnJ107XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuY29uc3QgaXNDb2xvclJlcHJlc2VudGF0aW9uID0gdmFsdWUgPT4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlLmlzQ29sb3IpO1xuXG4vKipcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXG4gKlxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4gKiB1c2VMYXlvdXRFZmZlY3QgZWxzZXdoZXJlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xuICovXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gLyogQF9fUFVSRV9fICovKChfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcikgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKCgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykpKCkgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VNdXRhYmxlQ2FsbGJhY2soZm4pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG4vKipcbiAqIEJyaWRnZXMgcmVuZGVyZXIgQ29udGV4dCBhbmQgU3RyaWN0TW9kZSBmcm9tIGEgcHJpbWFyeSByZW5kZXJlci5cbiAqL1xuZnVuY3Rpb24gdXNlQnJpZGdlKCkge1xuICBjb25zdCBmaWJlciA9IHVzZUZpYmVyKCk7XG4gIGNvbnN0IENvbnRleHRCcmlkZ2UgPSB1c2VDb250ZXh0QnJpZGdlKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHN0cmljdCA9ICEhdHJhdmVyc2VGaWJlcihmaWJlciwgdHJ1ZSwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFJlYWN0LlN0cmljdE1vZGUpO1xuICAgIGNvbnN0IFJvb3QgPSBzdHJpY3QgPyBSZWFjdC5TdHJpY3RNb2RlIDogUmVhY3QuRnJhZ21lbnQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goUm9vdCwge1xuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ29udGV4dEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pXG4gICAgfSk7XG4gIH0sIFtmaWJlciwgQ29udGV4dEJyaWRnZV0pO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogc3RhdGljIG1lbWJlcnMgZ2V0IGRvd24tbGV2ZWwgdHJhbnNwaWxlZCB0byBtdXRhdGlvbnMgd2hpY2ggYnJlYWsgdHJlZS1zaGFraW5nXG5jb25zdCBFcnJvckJvdW5kYXJ5ID0gLyogQF9fUFVSRV9fICovKF9FcnJvckJvdW5kYXJ5ID0+IChfRXJyb3JCb3VuZGFyeSA9IGNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSwgX0Vycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pLCBfRXJyb3JCb3VuZGFyeSkpKCk7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5zdGFuY2Ugcm9vdCBzdGF0ZVxuICovXG5mdW5jdGlvbiBnZXRSb290U3RhdGUob2JqKSB7XG4gIHZhciBfcjNmO1xuICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbn1cbi8vIEEgY29sbGVjdGlvbiBvZiBjb21wYXJlIGZ1bmN0aW9uc1xuY29uc3QgaXMgPSB7XG4gIG9iajogYSA9PiBhID09PSBPYmplY3QoYSkgJiYgIWlzLmFycihhKSAmJiB0eXBlb2YgYSAhPT0gJ2Z1bmN0aW9uJyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICBib286IGEgPT4gdHlwZW9mIGEgPT09ICdib29sZWFuJyxcbiAgdW5kOiBhID0+IGEgPT09IHZvaWQgMCxcbiAgbnVsOiBhID0+IGEgPT09IG51bGwsXG4gIGFycjogYSA9PiBBcnJheS5pc0FycmF5KGEpLFxuICBlcXUoYSwgYiwge1xuICAgIGFycmF5cyA9ICdzaGFsbG93JyxcbiAgICBvYmplY3RzID0gJ3JlZmVyZW5jZScsXG4gICAgc3RyaWN0ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvLyBXcm9uZyB0eXBlIG9yIG9uZSBvZiB0aGUgdHdvIHVuZGVmaW5lZCwgZG9lc24ndCBtYXRjaFxuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIgfHwgISFhICE9PSAhIWIpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuICAgIGlmIChpcy5zdHIoYSkgfHwgaXMubnVtKGEpIHx8IGlzLmJvbyhhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29sbGVjdHMgbm9kZXMgYW5kIG1hdGVyaWFscyBmcm9tIGEgVEhSRUUuT2JqZWN0M0RcbmZ1bmN0aW9uIGJ1aWxkR3JhcGgob2JqZWN0KSB7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbm9kZXM6IHt9LFxuICAgIG1hdGVyaWFsczoge30sXG4gICAgbWVzaGVzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgICBpZiAob2JqLmlzTWVzaCAmJiAhZGF0YS5tZXNoZXNbb2JqLm5hbWVdKSBkYXRhLm1lc2hlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG4vLyBEaXNwb3NlcyBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcGVydGllc1xuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai50eXBlICE9PSAnU2NlbmUnKSBvYmouZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogb2JqLmRpc3Bvc2UoKTtcbiAgZm9yIChjb25zdCBwIGluIG9iaikge1xuICAgIGNvbnN0IHByb3AgPSBvYmpbcF07XG4gICAgaWYgKChwcm9wID09IG51bGwgPyB2b2lkIDAgOiBwcm9wLnR5cGUpICE9PSAnU2NlbmUnKSBwcm9wID09IG51bGwgPyB2b2lkIDAgOiBwcm9wLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3AuZGlzcG9zZSgpO1xuICB9XG59XG5jb25zdCBSRUFDVF9JTlRFUk5BTF9QUk9QUyA9IFsnY2hpbGRyZW4nLCAna2V5JywgJ3JlZiddO1xuXG4vLyBHZXRzIG9ubHkgaW5zdGFuY2UgcHJvcHMgZnJvbSByZWNvbmNpbGVyIGZpYmVyc1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VQcm9wcyhxdWV1ZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBxdWV1ZSkge1xuICAgIGlmICghUkVBQ1RfSU5URVJOQUxfUFJPUFMuaW5jbHVkZXMoa2V5KSkgcHJvcHNba2V5XSA9IHF1ZXVlW2tleV07XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgc2NlbmUgY2FycmllcyBhIHNtYWxsIExvY2FsU3RhdGUgZGVzY3JpcHRvclxuZnVuY3Rpb24gcHJlcGFyZSh0YXJnZXQsIHJvb3QsIHR5cGUsIHByb3BzKSB7XG4gIGNvbnN0IG9iamVjdCA9IHRhcmdldDtcblxuICAvLyBDcmVhdGUgaW5zdGFuY2UgZGVzY3JpcHRvclxuICBsZXQgaW5zdGFuY2UgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdC5fX3IzZjtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgcm9vdCxcbiAgICAgIHR5cGUsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBwcm9wczogZ2V0SW5zdGFuY2VQcm9wcyhwcm9wcyksXG4gICAgICBvYmplY3QsXG4gICAgICBldmVudENvdW50OiAwLFxuICAgICAgaGFuZGxlcnM6IHt9LFxuICAgICAgaXNIaWRkZW46IGZhbHNlXG4gICAgfTtcbiAgICBpZiAob2JqZWN0KSBvYmplY3QuX19yM2YgPSBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiByZXNvbHZlKHJvb3QsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gcm9vdFtrZXldO1xuICBpZiAoIWtleS5pbmNsdWRlcygnLScpKSByZXR1cm4ge1xuICAgIHJvb3QsXG4gICAga2V5LFxuICAgIHRhcmdldFxuICB9O1xuXG4gIC8vIFJlc29sdmUgcGllcmNlZCB0YXJnZXRcbiAgdGFyZ2V0ID0gcm9vdDtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGtleS5zcGxpdCgnLScpKSB7XG4gICAgdmFyIF90YXJnZXQ7XG4gICAga2V5ID0gcGFydDtcbiAgICByb290ID0gdGFyZ2V0O1xuICAgIHRhcmdldCA9IChfdGFyZ2V0ID0gdGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldFtrZXldO1xuICB9XG5cbiAgLy8gVE9ETzogY2hhbmdlIGtleSB0byAnZm9vLWJhcicgaWYgdGFyZ2V0IGlzIHVuZGVmaW5lZD9cblxuICByZXR1cm4ge1xuICAgIHJvb3QsXG4gICAga2V5LFxuICAgIHRhcmdldFxuICB9O1xufVxuXG4vLyBDaGVja3MgaWYgYSBkYXNoLWNhc2VkIHN0cmluZyBlbmRzIHdpdGggYW4gaW50ZWdlclxuY29uc3QgSU5ERVhfUkVHRVggPSAvLVxcZCskLztcbmZ1bmN0aW9uIGF0dGFjaChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChpcy5zdHIoY2hpbGQucHJvcHMuYXR0YWNoKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdChjaGlsZC5wcm9wcy5hdHRhY2gpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGNoaWxkLnByb3BzLmF0dGFjaC5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvb3QsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgaW5kZXgpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJvb3Rba2V5XSkpIHJvb3Rba2V5XSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgY2hpbGQucHJvcHMuYXR0YWNoKTtcbiAgICBjaGlsZC5wcmV2aW91c0F0dGFjaCA9IHJvb3Rba2V5XTtcbiAgICByb290W2tleV0gPSBjaGlsZC5vYmplY3Q7XG4gIH0gZWxzZSBpZiAoaXMuZnVuKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICBjaGlsZC5wcmV2aW91c0F0dGFjaCA9IGNoaWxkLnByb3BzLmF0dGFjaChwYXJlbnQub2JqZWN0LCBjaGlsZC5vYmplY3QpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCkge1xuICBpZiAoaXMuc3RyKGNoaWxkLnByb3BzLmF0dGFjaCkpIHtcbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50Lm9iamVjdCwgY2hpbGQucHJvcHMuYXR0YWNoKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJvb3Rba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2Ugcm9vdFtrZXldID0gcHJldmlvdXM7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGQucHJldmlvdXNBdHRhY2ggPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLnByZXZpb3VzQXR0YWNoKHBhcmVudC5vYmplY3QsIGNoaWxkLm9iamVjdCk7XG4gIH1cbiAgZGVsZXRlIGNoaWxkLnByZXZpb3VzQXR0YWNoO1xufVxuY29uc3QgUkVTRVJWRURfUFJPUFMgPSBbLi4uUkVBQ1RfSU5URVJOQUxfUFJPUFMsXG4vLyBJbnN0YW5jZSBwcm9wc1xuJ2FyZ3MnLCAnZGlzcG9zZScsICdhdHRhY2gnLCAnb2JqZWN0JywgJ29uVXBkYXRlJyxcbi8vIEJlaGF2aW9yIGZsYWdzXG4nZGlzcG9zZSddO1xuY29uc3QgTUVNT0laRURfUFJPVE9UWVBFUyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1lbW9pemVkUHJvdG90eXBlKHJvb3QpIHtcbiAgbGV0IGN0b3IgPSBNRU1PSVpFRF9QUk9UT1RZUEVTLmdldChyb290LmNvbnN0cnVjdG9yKTtcbiAgdHJ5IHtcbiAgICBpZiAoIWN0b3IpIHtcbiAgICAgIGN0b3IgPSBuZXcgcm9vdC5jb25zdHJ1Y3RvcigpO1xuICAgICAgTUVNT0laRURfUFJPVE9UWVBFUy5zZXQocm9vdC5jb25zdHJ1Y3RvciwgY3Rvcik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gLi4uXG4gIH1cbiAgcmV0dXJuIGN0b3I7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCBuZXdQcm9wcykge1xuICBjb25zdCBjaGFuZ2VkUHJvcHMgPSB7fTtcblxuICAvLyBTb3J0IHRocm91Z2ggcHJvcHNcbiAgZm9yIChjb25zdCBwcm9wIGluIG5ld1Byb3BzKSB7XG4gICAgLy8gU2tpcCByZXNlcnZlZCBrZXlzXG4gICAgaWYgKFJFU0VSVkVEX1BST1BTLmluY2x1ZGVzKHByb3ApKSBjb250aW51ZTtcbiAgICAvLyBTa2lwIGlmIHByb3BzIG1hdGNoXG4gICAgaWYgKGlzLmVxdShuZXdQcm9wc1twcm9wXSwgaW5zdGFuY2UucHJvcHNbcHJvcF0pKSBjb250aW51ZTtcblxuICAgIC8vIFByb3BzIGNoYW5nZWQsIGFkZCB0aGVtXG4gICAgY2hhbmdlZFByb3BzW3Byb3BdID0gbmV3UHJvcHNbcHJvcF07XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBvdGhlciBpbiBuZXdQcm9wcykge1xuICAgICAgaWYgKG90aGVyLnN0YXJ0c1dpdGgoYCR7cHJvcH0tYCkpIGNoYW5nZWRQcm9wc1tvdGhlcl0gPSBuZXdQcm9wc1tvdGhlcl07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgcmVtb3ZlZCBwcm9wcyBmb3IgSE1SXG4gIGZvciAoY29uc3QgcHJvcCBpbiBpbnN0YW5jZS5wcm9wcykge1xuICAgIGlmIChSRVNFUlZFRF9QUk9QUy5pbmNsdWRlcyhwcm9wKSB8fCBuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKGluc3RhbmNlLm9iamVjdCwgcHJvcCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTIwOVxuICAgIC8vIEhNUi9mYXN0LXJlZnJlc2ggcmVsaWVzIG9uIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCBvdXQgcHJvcHMsIGJ1dCB0aHJlZWpzXG4gICAgLy8gaGFzIG5vIG1lYW5zIHRvIGRvIHRoaXMuIEhlbmNlIHdlIGN1cmF0ZSBhIHNtYWxsIGNvbGxlY3Rpb24gb2YgdmFsdWUtY2xhc3Nlc1xuICAgIC8vIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25zdHJ1Y3Rvci9zZXQgYXJndW1lbnRzXG4gICAgLy8gRm9yIHJlbW92ZWQgcHJvcHMsIHRyeSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHJvb3QuY29uc3RydWN0b3IgJiYgcm9vdC5jb25zdHJ1Y3Rvci5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICBjb25zdCBjdG9yID0gZ2V0TWVtb2l6ZWRQcm90b3R5cGUocm9vdCk7XG4gICAgICBpZiAoIWlzLnVuZChjdG9yKSkgY2hhbmdlZFByb3BzW2tleV0gPSBjdG9yW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgIGNoYW5nZWRQcm9wc1trZXldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWRQcm9wcztcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI3MDQyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjI3NDhcbmNvbnN0IGNvbG9yTWFwcyA9IFsnbWFwJywgJ2VtaXNzaXZlTWFwJywgJ3NoZWVuQ29sb3JNYXAnLCAnc3BlY3VsYXJDb2xvck1hcCcsICdlbnZNYXAnXTtcbmNvbnN0IEVWRU5UX1JFR0VYID0gL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS87XG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMob2JqZWN0LCBwcm9wcykge1xuICB2YXIgX2luc3RhbmNlJG9iamVjdDtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3QuX19yM2Y7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGluc3RhbmNlICYmIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmV2ZW50Q291bnQ7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGxldCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuXG4gICAgLy8gRG9uJ3QgbXV0YXRlIHJlc2VydmVkIGtleXNcbiAgICBpZiAoUkVTRVJWRURfUFJPUFMuaW5jbHVkZXMocHJvcCkpIGNvbnRpbnVlO1xuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzLCBpbmNsdWRpbmcgcmVtb3ZpbmcgdGhlbSBpZiB1bmRlZmluZWRcbiAgICBpZiAoaW5zdGFuY2UgJiYgRVZFTlRfUkVHRVgudGVzdChwcm9wKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgaW5zdGFuY2UuaGFuZGxlcnNbcHJvcF0gPSB2YWx1ZTtlbHNlIGRlbGV0ZSBpbnN0YW5jZS5oYW5kbGVyc1twcm9wXTtcbiAgICAgIGluc3RhbmNlLmV2ZW50Q291bnQgPSBPYmplY3Qua2V5cyhpbnN0YW5jZS5oYW5kbGVycykubGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHNldHRpbmcgdW5kZWZpbmVkIHByb3BzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGxldCB7XG4gICAgICByb290LFxuICAgICAga2V5LFxuICAgICAgdGFyZ2V0XG4gICAgfSA9IHJlc29sdmUob2JqZWN0LCBwcm9wKTtcblxuICAgIC8vIExheWVycyBtdXN0IGJlIHdyaXR0ZW4gdG8gdGhlIG1hc2sgcHJvcGVydHlcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB7XG4gICAgICB0YXJnZXQubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgfVxuICAgIC8vIFNldCBjb2xvcnMgaWYgdmFsaWQgY29sb3IgcmVwcmVzZW50YXRpb24gZm9yIGF1dG9tYXRpYyBjb252ZXJzaW9uIChjb3B5KVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICYmIGlzQ29sb3JSZXByZXNlbnRhdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5zZXQodmFsdWUpO1xuICAgIH1cbiAgICAvLyBDb3B5IGlmIHByb3BlcnRpZXMgbWF0Y2ggc2lnbmF0dXJlcyBhbmQgaW1wbGVtZW50IG1hdGggaW50ZXJmYWNlIChsaWtlbHkgcmVhZC1vbmx5KVxuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGFyZ2V0LmNvcHkgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0YXJnZXQuY29weSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNldCBhcnJheSB0eXBlc1xuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuZnJvbUFycmF5ID09PSAnZnVuY3Rpb24nKSB0YXJnZXQuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldC5zZXQoLi4udmFsdWUpO1xuICAgIH1cbiAgICAvLyBTZXQgbGl0ZXJhbCB0eXBlc1xuICAgIGVsc2UgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0LnNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LnNldFNjYWxhciA9PT0gJ2Z1bmN0aW9uJykgdGFyZ2V0LnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgc2luZ2xlIHZhbHVlXG4gICAgICBlbHNlIHRhcmdldC5zZXQodmFsdWUpO1xuICAgIH1cbiAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICBlbHNlIHtcbiAgICAgIHZhciBfcm9vdCRrZXk7XG4gICAgICByb290W2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBidWlsdC1pbiBtYXRlcmlhbHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1ODU3XG4gICAgICBpZiAocm9vdFN0YXRlICYmICFyb290U3RhdGUubGluZWFyICYmIGNvbG9yTWFwcy5pbmNsdWRlcyhrZXkpICYmIChfcm9vdCRrZXkgPSByb290W2tleV0pICE9IG51bGwgJiYgX3Jvb3Qka2V5LmlzVGV4dHVyZSAmJlxuICAgICAgLy8gc1JHQiB0ZXh0dXJlcyBtdXN0IGJlIFJHQkE4IHNpbmNlIHIxMzcgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMTI5XG4gICAgICByb290W2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHJvb3Rba2V5XS50eXBlID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgY2Fubm90IGJlIHNldCBmcm9tIHRoZSByZW5kZXJlciAoZS5nLiBzUkdCIHNvdXJjZSB0ZXh0dXJlcyByZW5kZXJlZCB0byBQMylcbiAgICAgICAgcm9vdFtrZXldLmNvbG9yU3BhY2UgPSBUSFJFRS5TUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5wYXJlbnQgJiYgcm9vdFN0YXRlICE9IG51bGwgJiYgcm9vdFN0YXRlLmludGVybmFsICYmIChfaW5zdGFuY2Ukb2JqZWN0ID0gaW5zdGFuY2Uub2JqZWN0KSAhPSBudWxsICYmIF9pbnN0YW5jZSRvYmplY3QuaXNPYmplY3QzRCAmJiBwcmV2SGFuZGxlcnMgIT09IGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICBjb25zdCBvYmplY3QgPSBpbnN0YW5jZS5vYmplY3Q7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChpbnN0YW5jZS5ldmVudENvdW50ICYmIG9iamVjdC5yYXljYXN0ICE9PSBudWxsKSB7XG4gICAgICByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8tYXR0YWNoIGdlb21ldHJpZXMgYW5kIG1hdGVyaWFsc1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJvcHMuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaW5zdGFuY2Uub2JqZWN0LmlzQnVmZmVyR2VvbWV0cnkpIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9ICdnZW9tZXRyeSc7ZWxzZSBpZiAoaW5zdGFuY2Uub2JqZWN0LmlzTWF0ZXJpYWwpIGluc3RhbmNlLnByb3BzLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gIH1cblxuICAvLyBJbnN0YW5jZSB3YXMgdXBkYXRlZCwgcmVxdWVzdCBhIGZyYW1lXG4gIGlmIChpbnN0YW5jZSkgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJHJvb3Q7XG4gIGlmICghaW5zdGFuY2UucGFyZW50KSByZXR1cm47XG4gIGluc3RhbmNlLnByb3BzLm9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5wcm9wcy5vblVwZGF0ZShpbnN0YW5jZS5vYmplY3QpO1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2Ukcm9vdCA9IGluc3RhbmNlLnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2Ukcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICBpZiAoY2FtZXJhLm1hbnVhbCkgcmV0dXJuO1xuICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgIGNhbWVyYS5yaWdodCA9IHNpemUud2lkdGggLyAyO1xuICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gIH0gZWxzZSB7XG4gICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgfVxuICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xufVxuY29uc3QgaXNPYmplY3QzRCA9IG9iamVjdCA9PiBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdC5pc09iamVjdDNEO1xuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8qKlxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxuICogVGhpcyBpcyBjYWxsZWQgYnkgcmVsZWFzZVBvaW50ZXJDYXB0dXJlIGluIHRoZSBBUEksIGFuZCB3aGVuIGFuIG9iamVjdCBpcyByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShjYXB0dXJlZE1hcCwgb2JqLCBjYXB0dXJlcywgcG9pbnRlcklkKSB7XG4gIGNvbnN0IGNhcHR1cmVEYXRhID0gY2FwdHVyZXMuZ2V0KG9iaik7XG4gIGlmIChjYXB0dXJlRGF0YSkge1xuICAgIGNhcHR1cmVzLmRlbGV0ZShvYmopO1xuICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IGNhcHR1cmluZyBvYmplY3QgZm9yIHRoaXMgcG9pbnRlclxuICAgIGlmIChjYXB0dXJlcy5zaXplID09PSAwKSB7XG4gICAgICBjYXB0dXJlZE1hcC5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgIGNhcHR1cmVEYXRhLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUludGVyYWN0aXZpdHkoc3RvcmUsIG9iamVjdCkge1xuICBjb25zdCB7XG4gICAgaW50ZXJuYWxcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIC8vIFJlbW92ZXMgZXZlcnkgdHJhY2Ugb2YgYW4gb2JqZWN0IGZyb20gdGhlIGRhdGEgc3RvcmVcbiAgaW50ZXJuYWwuaW50ZXJhY3Rpb24gPSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGludGVybmFsLmluaXRpYWxIaXRzLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmhvdmVyZWQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh2YWx1ZS5ldmVudE9iamVjdCA9PT0gb2JqZWN0IHx8IHZhbHVlLm9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGludGVybmFsLmNhcHR1cmVkTWFwLmZvckVhY2goKGNhcHR1cmVzLCBwb2ludGVySWQpID0+IHtcbiAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgb2JqZWN0LCBjYXB0dXJlcywgcG9pbnRlcklkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudHMoc3RvcmUpIHtcbiAgLyoqIENhbGN1bGF0ZXMgZGVsdGEgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR4ID0gZXZlbnQub2Zmc2V0WCAtIGludGVybmFsLmluaXRpYWxDbGlja1swXTtcbiAgICBjb25zdCBkeSA9IGV2ZW50Lm9mZnNldFkgLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMV07XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIGluc3RhbmNlIGhhcyBhIHZhbGlkIHBvaW50ZXItZXZlbnQgcmVnaXN0ZXJlZCwgdGhpcyBleGNsdWRlcyBzY3JvbGwsIGNsaWNrcyBldGMgKi9cbiAgZnVuY3Rpb24gZmlsdGVyUG9pbnRlckV2ZW50cyhvYmplY3RzKSB7XG4gICAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKG9iaiA9PiBbJ01vdmUnLCAnT3ZlcicsICdFbnRlcicsICdPdXQnLCAnTGVhdmUnXS5zb21lKG5hbWUgPT4ge1xuICAgICAgdmFyIF9yM2Y7XG4gICAgICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLmhhbmRsZXJzWydvblBvaW50ZXInICsgbmFtZV07XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGludGVyc2VjdChldmVudCwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIC8vIEFsbG93IGNhbGxlcnMgdG8gZWxpbWluYXRlIGV2ZW50IG9iamVjdHNcbiAgICBjb25zdCBldmVudHNPYmplY3RzID0gZmlsdGVyID8gZmlsdGVyKHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uKSA6IHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uO1xuICAgIC8vIFJlc2V0IGFsbCByYXljYXN0ZXIgY2FtZXJhcyB0byB1bmRlZmluZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50c09iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGV2ZW50c09iamVjdHNbaV0pO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhdGUucHJldmlvdXNSb290KSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcm9vdC1sZXZlbCBwb2ludGVyIGFuZCByYXkgYXJlIHNldCB1cFxuICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJheWNhc3Qob2JqKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShvYmopO1xuICAgICAgLy8gU2tpcCBldmVudCBoYW5kbGluZyB3aGVuIG5vRXZlbnRzIGlzIHNldCwgb3Igd2hlbiB0aGUgcmF5Y2FzdGVycyBjYW1lcmEgaXMgbnVsbFxuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuZXZlbnRzLmVuYWJsZWQgfHwgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gICAgICAvLyBXaGVuIHRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkIHdlIGhhdmUgdG8gY2FsbCB0aGUgZXZlbnQgbGF5ZXJzIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3N0YXRlJHByZXZpb3VzUm9vdDtcbiAgICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSwgKF9zdGF0ZSRwcmV2aW91c1Jvb3QgPSBzdGF0ZS5wcmV2aW91c1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkcHJldmlvdXNSb290LmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBJZiB0aGUgY2FtZXJhIGlzIHN0aWxsIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIHNraXAgdGhpcyBsYXllciBlbnRpcmVseVxuICAgICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJzZWN0IG9iamVjdCBieSBvYmplY3RcbiAgICAgIHJldHVybiBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID8gc3RhdGUucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdChvYmosIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBldmVudHNcbiAgICBsZXQgaGl0cyA9IGV2ZW50c09iamVjdHNcbiAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0c1xuICAgIC5mbGF0TWFwKGhhbmRsZVJheWNhc3QpXG4gICAgLy8gU29ydCBieSBldmVudCBwcmlvcml0eSBhbmQgZGlzdGFuY2VcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYVN0YXRlID0gZ2V0Um9vdFN0YXRlKGEub2JqZWN0KTtcbiAgICAgIGNvbnN0IGJTdGF0ZSA9IGdldFJvb3RTdGF0ZShiLm9iamVjdCk7XG4gICAgICBpZiAoIWFTdGF0ZSB8fCAhYlN0YXRlKSByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgICByZXR1cm4gYlN0YXRlLmV2ZW50cy5wcmlvcml0eSAtIGFTdGF0ZS5ldmVudHMucHJpb3JpdHkgfHwgYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgfSlcbiAgICAvLyBGaWx0ZXIgb3V0IGR1cGxpY2F0ZXNcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaWQgPSBtYWtlSWQoaXRlbSk7XG4gICAgICBpZiAoZHVwbGljYXRlcy5oYXMoaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICBkdXBsaWNhdGVzLmFkZChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE2MDMxXG4gICAgLy8gQWxsb3cgY3VzdG9tIHVzZXJsYW5kIGludGVyc2VjdCBzb3J0IG9yZGVyLCB0aGlzIGxpa2VseSBvbmx5IG1ha2VzIHNlbnNlIG9uIHRoZSByb290IGZpbHRlclxuICAgIGlmIChzdGF0ZS5ldmVudHMuZmlsdGVyKSBoaXRzID0gc3RhdGUuZXZlbnRzLmZpbHRlcihoaXRzLCBzdGF0ZSk7XG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGV2ZW50cywgZmluZCB0aGUgZXZlbnQgc291cmNlIChldmVudE9iamVjdClcbiAgICBmb3IgKGNvbnN0IGhpdCBvZiBoaXRzKSB7XG4gICAgICBsZXQgZXZlbnRPYmplY3QgPSBoaXQub2JqZWN0O1xuICAgICAgLy8gQnViYmxlIGV2ZW50IHVwXG4gICAgICB3aGlsZSAoZXZlbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIF9yM2YyO1xuICAgICAgICBpZiAoKF9yM2YyID0gZXZlbnRPYmplY3QuX19yM2YpICE9IG51bGwgJiYgX3IzZjIuZXZlbnRDb3VudCkgaW50ZXJzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgZXZlbnRPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50T2JqZWN0ID0gZXZlbnRPYmplY3QucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbnRlcmFjdGlvbiBpcyBjYXB0dXJlZCwgbWFrZSBhbGwgY2FwdHVyaW5nIHRhcmdldHMgcGFydCBvZiB0aGUgaW50ZXJzZWN0LlxuICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgZm9yIChsZXQgY2FwdHVyZURhdGEgb2Ygc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCkudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGVzLmhhcyhtYWtlSWQoY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKSkpIGludGVyc2VjdGlvbnMucHVzaChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIC8qKiAgSGFuZGxlcyBpbnRlcnNlY3Rpb25zIGJ5IGZvcndhcmRpbmcgdGhlbSB0byBoYW5kbGVycyAqL1xuICBmdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3RzKGludGVyc2VjdGlvbnMsIGV2ZW50LCBkZWx0YSwgY2FsbGJhY2spIHtcbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGhpdC5vYmplY3QpO1xuXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbm90IG1hbmFnZWQgYnkgUjNGLCBpdCBtaWdodCBiZSBwYXJlbnRlZCB0byBhbiBlbGVtZW50IHdoaWNoIGlzLlxuICAgICAgICAvLyBUcmF2ZXJzZSB1cHdhcmRzIHVudGlsIHdlIGZpbmQgYSBtYW5hZ2VkIHBhcmVudCBhbmQgdXNlIGl0cyBzdGF0ZSBpbnN0ZWFkLlxuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgaGl0Lm9iamVjdC50cmF2ZXJzZUFuY2VzdG9ycyhvYmogPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50U3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHBhcmVudFN0YXRlO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICAgIGNvbnN0IHVucHJvamVjdGVkUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb2ludGVyLngsIHBvaW50ZXIueSwgMCkudW5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgICAgcmV0dXJuIChfaW50ZXJuYWwkY2FwdHVyZWRNYXAgPSAoX2ludGVybmFsJGNhcHR1cmVkTWFwMiA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSAhPSBudWxsID8gX2ludGVybmFsJGNhcHR1cmVkTWFwIDogZmFsc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVEYXRhID0ge1xuICAgICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgICAgLy8gZXZlbnQgY2FwdHVyZWRNYXAuXG4gICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgbm90IHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGNyZWF0ZSBhIG1hcFxuICAgICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuc2V0KGlkLCBuZXcgTWFwKFtbaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgICAvLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50J3MgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIGluaGVyaXRlZCBvbmVzLiBOYXRpdmUgUG9pbnRlckV2ZW50cyBoYXZlIG1vc3Qgb2YgdGhlaXIgcHJvcHMgYXMgZ2V0dGVycyB3aGljaCBhcmUgaW5oZXJpdGVkLCBidXQgcG9seWZpbGxlZCBQb2ludGVyRXZlbnRzIGhhdmUgdGhlbSBhbGwgYXMgdGhlaXIgb3duIHByb3BlcnRpZXMgKGkuZS4gbm90IGluaGVyaXRlZCkuIFdlIGNhbid0IHVzZSBPYmplY3Qua2V5cygpIG9yIE9iamVjdC5lbnRyaWVzKCkgYXMgdGhleSBvbmx5IHJldHVybiBcIm93blwiIHByb3BlcnRpZXM7IG5vciBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpIGFzIHRoYXQgKmRvZXNuJ3QqIHJldHVybiBcIm93blwiIHByb3BlcnRpZXMsIG9ubHkgaW5oZXJpdGVkIG9uZXMuXG4gICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgICAvLyBPbmx5IGNvcHkgb3ZlciBhdG9taWNzLCBsZWF2ZSBmdW5jdGlvbnMgYWxvbmUgYXMgdGhlc2Ugc2hvdWxkIGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAgIC4uLmV4dHJhY3RFdmVudFByb3BzLFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgICBzdG9wcGVkOiBsb2NhbFN0YXRlLnN0b3BwZWQsXG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgICByYXk6IHJheWNhc3Rlci5yYXksXG4gICAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlc0ZvclBvaW50ZXIgPSAncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKTtcblxuICAgICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyAuLi5pZiB0aGlzIHBvaW50ZXIgaGFzbid0IGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICAgIGNhcHR1cmVzRm9yUG9pbnRlci5oYXMoaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgYWxsb3dlZCB0byBmbHVzaCBvdGhlciBoYW5kbGVycyBpZiBpdCBpcyBob3ZlcmVkIGl0c2VsZlxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgaW50ZXJzZWN0aW9ucy5pbmRleE9mKGhpdCkpO1xuICAgICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBDYWxsIHN1YnNjcmliZXJzXG4gICAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgaWYgKGxvY2FsU3RhdGUuc3RvcHBlZCA9PT0gdHJ1ZSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgLi4uaG92ZXJlZE9iaixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck91dCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3V0KGRhdGEpO1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyTWlzc2VkKGV2ZW50LCBvYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdHNbaV0uX19yM2Y7XG4gICAgICBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyKG5hbWUpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FuY2VsYXRpb25cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ29uUG9pbnRlckxlYXZlJzpcbiAgICAgIGNhc2UgJ29uUG9pbnRlckNhbmNlbCc6XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgIGNhc2UgJ29uTG9zdFBvaW50ZXJDYXB0dXJlJzpcbiAgICAgICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuIFdlIGNhbGwgaXQgb24gdGhlIG5leHQgZnJhbWUgYmVjYXVzZSBvbkxvc3RQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgLy8gZmlyZXMgYmVmb3JlIG9uUG9pbnRlclVwLiBPdGhlcndpc2UgcG9pbnRlclVwIHdvdWxkIG5ldmVyIGJlIGNhbGxlZCBpZiB0aGUgZXZlbnQgZGlkbid0XG4gICAgICAgICAgICAvLyBoYXBwZW4gaW4gdGhlIG9iamVjdCBpdCBvcmlnaW5hdGVkIGZyb20sIGxlYXZpbmcgY29tcG9uZW50cyBpbiBhIGluLWJldHdlZW4gc3RhdGUuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHJlbGVhc2UgaWYgcG9pbnRlci11cCBkaWRuJ3QgZG8gaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFueSBvdGhlciBwb2ludGVyIGdvZXMgaGVyZSAuLi5cbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIHByZXBhcmVSYXkoZXZlbnQpXG4gICAgICBpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCA9IGV2ZW50O1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdvblBvaW50ZXJNb3ZlJztcbiAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IG5hbWUgPT09ICdvbkNsaWNrJyB8fCBuYW1lID09PSAnb25Db250ZXh0TWVudScgfHwgbmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snO1xuICAgICAgY29uc3QgZmlsdGVyID0gaXNQb2ludGVyTW92ZSA/IGZpbHRlclBvaW50ZXJFdmVudHMgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBoaXRzID0gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpO1xuICAgICAgY29uc3QgZGVsdGEgPSBpc0NsaWNrRXZlbnQgPyBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkgOiAwO1xuXG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ29uUG9pbnRlckRvd24nKSB7XG4gICAgICAgIGludGVybmFsLmluaXRpYWxDbGljayA9IFtldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBoaXRzLm1hcChoaXQgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKG9uUG9pbnRlck1pc3NlZCkgb25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGFrZSBjYXJlIG9mIHVuaG92ZXJcbiAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSBjYW5jZWxQb2ludGVyKGhpdHMpO1xuICAgICAgZnVuY3Rpb24gb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlLmhhbmRsZXJzO1xuXG4gICAgICAgIC8qXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RvcmUgPSBjcmVhdGVXaXRoRXF1YWxpdHlGbigoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldC5pc1ZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICB4cjogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHRvcCA9IDAsIGxlZnQgPSAwKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnRcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgIGludGVyYWN0aW9uOiBbXSxcbiAgICAgICAgaG92ZXJlZDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgIGluaXRpYWxDbGljazogWzAsIDBdLFxuICAgICAgICBpbml0aWFsSGl0czogW10sXG4gICAgICAgIGNhcHR1cmVkTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICAvLyBVcGRhdGVzXG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIHN1YnNjcmliZTogKHJlZiwgcHJpb3JpdHksIHN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAvLyBJZiB0aGlzIHN1YnNjcmlwdGlvbiB3YXMgZ2l2ZW4gYSBwcmlvcml0eSwgaXQgdGFrZXMgcmVuZGVyaW5nIGludG8gaXRzIG93biBoYW5kc1xuICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiB3ZSBzd2l0Y2ggb2ZmIGF1dG9tYXRpYyByZW5kZXJpbmcgYW5kIGluY3JlYXNlIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlIHRoZXJlIGNhbiBiZSBubyBpbnRlcm5hbCByZW5kZXJpbmcgYXQgYWxsXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgKyAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdG9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIHN1YnNjcmliZXIgYW5kIHNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsXG4gICAgICAgICAgLy8gaGlnaGVzdCBwcmlvcml0eSByZW5kZXJzIGxhc3QgKG9uIHRvcCBvZiB0aGUgb3RoZXIgZnJhbWVzKVxuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwgJiYgaW50ZXJuYWwuc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgbWFudWFsIGZsYWcgaWYgdGhpcyBzdWJzY3JpcHRpb24gaGFkIGEgcHJpb3JpdHlcbiAgICAgICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSAtIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLmZpbHRlcihzID0+IHMucmVmICE9PSByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByb290U3RhdGU7XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuICBsZXQgb2xkU2l6ZSA9IHN0YXRlLnNpemU7XG4gIGxldCBvbGREcHIgPSBzdGF0ZS52aWV3cG9ydC5kcHI7XG4gIGxldCBvbGRDYW1lcmEgPSBzdGF0ZS5jYW1lcmE7XG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIHNpemUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGdsLFxuICAgICAgc2V0XG4gICAgfSA9IHJvb3RTdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gUmVzaXplIGNhbWVyYSBhbmQgcmVuZGVyZXIgb24gY2hhbmdlcyB0byBzaXplIGFuZCBwaXhlbHJhdGlvXG4gICAgaWYgKHNpemUud2lkdGggIT09IG9sZFNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IG9sZFNpemUuaGVpZ2h0IHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBpZiAodmlld3BvcnQuZHByID4gMCkgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdG9yZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RvcmU7XG59O1xuXG4vKipcbiAqIEV4cG9zZXMgYW4gb2JqZWN0J3Mge0BsaW5rIEluc3RhbmNlfS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxuICpcbiAqICoqTm90ZSoqOiB0aGlzIGlzIGFuIGVzY2FwZSBoYXRjaCB0byByZWFjdC1pbnRlcm5hbCBmaWVsZHMuIEV4cGVjdCB0aGlzIHRvIGNoYW5nZSBzaWduaWZpY2FudGx5IGJldHdlZW4gdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShpbnN0YW5jZSwgKCkgPT4gcmVmLmN1cnJlbnQuX19yM2YsIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIFIzRiBDYW52YXMnIFp1c3RhbmQgc3RvcmUuIFVzZWZ1bCBmb3IgW3RyYW5zaWVudCB1cGRhdGVzXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQjdHJhbnNpZW50LXVwZGF0ZXMtZm9yLW9mdGVuLW9jY3VycmluZy1zdGF0ZS1jaGFuZ2VzKS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXN0b3JlXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcignUjNGOiBIb29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCEnKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2V0aHJlZVxuICovXG5mdW5jdGlvbiB1c2VUaHJlZShzZWxlY3RvciA9IHN0YXRlID0+IHN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIHJldHVybiB1c2VTdG9yZSgpKHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cbiAqIENhbiBvcmRlciBlZmZlY3RzIHdpdGggcmVuZGVyIHByaW9yaXR5IG9yIG1hbnVhbGx5IHJlbmRlciB3aXRoIGEgcG9zaXRpdmUgcHJpb3JpdHkuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VmcmFtZVxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbm9kZSBncmFwaCBvZiBhbiBvYmplY3Qgd2l0aCBuYW1lZCBub2RlcyAmIG1hdGVyaWFscy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWdyYXBoXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmNvbnN0IG1lbW9pemVkTG9hZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpc0NvbnN0cnVjdG9yJDEgPSB2YWx1ZSA9PiB7XG4gIHZhciBfdmFsdWUkcHJvdG90eXBlO1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogKF92YWx1ZSRwcm90b3R5cGUgPSB2YWx1ZS5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfdmFsdWUkcHJvdG90eXBlLmNvbnN0cnVjdG9yKSA9PT0gdmFsdWU7XG59O1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICBsZXQgbG9hZGVyO1xuXG4gICAgLy8gQ29uc3RydWN0IGFuZCBjYWNoZSBsb2FkZXIgaWYgY29uc3RydWN0b3Igd2FzIHBhc3NlZFxuICAgIGlmIChpc0NvbnN0cnVjdG9yJDEoUHJvdG8pKSB7XG4gICAgICBsb2FkZXIgPSBtZW1vaXplZExvYWRlcnMuZ2V0KFByb3RvKTtcbiAgICAgIGlmICghbG9hZGVyKSB7XG4gICAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgICBtZW1vaXplZExvYWRlcnMuc2V0KFByb3RvLCBsb2FkZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXIgPSBQcm90bztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBsb2FkZXIgZXh0ZW5zaW9uc1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG5cbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0M0QoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5zY2VuZSkpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIGFuZCBjYWNoZXMgYXNzZXRzIHdpdGggYSB0aHJlZSBsb2FkZXIuXG4gKlxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWxvYWRlclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIobG9hZGVyLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtsb2FkZXIsIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3QocylcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpID8gcmVzdWx0cyA6IHJlc3VsdHNbMF07XG59XG5cbi8qKlxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxuICovXG51c2VMb2FkZXIucHJlbG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIsIGlucHV0LCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHByZWxvYWQobG9hZGluZ0ZuKGV4dGVuc2lvbnMpLCBbbG9hZGVyLCAuLi5rZXlzXSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKGxvYWRlciwgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW2xvYWRlciwgLi4ua2V5c10pO1xufTtcblxuLy8gVE9ETzogdXBzdHJlYW0gdG8gRGVmaW5pdGVseVR5cGVkIGZvciBSZWFjdCAxOVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yODk1NlxuXG5mdW5jdGlvbiBjcmVhdGVSZWNvbmNpbGVyKGNvbmZpZykge1xuICBjb25zdCByZWNvbmNpbGVyID0gUmVjb25jaWxlcihjb25maWcpO1xuICByZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gICAgYnVuZGxlVHlwZTogdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAxIDogMCxcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiAnQHJlYWN0LXRocmVlL2ZpYmVyJyxcbiAgICB2ZXJzaW9uOiBSZWFjdC52ZXJzaW9uXG4gIH0pO1xuICByZXR1cm4gcmVjb25jaWxlcjtcbn1cbmNvbnN0IE5vRXZlbnRQcmlvcml0eSA9IDA7XG5cbi8vIFRPRE86IGhhbmRsZSBjb25zdHJ1Y3RvciBvdmVybG9hZHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yOTMxXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3MDc5XG5cbmNvbnN0IGNhdGFsb2d1ZSA9IHt9O1xuY29uc3QgUFJFRklYX1JFR0VYID0gL150aHJlZSg/PVtBLVpdKS87XG5jb25zdCB0b1Bhc2NhbENhc2UgPSB0eXBlID0+IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbmxldCBpID0gMDtcbmNvbnN0IGlzQ29uc3RydWN0b3IgPSBvYmplY3QgPT4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGV4dGVuZChvYmplY3RzKSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKG9iamVjdHMpKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYCR7aSsrfWA7XG4gICAgY2F0YWxvZ3VlW0NvbXBvbmVudF0gPSBvYmplY3RzO1xuICAgIHJldHVybiBDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlKHR5cGUsIHByb3BzKSB7XG4gIC8vIEdldCB0YXJnZXQgZnJvbSBjYXRhbG9ndWVcbiAgY29uc3QgbmFtZSA9IHRvUGFzY2FsQ2FzZSh0eXBlKTtcbiAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuXG4gIC8vIFZhbGlkYXRlIGVsZW1lbnQgdGFyZ2V0XG4gIGlmICh0eXBlICE9PSAncHJpbWl0aXZlJyAmJiAhdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuXG4gIC8vIFZhbGlkYXRlIHByaW1pdGl2ZXNcbiAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnICYmICFwcm9wcy5vYmplY3QpIHRocm93IG5ldyBFcnJvcihgUjNGOiBQcmltaXRpdmVzIHdpdGhvdXQgJ29iamVjdCcgYXJlIGludmFsaWQhYCk7XG5cbiAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICBpZiAocHJvcHMuYXJncyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KHByb3BzLmFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMsIHJvb3QpIHtcbiAgdmFyIF9wcm9wcyRvYmplY3Q7XG4gIC8vIFJlbW92ZSB0aHJlZSogcHJlZml4IGZyb20gZWxlbWVudHMgaWYgbmF0aXZlIGVsZW1lbnQgbm90IHByZXNlbnRcbiAgdHlwZSA9IHRvUGFzY2FsQ2FzZSh0eXBlKSBpbiBjYXRhbG9ndWUgPyB0eXBlIDogdHlwZS5yZXBsYWNlKFBSRUZJWF9SRUdFWCwgJycpO1xuICB2YWxpZGF0ZUluc3RhbmNlKHR5cGUsIHByb3BzKTtcblxuICAvLyBSZWdlbmVyYXRlIHRoZSBSM0YgaW5zdGFuY2UgZm9yIHByaW1pdGl2ZXMgdG8gc2ltdWxhdGUgYSBuZXcgb2JqZWN0XG4gIGlmICh0eXBlID09PSAncHJpbWl0aXZlJyAmJiAoX3Byb3BzJG9iamVjdCA9IHByb3BzLm9iamVjdCkgIT0gbnVsbCAmJiBfcHJvcHMkb2JqZWN0Ll9fcjNmKSBkZWxldGUgcHJvcHMub2JqZWN0Ll9fcjNmO1xuICByZXR1cm4gcHJlcGFyZShwcm9wcy5vYmplY3QsIHJvb3QsIHR5cGUsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoIWluc3RhbmNlLmlzSGlkZGVuKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwYXJlbnQ7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCAmJiAoX2luc3RhbmNlJHBhcmVudCA9IGluc3RhbmNlLnBhcmVudCkgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcGFyZW50Lm9iamVjdCkge1xuICAgICAgZGV0YWNoKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpKSB7XG4gICAgICBpbnN0YW5jZS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpbnN0YW5jZS5pc0hpZGRlbiA9IHRydWU7XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmlzSGlkZGVuKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwYXJlbnQyO1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2ggJiYgKF9pbnN0YW5jZSRwYXJlbnQyID0gaW5zdGFuY2UucGFyZW50KSAhPSBudWxsICYmIF9pbnN0YW5jZSRwYXJlbnQyLm9iamVjdCkge1xuICAgICAgYXR0YWNoKGluc3RhbmNlLnBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpICYmIGluc3RhbmNlLnByb3BzLnZpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICBpbnN0YW5jZS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGluc3RhbmNlLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4vLyBUaGlzIHdpbGwgbWFrZSBzdXJlIGV2ZW50cyBhbmQgYXR0YWNoIGFyZSBvbmx5IGhhbmRsZWQgb25jZSB3aGVuIHRyZWVzIGFyZSBjb21wbGV0ZVxuZnVuY3Rpb24gaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhwYXJlbnQsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAvLyBCYWlsIGlmIHRyZWUgaXNuJ3QgbW91bnRlZCBvciBwYXJlbnQgaXMgbm90IGEgY29udGFpbmVyLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdHJlZSBpcyBmaW5hbGl6ZWQgYW5kIFJlYWN0IHdvbid0IGRpc2NhcmQgcmVzdWx0cyB0byBTdXNwZW5zZVxuICBjb25zdCBzdGF0ZSA9IGNoaWxkLnJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKCFwYXJlbnQucGFyZW50ICYmIHBhcmVudC5vYmplY3QgIT09IHN0YXRlLnNjZW5lKSByZXR1cm47XG5cbiAgLy8gQ3JlYXRlICYgbGluayBvYmplY3Qgb24gZmlyc3QgcnVuXG4gIGlmICghY2hpbGQub2JqZWN0KSB7XG4gICAgdmFyIF9jaGlsZCRwcm9wcyRvYmplY3QsIF9jaGlsZCRwcm9wcyRhcmdzO1xuICAgIC8vIEdldCB0YXJnZXQgZnJvbSBjYXRhbG9ndWVcbiAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbdG9QYXNjYWxDYXNlKGNoaWxkLnR5cGUpXTtcblxuICAgIC8vIENyZWF0ZSBvYmplY3RcbiAgICBjaGlsZC5vYmplY3QgPSAoX2NoaWxkJHByb3BzJG9iamVjdCA9IGNoaWxkLnByb3BzLm9iamVjdCkgIT0gbnVsbCA/IF9jaGlsZCRwcm9wcyRvYmplY3QgOiBuZXcgdGFyZ2V0KC4uLigoX2NoaWxkJHByb3BzJGFyZ3MgPSBjaGlsZC5wcm9wcy5hcmdzKSAhPSBudWxsID8gX2NoaWxkJHByb3BzJGFyZ3MgOiBbXSkpO1xuICAgIGNoaWxkLm9iamVjdC5fX3IzZiA9IGNoaWxkO1xuICB9XG5cbiAgLy8gU2V0IGluaXRpYWwgcHJvcHNcbiAgYXBwbHlQcm9wcyhjaGlsZC5vYmplY3QsIGNoaWxkLnByb3BzKTtcblxuICAvLyBBcHBlbmQgaW5zdGFuY2VcbiAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgIGF0dGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLmluZGV4T2YoYmVmb3JlQ2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGJlZm9yZUNoaWxkLm9iamVjdCk7XG4gICAgaWYgKGJlZm9yZUNoaWxkICYmIGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgYWxyZWFkeSBpbiB0aGUgcGFyZW50J3MgY2hpbGRyZW4gYXJyYXksIG1vdmUgaXQgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IGluc2VydCBpdCBhdCB0aGUgdGFyZ2V0IHBvc2l0aW9uXG4gICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5pbmRleE9mKGNoaWxkLm9iamVjdCk7XG4gICAgICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSk7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkSW5kZXggPSBleGlzdGluZ0luZGV4IDwgY2hpbGRJbmRleCA/IGNoaWxkSW5kZXggLSAxIDogY2hpbGRJbmRleDtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5jaGlsZHJlbi5zcGxpY2UoYWRqdXN0ZWRJbmRleCwgMCwgY2hpbGQub2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkLm9iamVjdC5wYXJlbnQgPSBwYXJlbnQub2JqZWN0O1xuICAgICAgICBwYXJlbnQub2JqZWN0LmNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZC5vYmplY3QpO1xuICAgICAgICBjaGlsZC5vYmplY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50Lm9iamVjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnY2hpbGRhZGRlZCcsXG4gICAgICAgICAgY2hpbGQ6IGNoaWxkLm9iamVjdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Lm9iamVjdC5hZGQoY2hpbGQub2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvLyBMaW5rIHN1YnRyZWVcbiAgZm9yIChjb25zdCBjaGlsZEluc3RhbmNlIG9mIGNoaWxkLmNoaWxkcmVuKSBoYW5kbGVDb250YWluZXJFZmZlY3RzKGNoaWxkLCBjaGlsZEluc3RhbmNlKTtcblxuICAvLyBUcmVlIHdhcyB1cGRhdGVkLCByZXF1ZXN0IGEgZnJhbWVcbiAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gIC8vIExpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gIC8vIEF0dGFjaCB0cmVlIG9uY2UgY29tcGxldGVcbiAgaGFuZGxlQ29udGFpbmVyRWZmZWN0cyhwYXJlbnQsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnQsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gIC8vIExpbmsgaW5zdGFuY2VzXG4gIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgY29uc3QgY2hpbGRJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkKTtlbHNlIHBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAvLyBBdHRhY2ggdHJlZSBvbmNlIGNvbXBsZXRlXG4gIGhhbmRsZUNvbnRhaW5lckVmZmVjdHMocGFyZW50LCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuZnVuY3Rpb24gZGlzcG9zZU9uSWRsZShvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QuZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhhbmRsZURpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIG5vLW9wXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEluIGEgdGVzdGluZyBlbnZpcm9ubWVudCwgY2xlYW51cCBpbW1lZGlhdGVseVxuICAgIGlmICh0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJykgaGFuZGxlRGlzcG9zZSgpO1xuICAgIC8vIE90aGVyd2lzZSwgdXNpbmcgYSByZWFsIEdQVSBzbyBzY2hlZHVsZSBjbGVhbnVwIHRvIHByZXZlbnQgc3RhbGxzXG4gICAgZWxzZSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHVuc3RhYmxlX0lkbGVQcmlvcml0eSwgaGFuZGxlRGlzcG9zZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gIC8vIFVubGluayBpbnN0YW5jZXNcbiAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgY29uc3QgY2hpbGRJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuXG4gIC8vIEVhZ2VybHkgdGVhciBkb3duIHRyZWVcbiAgaWYgKGNoaWxkLnByb3BzLmF0dGFjaCkge1xuICAgIGRldGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgIHBhcmVudC5vYmplY3QucmVtb3ZlKGNoaWxkLm9iamVjdCk7XG4gICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZC5vYmplY3QpO1xuICB9XG5cbiAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiB1bm1vdW50IGRpc3Bvc2FsIHdpdGggZGlzcG9zZT17bnVsbH1cbiAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9IGNoaWxkLnByb3BzLmRpc3Bvc2UgIT09IG51bGwgJiYgZGlzcG9zZSAhPT0gZmFsc2U7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcmVtb3ZlIGluc3RhbmNlIGNoaWxkcmVuXG4gIGZvciAobGV0IGkgPSBjaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSBjaGlsZC5jaGlsZHJlbltpXTtcbiAgICByZW1vdmVDaGlsZChjaGlsZCwgbm9kZSwgc2hvdWxkRGlzcG9zZSk7XG4gIH1cbiAgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAvLyBVbmxpbmsgaW5zdGFuY2Ugb2JqZWN0XG4gIGRlbGV0ZSBjaGlsZC5vYmplY3QuX19yM2Y7XG5cbiAgLy8gRGlzcG9zZSBvYmplY3Qgd2hlbmV2ZXIgdGhlIHJlY29uY2lsZXIgZmVlbHMgbGlrZSBpdC5cbiAgLy8gTmV2ZXIgZGlzcG9zZSBvZiBwcmltaXRpdmVzIGJlY2F1c2UgdGhlaXIgc3RhdGUgbWF5IGJlIGtlcHQgb3V0c2lkZSBvZiBSZWFjdCFcbiAgLy8gSW4gb3JkZXIgZm9yIGFuIG9iamVjdCB0byBiZSBhYmxlIHRvIGRpc3Bvc2UgaXRcbiAgLy8gICAtIGhhcyBhIGRpc3Bvc2UgbWV0aG9kXG4gIC8vICAgLSBjYW5ub3QgYmUgYSA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSAvPlxuICAvLyAgIC0gY2Fubm90IGJlIGEgVEhSRUUuU2NlbmUsIGJlY2F1c2UgdGhyZWUgaGFzIGJyb2tlbiBpdHMgb3duIEFQSVxuICBpZiAoc2hvdWxkRGlzcG9zZSAmJiBjaGlsZC50eXBlICE9PSAncHJpbWl0aXZlJyAmJiBjaGlsZC5vYmplY3QudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgIGRpc3Bvc2VPbklkbGUoY2hpbGQub2JqZWN0KTtcbiAgfVxuXG4gIC8vIFRyZWUgd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZSBmb3IgdG9wLWxldmVsIGluc3RhbmNlXG4gIGlmIChkaXNwb3NlID09PSB1bmRlZmluZWQpIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRGaWJlclJlZihmaWJlciwgcHVibGljSW5zdGFuY2UpIHtcbiAgZm9yIChjb25zdCBfZmliZXIgb2YgW2ZpYmVyLCBmaWJlci5hbHRlcm5hdGVdKSB7XG4gICAgaWYgKF9maWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBfZmliZXIucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9maWJlci5yZWZDbGVhbnVwID09IG51bGwgPyB2b2lkIDAgOiBfZmliZXIucmVmQ2xlYW51cCgpO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gX2ZpYmVyLnJlZihwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgX2ZpYmVyLnJlZkNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgfSBlbHNlIGlmIChfZmliZXIucmVmKSB7XG4gICAgICAgIF9maWJlci5yZWYuY3VycmVudCA9IHB1YmxpY0luc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgcmVjb25zdHJ1Y3RlZCA9IFtdO1xuZnVuY3Rpb24gc3dhcEluc3RhbmNlcygpIHtcbiAgLy8gRGV0YWNoIGluc3RhbmNlXG4gIGZvciAoY29uc3QgW2luc3RhbmNlXSBvZiByZWNvbnN0cnVjdGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gaW5zdGFuY2UucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGluc3RhbmNlLm9iamVjdCkgJiYgaXNPYmplY3QzRChwYXJlbnQub2JqZWN0KSkge1xuICAgICAgICBwYXJlbnQub2JqZWN0LnJlbW92ZShpbnN0YW5jZS5vYmplY3QpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucHJvcHMuYXR0YWNoKSB7XG4gICAgICAgICAgZGV0YWNoKGluc3RhbmNlLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QzRChjaGlsZC5vYmplY3QpICYmIGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSkge1xuICAgICAgICAgIGluc3RhbmNlLm9iamVjdC5yZW1vdmUoY2hpbGQub2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbGQgaW5zdGFuY2UgaXMgaGlkZGVuLCB3ZSBuZWVkIHRvIHVuaGlkZSBpdC5cbiAgICAvLyBSZWFjdCBhc3N1bWVzIGl0IGNhbiBkaXNjYXJkIGluc3RhbmNlcyBzaW5jZSB0aGV5J3JlIHB1cmUgZm9yIERPTS5cbiAgICAvLyBUaGlzIGlzbid0IHRydWUgZm9yIHVzIHNpbmNlIG91ciBsaWZldGltZXMgYXJlIGltcHVyZSBhbmQgbG9uZ2xpdmluZy5cbiAgICAvLyBTbywgd2UgbWFudWFsbHkgY2hlY2sgaWYgYW4gaW5zdGFuY2Ugd2FzIGhpZGRlbiBhbmQgdW5oaWRlIGl0LlxuICAgIGlmIChpbnN0YW5jZS5pc0hpZGRlbikgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuXG4gICAgLy8gRGlzcG9zZSBvZiBvbGQgb2JqZWN0IGlmIGFibGVcbiAgICBpZiAoaW5zdGFuY2Uub2JqZWN0Ll9fcjNmKSBkZWxldGUgaW5zdGFuY2Uub2JqZWN0Ll9fcjNmO1xuICAgIGlmIChpbnN0YW5jZS50eXBlICE9PSAncHJpbWl0aXZlJykgZGlzcG9zZU9uSWRsZShpbnN0YW5jZS5vYmplY3QpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGluc3RhbmNlXG4gIGZvciAoY29uc3QgW2luc3RhbmNlLCBwcm9wcywgZmliZXJdIG9mIHJlY29uc3RydWN0ZWQpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGNvbnN0IHBhcmVudCA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHByb3BzJG9iamVjLCBfaW5zdGFuY2UkcHJvcHMkYXJncztcbiAgICAgIC8vIEdldCB0YXJnZXQgZnJvbSBjYXRhbG9ndWVcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVt0b1Bhc2NhbENhc2UoaW5zdGFuY2UudHlwZSldO1xuXG4gICAgICAvLyBDcmVhdGUgb2JqZWN0XG4gICAgICBpbnN0YW5jZS5vYmplY3QgPSAoX2luc3RhbmNlJHByb3BzJG9iamVjID0gaW5zdGFuY2UucHJvcHMub2JqZWN0KSAhPSBudWxsID8gX2luc3RhbmNlJHByb3BzJG9iamVjIDogbmV3IHRhcmdldCguLi4oKF9pbnN0YW5jZSRwcm9wcyRhcmdzID0gaW5zdGFuY2UucHJvcHMuYXJncykgIT0gbnVsbCA/IF9pbnN0YW5jZSRwcm9wcyRhcmdzIDogW10pKTtcbiAgICAgIGluc3RhbmNlLm9iamVjdC5fX3IzZiA9IGluc3RhbmNlO1xuICAgICAgc2V0RmliZXJSZWYoZmliZXIsIGluc3RhbmNlLm9iamVjdCk7XG5cbiAgICAgIC8vIFNldCBpbml0aWFsIHByb3BzXG4gICAgICBhcHBseVByb3BzKGluc3RhbmNlLm9iamVjdCwgaW5zdGFuY2UucHJvcHMpO1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0M0QoaW5zdGFuY2Uub2JqZWN0KSAmJiBpc09iamVjdDNEKHBhcmVudC5vYmplY3QpKSB7XG4gICAgICAgIHBhcmVudC5vYmplY3QuYWRkKGluc3RhbmNlLm9iamVjdCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcy5hdHRhY2gpIHtcbiAgICAgICAgICBhdHRhY2goaW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdDNEKGNoaWxkLm9iamVjdCkgJiYgaXNPYmplY3QzRChpbnN0YW5jZS5vYmplY3QpKSB7XG4gICAgICAgICAgaW5zdGFuY2Uub2JqZWN0LmFkZChjaGlsZC5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyZWUgd2FzIHVwZGF0ZWQsIHJlcXVlc3QgYSBmcmFtZVxuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgcmVjb25zdHJ1Y3RlZC5sZW5ndGggPSAwO1xufVxuXG4vLyBEb24ndCBoYW5kbGUgdGV4dCBpbnN0YW5jZXMsIG1ha2UgaXQgbm8tb3BcbmNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IHt9O1xuY29uc3QgTk9fQ09OVEVYVCA9IHt9O1xubGV0IGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vRXZlbnRQcmlvcml0eTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyL3NyYy9SZWFjdEZpYmVyRmxhZ3MuanNcbmNvbnN0IE5vRmxhZ3MgPSAwO1xuY29uc3QgVXBkYXRlID0gNDtcbmNvbnN0IHJlY29uY2lsZXIgPSAvKiBAX19QVVJFX18gKi9jcmVhdGVSZWNvbmNpbGVyKHtcbiAgaXNQcmltYXJ5UmVuZGVyZXI6IGZhbHNlLFxuICB3YXJuc0lmTm90QWN0aW5nOiBmYWxzZSxcbiAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gIHN1cHBvcnRzSHlkcmF0aW9uOiBmYWxzZSxcbiAgY3JlYXRlSW5zdGFuY2UsXG4gIHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZCxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlLFxuICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIXNjZW5lKSByZXR1cm47XG4gICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgfSxcbiAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIXNjZW5lKSByZXR1cm47XG4gICAgcmVtb3ZlQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgfSxcbiAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLl9fcjNmO1xuICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkIHx8ICFzY2VuZSkgcmV0dXJuO1xuICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSxcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBOT19DT05URVhULFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiAoKSA9PiBOT19DT05URVhULFxuICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX25ld1Byb3BzJGFyZ3MsIF9vbGRQcm9wcyRhcmdzLCBfbmV3UHJvcHMkYXJnczI7XG4gICAgdmFsaWRhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcyk7XG4gICAgbGV0IHJlY29uc3RydWN0ID0gZmFsc2U7XG5cbiAgICAvLyBSZWNvbnN0cnVjdCBwcmltaXRpdmVzIGlmIG9iamVjdCBwcm9wIGNoYW5nZXNcbiAgICBpZiAoaW5zdGFuY2UudHlwZSA9PT0gJ3ByaW1pdGl2ZScgJiYgb2xkUHJvcHMub2JqZWN0ICE9PSBuZXdQcm9wcy5vYmplY3QpIHJlY29uc3RydWN0ID0gdHJ1ZTtcbiAgICAvLyBSZWNvbnN0cnVjdCBpbnN0YW5jZSBpZiBhcmdzIHdlcmUgYWRkZWQgb3IgcmVtb3ZlZFxuICAgIGVsc2UgaWYgKCgoX25ld1Byb3BzJGFyZ3MgPSBuZXdQcm9wcy5hcmdzKSA9PSBudWxsID8gdm9pZCAwIDogX25ld1Byb3BzJGFyZ3MubGVuZ3RoKSAhPT0gKChfb2xkUHJvcHMkYXJncyA9IG9sZFByb3BzLmFyZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUHJvcHMkYXJncy5sZW5ndGgpKSByZWNvbnN0cnVjdCA9IHRydWU7XG4gICAgLy8gUmVjb25zdHJ1Y3QgaW5zdGFuY2UgaWYgYXJncyB3ZXJlIGNoYW5nZWRcbiAgICBlbHNlIGlmICgoX25ld1Byb3BzJGFyZ3MyID0gbmV3UHJvcHMuYXJncykgIT0gbnVsbCAmJiBfbmV3UHJvcHMkYXJnczIuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICB2YXIgX29sZFByb3BzJGFyZ3MyO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9vbGRQcm9wcyRhcmdzMiA9IG9sZFByb3BzLmFyZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUHJvcHMkYXJnczJbaW5kZXhdKTtcbiAgICB9KSkgcmVjb25zdHJ1Y3QgPSB0cnVlO1xuXG4gICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgIGlmIChyZWNvbnN0cnVjdCkge1xuICAgICAgcmVjb25zdHJ1Y3RlZC5wdXNoKFtpbnN0YW5jZSwge1xuICAgICAgICAuLi5uZXdQcm9wc1xuICAgICAgfSwgZmliZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgZGlmZi1zZXQsIGZsYWcgaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzXG4gICAgICBjb25zdCBjaGFuZ2VkUHJvcHMgPSBkaWZmUHJvcHMoaW5zdGFuY2UsIG5ld1Byb3BzKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhjaGFuZ2VkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLnByb3BzLCBjaGFuZ2VkUHJvcHMpO1xuICAgICAgICBhcHBseVByb3BzKGluc3RhbmNlLm9iamVjdCwgY2hhbmdlZFByb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGbHVzaCByZWNvbnN0cnVjdGVkIHNpYmxpbmdzIHdoZW4gd2UgaGl0IHRoZSBsYXN0IHVwZGF0ZWQgY2hpbGQgaW4gYSBzZXF1ZW5jZVxuICAgIGNvbnN0IGlzVGFpbFNpYmxpbmcgPSBmaWJlci5zaWJsaW5nID09PSBudWxsIHx8IChmaWJlci5mbGFncyAmIFVwZGF0ZSkgPT09IE5vRmxhZ3M7XG4gICAgaWYgKGlzVGFpbFNpYmxpbmcpIHN3YXBJbnN0YW5jZXMoKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46ICgpID0+IGZhbHNlLFxuICBjb21taXRNb3VudCgpIHt9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9iamVjdCxcbiAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSwgY29udGFpbmVyLCAnJywge30pLFxuICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gIGhpZGVJbnN0YW5jZSxcbiAgdW5oaWRlSW5zdGFuY2UsXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICBzY2hlZHVsZVRpbWVvdXQ6IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgY2FuY2VsVGltZW91dDogdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZCxcbiAgbm9UaW1lb3V0OiAtMSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogKCkgPT4gbnVsbCxcbiAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyKCkge30sXG4gIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyKCkge30sXG4gIGRldGFjaERlbGV0ZWRJbnN0YW5jZSgpIHt9LFxuICBwcmVwYXJlU2NvcGVVcGRhdGUoKSB7fSxcbiAgZ2V0SW5zdGFuY2VGcm9tU2NvcGU6ICgpID0+IG51bGwsXG4gIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb246ICgpID0+IGZhbHNlLFxuICB0cmFja1NjaGVkdWxlckV2ZW50OiAoKSA9PiB7fSxcbiAgcmVzb2x2ZUV2ZW50VHlwZTogKCkgPT4gbnVsbCxcbiAgcmVzb2x2ZUV2ZW50VGltZVN0YW1wOiAoKSA9PiAtMS4xLFxuICByZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2soKSB7fSxcbiAgbWF5U3VzcGVuZENvbW1pdDogKCkgPT4gZmFsc2UsXG4gIHByZWxvYWRJbnN0YW5jZTogKCkgPT4gdHJ1ZSxcbiAgLy8gdHJ1ZSBpbmRpY2F0ZXMgYWxyZWFkeSBsb2FkZWRcbiAgc3RhcnRTdXNwZW5kaW5nQ29tbWl0KCkge30sXG4gIHN1c3BlbmRJbnN0YW5jZSgpIHt9LFxuICB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5OiAoKSA9PiBudWxsLFxuICBOb3RQZW5kaW5nVHJhbnNpdGlvbjogbnVsbCxcbiAgSG9zdFRyYW5zaXRpb25Db250ZXh0OiAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpLFxuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkobmV3UHJpb3JpdHkpIHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbiAgfSxcbiAgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCkge1xuICAgIHJldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG4gIH0sXG4gIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpIHtcbiAgICB2YXIgX3dpbmRvdyRldmVudDtcbiAgICBpZiAoY3VycmVudFVwZGF0ZVByaW9yaXR5ICE9PSBOb0V2ZW50UHJpb3JpdHkpIHJldHVybiBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG4gICAgc3dpdGNoICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZXZlbnQgPSB3aW5kb3cuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JGV2ZW50LnR5cGUpKSB7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBjYXNlICdkYmxjbGljayc6XG4gICAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gICAgfVxuICB9LFxuICByZXNldEZvcm1JbnN0YW5jZSgpIHt9XG59KTtcblxuY29uc3QgX3Jvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qgc2hhbGxvd0xvb3NlID0ge1xuICBvYmplY3RzOiAnc2hhbGxvdycsXG4gIHN0cmljdDogZmFsc2Vcbn07XG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBzaXplKSB7XG4gIGlmICghc2l6ZSAmJiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0XG4gICAgfSA9IGNhbnZhcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFzaXplICYmIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLi4uc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdChjYW52YXMpIHtcbiAgLy8gQ2hlY2sgYWdhaW5zdCBtaXN0YWtlbiB1c2Ugb2YgY3JlYXRlUm9vdFxuICBjb25zdCBwcmV2Um9vdCA9IF9yb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLFxuICAvLyBjb250YWluZXJcbiAgQ29uY3VycmVudFJvb3QsXG4gIC8vIHRhZ1xuICBudWxsLFxuICAvLyBoeWRyYXRpb24gY2FsbGJhY2tzXG4gIGZhbHNlLFxuICAvLyBpc1N0cmljdE1vZGVcbiAgbnVsbCxcbiAgLy8gY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZVxuICAnJyxcbiAgLy8gaWRlbnRpZmllclByZWZpeFxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvblVuY2F1Z2h0RXJyb3JcbiAgbG9nUmVjb3ZlcmFibGVFcnJvcixcbiAgLy8gb25DYXVnaHRFcnJvclxuICBsb2dSZWNvdmVyYWJsZUVycm9yLFxuICAvLyBvblJlY292ZXJhYmxlRXJyb3JcbiAgbnVsbCAvLyB0cmFuc2l0aW9uQ2FsbGJhY2tzXG4gICk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSBfcm9vdHMuc2V0KGNhbnZhcywge1xuICAgIGZpYmVyLFxuICAgIHN0b3JlXG4gIH0pO1xuXG4gIC8vIExvY2Fsc1xuICBsZXQgb25DcmVhdGVkO1xuICBsZXQgbGFzdENhbWVyYTtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IHBlbmRpbmcgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiByZXNvbHZlID0gX3Jlc29sdmUpO1xuICAgICAgbGV0IHtcbiAgICAgICAgZ2w6IGdsQ29uZmlnLFxuICAgICAgICBzaXplOiBwcm9wc1NpemUsXG4gICAgICAgIHNjZW5lOiBzY2VuZU9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWRDYWxsYmFjayxcbiAgICAgICAgc2hhZG93cyA9IGZhbHNlLFxuICAgICAgICBsaW5lYXIgPSBmYWxzZSxcbiAgICAgICAgZmxhdCA9IGZhbHNlLFxuICAgICAgICBsZWdhY3kgPSBmYWxzZSxcbiAgICAgICAgb3J0aG9ncmFwaGljID0gZmFsc2UsXG4gICAgICAgIGZyYW1lbG9vcCA9ICdhbHdheXMnLFxuICAgICAgICBkcHIgPSBbMSwgMl0sXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RPcHRpb25zLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYU9wdGlvbnMsXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSA9IHByb3BzO1xuICAgICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2V0IHVwIHJlbmRlcmVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCBnbCA9IHN0YXRlLmdsO1xuICAgICAgaWYgKCFzdGF0ZS5nbCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgIGFscGhhOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsQ29uZmlnID09PSAnZnVuY3Rpb24nID8gYXdhaXQgZ2xDb25maWcoZGVmYXVsdFByb3BzKSA6IGdsQ29uZmlnO1xuICAgICAgICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHtcbiAgICAgICAgICBnbCA9IGN1c3RvbVJlbmRlcmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICAgICAgLi4uZ2xDb25maWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIGdsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbWVyYU9wdGlvbnMuaXNDYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdXNlci1kZWZpbmVkIGZydXN0dW0gaWYgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzMxNjBcbiAgICAgICAgICAgIGlmICghY2FtZXJhLm1hbnVhbCkge1xuICAgICAgICAgICAgICBpZiAoJ2FzcGVjdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnbGVmdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAncmlnaHQnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ2JvdHRvbScgaW4gY2FtZXJhT3B0aW9ucyB8fCAndG9wJyBpbiBjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhLm1hbnVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbHdheXMgbG9vayBhdCBjZW50ZXIgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmICghc3RhdGUuY2FtZXJhICYmICEoY2FtZXJhT3B0aW9ucyAhPSBudWxsICYmIGNhbWVyYU9wdGlvbnMucm90YXRpb24pKSBjYW1lcmEubG9va0F0KDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgY2FtZXJhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSByYXljYXN0ZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC14ci9pc3N1ZXMvMzAwXG4gICAgICAgIHJheWNhc3Rlci5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBzY2VuZSAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnNjZW5lKSB7XG4gICAgICAgIGxldCBzY2VuZTtcbiAgICAgICAgaWYgKHNjZW5lT3B0aW9ucyAhPSBudWxsICYmIHNjZW5lT3B0aW9ucy5pc1NjZW5lKSB7XG4gICAgICAgICAgc2NlbmUgPSBzY2VuZU9wdGlvbnM7XG4gICAgICAgICAgcHJlcGFyZShzY2VuZSwgc3RvcmUsICcnLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBwcmVwYXJlKHNjZW5lLCBzdG9yZSwgJycsIHt9KTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGV2ZW50cyBpbnRlcm5hbGx5XG4gICAgICBpZiAoZXZlbnRzICYmICFzdGF0ZS5ldmVudHMuaGFuZGxlcnMpIHN0YXRlLnNldCh7XG4gICAgICAgIGV2ZW50czogZXZlbnRzKHN0b3JlKVxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBzaXplLCBhbGxvdyBpdCB0byB0YWtlIG9uIGNvbnRhaW5lciBib3VuZHMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBzaXplID0gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgcHJvcHNTaXplKTtcbiAgICAgIGlmICghaXMuZXF1KHNpemUsIHN0YXRlLnNpemUsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgc3RhdGUuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgc2l6ZS50b3AsIHNpemUubGVmdCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBwaXhlbHJhdGlvXG4gICAgICBpZiAoZHByICYmIHN0YXRlLnZpZXdwb3J0LmRwciAhPT0gY2FsY3VsYXRlRHByKGRwcikpIHN0YXRlLnNldERwcihkcHIpO1xuICAgICAgLy8gQ2hlY2sgZnJhbWVsb29wXG4gICAgICBpZiAoc3RhdGUuZnJhbWVsb29wICE9PSBmcmFtZWxvb3ApIHN0YXRlLnNldEZyYW1lbG9vcChmcmFtZWxvb3ApO1xuICAgICAgLy8gQ2hlY2sgcG9pbnRlciBtaXNzZWRcbiAgICAgIGlmICghc3RhdGUub25Qb2ludGVyTWlzc2VkKSBzdGF0ZS5zZXQoe1xuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiAhaXMuZXF1KHBlcmZvcm1hbmNlLCBzdGF0ZS5wZXJmb3JtYW5jZSwgc2hhbGxvd0xvb3NlKSkgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgLi4ucGVyZm9ybWFuY2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFLkJhc2ljU2hhZG93TWFwLFxuICAgICAgICAgICAgcGVyY2VudGFnZTogVEhSRUUuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUUuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRS5WU01TaGFkb3dNYXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gKF90eXBlcyRzaGFkb3dzID0gdHlwZXNbc2hhZG93c10pICE9IG51bGwgPyBfdHlwZXMkc2hhZG93cyA6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFRIUkVFLkNvbG9yTWFuYWdlbWVudC5lbmFibGVkID0gIWxlZ2FjeTtcblxuICAgICAgLy8gU2V0IGNvbG9yIHNwYWNlIGFuZCB0b25lbWFwcGluZyBwcmVmZXJlbmNlc1xuICAgICAgaWYgKCFjb25maWd1cmVkKSB7XG4gICAgICAgIGdsLm91dHB1dENvbG9yU3BhY2UgPSBsaW5lYXIgPyBUSFJFRS5MaW5lYXJTUkdCQ29sb3JTcGFjZSA6IFRIUkVFLlNSR0JDb2xvclNwYWNlO1xuICAgICAgICBnbC50b25lTWFwcGluZyA9IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY29sb3IgbWFuYWdlbWVudCBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmxlZ2FjeSAhPT0gbGVnYWN5KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGVnYWN5XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUubGluZWFyICE9PSBsaW5lYXIpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsaW5lYXJcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5mbGF0ICE9PSBmbGF0KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgZmxhdFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgZ2wgcHJvcHNcbiAgICAgIGlmIChnbENvbmZpZyAmJiAhaXMuZnVuKGdsQ29uZmlnKSAmJiAhaXNSZW5kZXJlcihnbENvbmZpZykgJiYgIWlzLmVxdShnbENvbmZpZywgZ2wsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMoZ2wsIGdsQ29uZmlnKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQgJiYgIXBlbmRpbmcpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICBwZW5kaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL2pzeChQcm92aWRlciwge1xuICAgICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWQsXG4gICAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9LFxuICAgIHVubW91bnQoKSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZnkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzLCBjYWxsYmFjaykge1xuICBjb25zdCByb290ID0gX3Jvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUuc2NlbmUpO1xuICAgICAgICAgICAgX3Jvb3RzLmRlbGV0ZShjYW52YXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhjYW52YXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFBvcnRhbCwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBQb3J0YWwoe1xuICBzdGF0ZSA9IHt9LFxuICBjaGlsZHJlbixcbiAgY29udGFpbmVyXG59KSB7XG4gIC8qKiBUaGlzIGhhcyB0byBiZSBhIGNvbXBvbmVudCBiZWNhdXNlIGl0IHdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdXNlVGhyZWUvdXNlU3RvcmUgb3RoZXJ3aXNlIHNpbmNlXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxuICAgKiAgPENhbnZhcz5cbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIGNvbnN0IGluamVjdCA9IHVzZU11dGFibGVDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUuY2FtZXJhICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLnJvb3RTdGF0ZSxcbiAgICAgIC4uLmluamVjdFN0YXRlLFxuICAgICAgLy8gUG9ydGFscyBoYXZlIHRoZWlyIG93biBzY2VuZSwgd2hpY2ggZm9ybXMgdGhlIHJvb3QsIGEgcmF5Y2FzdGVyIGFuZCBhIHBvaW50ZXJcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICAvLyBUaGVpciBwcmV2aW91cyByb290IGlzIHRoZSBsYXllciBiZWZvcmUgaXRcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIC8vIEV2ZW50cywgc2l6ZSBhbmQgdmlld3BvcnQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGluamVjdCBsYXllclxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmluamVjdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5yb290U3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgLi4udmlld3BvcnRcbiAgICAgIH0sXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBpbmplY3RTdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHVzZVBvcnRhbFN0b3JlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucmVzdCxcbiAgICAgIHNldCxcbiAgICAgIGdldFxuICAgIH0pKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBwcmV2aW91cyByb290LXN0YXRlIGFuZCBjb3B5IGNoYW5nZXMgb3ZlciB0byB0aGUgbWlycm9yZWQgcG9ydGFsLXN0YXRlXG4gICAgY29uc3Qgb25NdXRhdGUgPSBwcmV2ID0+IHN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdC5jdXJyZW50KHByZXYsIHN0YXRlKSk7XG4gICAgb25NdXRhdGUocHJldmlvdXNSb290LmdldFN0YXRlKCkpO1xuICAgIHByZXZpb3VzUm9vdC5zdWJzY3JpYmUob25NdXRhdGUpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtwcmV2aW91c1Jvb3QsIGNvbnRhaW5lcl0pO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBAdHMtaWdub3JlLCByZWNvbmNpbGVyIHR5cGVzIGFyZSBub3QgbWFpbnRhaW5lZFxuICAgIGpzeChGcmFnbWVudCwge1xuICAgICAgY2hpbGRyZW46IHJlY29uY2lsZXIuY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHVzZVBvcnRhbFN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbClcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZvcmNlIFJlYWN0IHRvIGZsdXNoIGFueSB1cGRhdGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc3luY2hyb25vdXNseSBhbmQgaW1tZWRpYXRlbHkuXG4gKiBBbGwgdGhlIHNhbWUgY2F2ZWF0cyBkb2N1bWVudGVkIGZvciByZWFjdC1kb20ncyBgZmx1c2hTeW5jYCBhcHBseSBoZXJlIChzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0LWRvbS9mbHVzaFN5bmMpLlxuICogTmV2ZXJ0aGVsZXNzLCBzb21ldGltZXMgb25lIG5lZWRzIHRvIHJlbmRlciBzeW5jaHJvbm91c2x5LCBmb3IgZXhhbXBsZSB0byBrZWVwIERPTSBhbmQgM0QgY2hhbmdlcyBpbiBsb2NrLXN0ZXAgd2l0aG91dFxuICogaGF2aW5nIHRvIHJldmVydCB0byBhIG5vbi1SZWFjdCBzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIHJldHVybiByZWNvbmNpbGVyLmZsdXNoU3luYyhmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5jb25zdCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xuY29uc3QgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcblxuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuXG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG5cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcblxuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxubGV0IHJ1bm5pbmcgPSBmYWxzZTtcbmxldCB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbmxldCByZXBlYXQ7XG5sZXQgZnJhbWU7XG5sZXQgc3RhdGU7XG5mdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgcnVubmluZyA9IHRydWU7XG4gIHJlcGVhdCA9IDA7XG5cbiAgLy8gUnVuIGVmZmVjdHNcbiAgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuXG4gIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgdXNlRnJhbWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgZm9yIChjb25zdCByb290IG9mIF9yb290cy52YWx1ZXMoKSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICByZXBlYXQgKz0gdXBkYXRlKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZhbGlkYXRlcyB0aGUgdmlldywgcmVxdWVzdGluZyBhIGZyYW1lIHRvIGJlIHJlbmRlcmVkLiBXaWxsIGdsb2JhbGx5IGludmFsaWRhdGUgdW5sZXNzIHBhc3NlZCBhIHJvb3QncyBzdGF0ZS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNpbnZhbGlkYXRlXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gIGlmICghc3RhdGUpIHJldHVybiBfcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpLCBmcmFtZXMpKTtcbiAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgaWYgKGZyYW1lcyA+IDEpIHtcbiAgICAvLyBsZWdhY3kgc3VwcG9ydCBmb3IgcGVvcGxlIHVzaW5nIGZyYW1lcyBwYXJhbWV0ZXJzXG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodXNlRnJhbWVJblByb2dyZXNzKSB7XG4gICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiBhIHVzZUZyYW1lLCBpdCBtZWFucyB0aGUgdXNlciB3YW50cyBhbiBhZGRpdGlvbmFsIGZyYW1lXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3RoZSB1c2VyIG5lZWQgYSBuZXcgZnJhbWUsIG5vIG5lZWQgdG8gaW5jcmVtZW50IGZ1cnRoZXIgdGhhbiAxXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSByZW5kZXItbG9vcCBpc24ndCBhY3RpdmUsIHN0YXJ0IGl0XG4gIGlmICghcnVubmluZykge1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkdmFuY2VzIHRoZSBmcmFtZWxvb3AgYW5kIHJ1bnMgcmVuZGVyIGVmZmVjdHMsIHVzZWZ1bCBmb3Igd2hlbiBtYW51YWxseSByZW5kZXJpbmcgdmlhIGBmcmFtZWxvb3A9XCJuZXZlclwiYC5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZHZhbmNlXG4gKi9cbmZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gIGlmICghc3RhdGUpIGZvciAoY29uc3Qgcm9vdCBvZiBfcm9vdHMudmFsdWVzKCkpIHVwZGF0ZSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSB1cGRhdGUodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpO1xuICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG59XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgaWYgKGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICAgIHBhc3NpdmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICBpZiAoZXZlbnRzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV2ZW50cy5oYW5kbGVycykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHMuaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZVN0b3JlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZVRocmVlIGFzIEMsIHVzZUZyYW1lIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlR3JhcGggYXMgRiwgdXNlTG9hZGVyIGFzIEcsIF9yb290cyBhcyBfLCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgYSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBiLCBjcmVhdGVSb290IGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNyZWF0ZVBvaW50ZXJFdmVudHMgYXMgZiwgY3JlYXRlRXZlbnRzIGFzIGcsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBoLCBpc1JlZiBhcyBpLCBhZGRFZmZlY3QgYXMgaiwgYWRkQWZ0ZXJFZmZlY3QgYXMgaywgYWRkVGFpbCBhcyBsLCBpbnZhbGlkYXRlIGFzIG0sIGFkdmFuY2UgYXMgbiwgY3JlYXRlUG9ydGFsIGFzIG8sIGZsdXNoU3luYyBhcyBwLCBjb250ZXh0IGFzIHEsIHJlY29uY2lsZXIgYXMgciwgYXBwbHlQcm9wcyBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZUJyaWRnZSBhcyB1LCBnZXRSb290U3RhdGUgYXMgdiwgZGlzcG9zZSBhcyB3LCBhY3QgYXMgeCwgYnVpbGRHcmFwaCBhcyB5LCB1c2VJbnN0YW5jZUhhbmRsZSBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   act: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   advance: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   events: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   extend: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)\n/* harmony export */ });\n/* harmony import */ var _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-cf57b220.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction CanvasImpl({\n  ref,\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events = _events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.f,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n  const Bridge = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)();\n  const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, () => canvasRef.current);\n  const handlePointerMissed = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(onPointerMissed);\n  const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n  const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(canvas);\n      async function run() {\n        await root.current.configure({\n          gl,\n          scene,\n          events,\n          shadows,\n          linear,\n          flat,\n          legacy,\n          orthographic,\n          frameloop,\n          dpr,\n          performance,\n          raycaster,\n          camera,\n          size: containerRect,\n          // Pass mutable reference to onPointerMissed so it's free to update\n          onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n          onCreated: state => {\n            // Connect to event source\n            state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n            // Set up compute function\n            if (eventPrefix) {\n              state.setEvents({\n                compute: (event, state) => {\n                  const x = event[eventPrefix + 'X'];\n                  const y = event[eventPrefix + 'Y'];\n                  state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                  state.raycaster.setFromCamera(state.pointer, state.camera);\n                }\n              });\n            }\n            // Call onCreated callback\n            onCreated == null ? void 0 : onCreated(state);\n          }\n        });\n        root.current.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n            set: setError,\n            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n              fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                set: setBlock\n              }),\n              children: children != null ? children : null\n            })\n          })\n        }));\n      }\n      run();\n    }\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => (0,_events_cf57b220_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    },\n    ...props,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100%',\n        height: '100%'\n      },\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        style: {\n          display: 'block'\n        },\n        children: fallback\n      })\n    })\n  });\n}\n\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */\nfunction Canvas(props) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n      ...props\n    })\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9QO0FBQ2tSO0FBQ3ZlO0FBQ0E7QUFDWTtBQUNGO0FBQ0Q7QUFDSjtBQUNQO0FBQ0g7QUFDUDtBQUNJOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMENBQWEsT0FBTywwREFBTSxDQUFDLGtDQUFLO0FBQ2xDLGlCQUFpQiwwREFBUztBQUMxQix3Q0FBd0MsNkRBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLHlDQUFZO0FBQ2hDLGlCQUFpQix5Q0FBWTtBQUM3QixFQUFFLHNEQUF5QjtBQUMzQiw4QkFBOEIsMERBQWtCO0FBQ2hELDRCQUE0QiwyQ0FBYztBQUMxQyw0QkFBNEIsMkNBQWM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBWTtBQUMzQixFQUFFLDBEQUF5QjtBQUMzQjtBQUNBO0FBQ0Esd0NBQXdDLDBEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsMERBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQyxzREFBRztBQUM3QyxpQ0FBaUMsc0RBQUcsQ0FBQyxzREFBYTtBQUNsRDtBQUNBLG1DQUFtQyxzREFBRyxDQUFDLDJDQUFjO0FBQ3JELHFDQUFxQyxzREFBRyxDQUFDLHNEQUFLO0FBQzlDO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQSw2QkFBNkIsMERBQXNCO0FBQ25ELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHNEQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQUcsQ0FBQyxtREFBYTtBQUN2QywyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVrQiIsInNvdXJjZXMiOlsiRDpcXE5nb2RzXFxyZXBvZ2l0aHViXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXGRpc3RcXHJlYWN0LXRocmVlLWZpYmVyLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlIGFzIGV4dGVuZCwgdSBhcyB1c2VCcmlkZ2UsIGEgYXMgdXNlTXV0YWJsZUNhbGxiYWNrLCBiIGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIGMgYXMgY3JlYXRlUm9vdCwgaSBhcyBpc1JlZiwgRSBhcyBFcnJvckJvdW5kYXJ5LCBCIGFzIEJsb2NrLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIGYgYXMgY3JlYXRlUG9pbnRlckV2ZW50cyB9IGZyb20gJy4vZXZlbnRzLWNmNTdiMjIwLmVzbS5qcyc7XG5leHBvcnQgeyB0IGFzIFJlYWN0VGhyZWVGaWJlciwgXyBhcyBfcm9vdHMsIHggYXMgYWN0LCBrIGFzIGFkZEFmdGVyRWZmZWN0LCBqIGFzIGFkZEVmZmVjdCwgbCBhcyBhZGRUYWlsLCBuIGFzIGFkdmFuY2UsIHMgYXMgYXBwbHlQcm9wcywgeSBhcyBidWlsZEdyYXBoLCBxIGFzIGNvbnRleHQsIGcgYXMgY3JlYXRlRXZlbnRzLCBvIGFzIGNyZWF0ZVBvcnRhbCwgYyBhcyBjcmVhdGVSb290LCB3IGFzIGRpc3Bvc2UsIGYgYXMgZXZlbnRzLCBlIGFzIGV4dGVuZCwgaCBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHAgYXMgZmx1c2hTeW5jLCB2IGFzIGdldFJvb3RTdGF0ZSwgbSBhcyBpbnZhbGlkYXRlLCByIGFzIHJlY29uY2lsZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgRCBhcyB1c2VGcmFtZSwgRiBhcyB1c2VHcmFwaCwgeiBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgRyBhcyB1c2VMb2FkZXIsIEEgYXMgdXNlU3RvcmUsIEMgYXMgdXNlVGhyZWUgfSBmcm9tICcuL2V2ZW50cy1jZjU3YjIyMC5lc20uanMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHVzZU1lYXN1cmUgZnJvbSAncmVhY3QtdXNlLW1lYXN1cmUnO1xuaW1wb3J0IHsgRmliZXJQcm92aWRlciB9IGZyb20gJ2l0cy1maW5lJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgJ3NjaGVkdWxlcic7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuXG5mdW5jdGlvbiBDYW52YXNJbXBsKHtcbiAgcmVmLFxuICBjaGlsZHJlbixcbiAgZmFsbGJhY2ssXG4gIHJlc2l6ZSxcbiAgc3R5bGUsXG4gIGdsLFxuICBldmVudHMgPSBjcmVhdGVQb2ludGVyRXZlbnRzLFxuICBldmVudFNvdXJjZSxcbiAgZXZlbnRQcmVmaXgsXG4gIHNoYWRvd3MsXG4gIGxpbmVhcixcbiAgZmxhdCxcbiAgbGVnYWN5LFxuICBvcnRob2dyYXBoaWMsXG4gIGZyYW1lbG9vcCxcbiAgZHByLFxuICBwZXJmb3JtYW5jZSxcbiAgcmF5Y2FzdGVyLFxuICBjYW1lcmEsXG4gIHNjZW5lLFxuICBvblBvaW50ZXJNaXNzZWQsXG4gIG9uQ3JlYXRlZCxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgLy8gQ3JlYXRlIGEga25vd24gY2F0YWxvZ3VlIG9mIFRocmVlanMtbmF0aXZlIGVsZW1lbnRzXG4gIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBlbnRpcmUgVEhSRUUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHVzZXJzIGNhbiBleHRlbmRcbiAgLy8gdGhlaXIgb3duIGVsZW1lbnRzIGJ5IHVzaW5nIHRoZSBjcmVhdGVSb290IEFQSSBpbnN0ZWFkXG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKFRIUkVFKSwgW10pO1xuICBjb25zdCBCcmlkZ2UgPSB1c2VCcmlkZ2UoKTtcbiAgY29uc3QgW2NvbnRhaW5lclJlZiwgY29udGFpbmVyUmVjdF0gPSB1c2VNZWFzdXJlKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkaXZSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSB1c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFN1c3BlbmQgdGhpcyBjb21wb25lbnQgaWYgYmxvY2sgaXMgYSBwcm9taXNlICgybmQgcnVuKVxuICBpZiAoYmxvY2spIHRocm93IGJsb2NrO1xuICAvLyBUaHJvdyBleGNlcHRpb24gb3V0d2FyZHMgaWYgYW55dGhpbmcgd2l0aGluIGNhbnZhcyB0aHJvd3NcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICBhc3luYyBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgIGF3YWl0IHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICAgIGdsLFxuICAgICAgICAgIHNjZW5lLFxuICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICBzaGFkb3dzLFxuICAgICAgICAgIGxpbmVhcixcbiAgICAgICAgICBmbGF0LFxuICAgICAgICAgIGxlZ2FjeSxcbiAgICAgICAgICBvcnRob2dyYXBoaWMsXG4gICAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICAgIGRwcixcbiAgICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIHNpemU6IGNvbnRhaW5lclJlY3QsXG4gICAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICAgIG9uUG9pbnRlck1pc3NlZDogKC4uLmFyZ3MpID0+IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50KC4uLmFyZ3MpLFxuICAgICAgICAgIG9uQ3JlYXRlZDogc3RhdGUgPT4ge1xuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChldmVudFNvdXJjZSA/IGlzUmVmKGV2ZW50U291cmNlKSA/IGV2ZW50U291cmNlLmN1cnJlbnQgOiBldmVudFNvdXJjZSA6IGRpdlJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIC8vIFNldCB1cCBjb21wdXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc2V0RXZlbnRzKHtcbiAgICAgICAgICAgICAgICBjb21wdXRlOiAoZXZlbnQsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1knXTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KHggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oeSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgb25DcmVhdGVkIGNhbGxiYWNrXG4gICAgICAgICAgICBvbkNyZWF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcm9vdC5jdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL2pzeChCcmlkZ2UsIHtcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICBzZXQ6IHNldEVycm9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goQmxvY2ssIHtcbiAgICAgICAgICAgICAgICBzZXQ6IHNldEJsb2NrXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gIT0gbnVsbCA/IGNoaWxkcmVuIDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBydW4oKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICAvLyBXaGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm90IHRoaXMgZGl2LCB3ZSBuZWVkIHRvIHNldCBwb2ludGVyLWV2ZW50cyB0byBub25lXG4gIC8vIE9yIGVsc2UgdGhlIGNhbnZhcyB3aWxsIGJsb2NrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBldmVudCBzb3VyY2VcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGV2ZW50U291cmNlID8gJ25vbmUnIDogJ2F1dG8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJjYW52YXNcIiwge1xuICAgICAgICByZWY6IGNhbnZhc1JlZixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBmYWxsYmFja1xuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn1cblxuLyoqXG4gKiBBIERPTSBjYW52YXMgd2hpY2ggYWNjZXB0cyB0aHJlZWpzIGVsZW1lbnRzIGFzIGNoaWxkcmVuLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvY2FudmFzXG4gKi9cbmZ1bmN0aW9uIENhbnZhcyhwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGaWJlclByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ2FudmFzSW1wbCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQ2FudmFzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = exports.unstable_now();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (\n                  currentTask = peek(taskQueue);\n                  null !== currentTask &&\n                  !(\n                    currentTask.expirationTime > currentTime &&\n                    shouldYieldToHost()\n                  );\n\n                ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = exports.unstable_now();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), requestHostCallback();\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function shouldYieldToHost() {\n      return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n    }\n    function requestHostCallback() {\n      isMessageLoopRunning ||\n        ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    exports.unstable_now = void 0;\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      frameInterval = 5,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_continueExecution = function () {\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback());\n    };\n    exports.unstable_forceFrameRate = function (fps) {\n      0 > fps || 125 < fps\n        ? console.error(\n            \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n          )\n        : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n    };\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_getFirstCallbackNode = function () {\n      return peek(taskQueue);\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_pauseExecution = function () {};\n    exports.unstable_requestPaint = function () {};\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = exports.unstable_now();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), requestHostCallback()));\n      return priorityLevel;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakMsSUFBSSxrQ0FBa0M7QUFDdEMsSUFBSSw0QkFBNEI7QUFDaEMsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSSxxQ0FBcUM7QUFDekMsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQkFBK0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUM7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDZCQUE2QjtBQUNqQyxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxJQUFJLDZCQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxOZ29kc1xccmVwb2dpdGh1Ylxcbm9kZV9tb2R1bGVzXFxAcmVhY3QtdGhyZWVcXGZpYmVyXFxub2RlX21vZHVsZXNcXHNjaGVkdWxlclxcY2pzXFxzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpIHtcbiAgICAgIGlmIChpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdmFyIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMTtcbiAgICAgICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgJiZcbiAgICAgICAgICAgICAgKChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITEpLFxuICAgICAgICAgICAgICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKSxcbiAgICAgICAgICAgICAgKHRhc2tUaW1lb3V0SUQgPSAtMSkpO1xuICAgICAgICAgICAgaXNQZXJmb3JtaW5nV29yayA9ICEwO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRUYXNrICYmXG4gICAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFlpZWxkVG9Ib3N0KClcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkgJiYgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50VGFzaykgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIChjdXJyZW50VGFzayA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgICAgICAgKGlzUGVyZm9ybWluZ1dvcmsgPSAhMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNNb3JlV29yayA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaGFzTW9yZVdvcmtcbiAgICAgICAgICAgID8gc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKVxuICAgICAgICAgICAgOiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gICAgICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgICAgIGhlYXAucHVzaChub2RlKTtcbiAgICAgIGE6IGZvciAoOyAwIDwgaW5kZXg7ICkge1xuICAgICAgICB2YXIgcGFyZW50SW5kZXggPSAoaW5kZXggLSAxKSA+Pj4gMSxcbiAgICAgICAgICBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcbiAgICAgICAgaWYgKDAgPCBjb21wYXJlKHBhcmVudCwgbm9kZSkpXG4gICAgICAgICAgKGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZSksXG4gICAgICAgICAgICAoaGVhcFtpbmRleF0gPSBwYXJlbnQpLFxuICAgICAgICAgICAgKGluZGV4ID0gcGFyZW50SW5kZXgpO1xuICAgICAgICBlbHNlIGJyZWFrIGE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICAgICAgcmV0dXJuIDAgPT09IGhlYXAubGVuZ3RoID8gbnVsbCA6IGhlYXBbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gICAgICBpZiAoMCA9PT0gaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGZpcnN0ID0gaGVhcFswXSxcbiAgICAgICAgbGFzdCA9IGhlYXAucG9wKCk7XG4gICAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgICAgIGE6IGZvciAoXG4gICAgICAgICAgdmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gaGVhcC5sZW5ndGgsIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICAgICAgaW5kZXggPCBoYWxmTGVuZ3RoO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSAyICogKGluZGV4ICsgMSkgLSAxLFxuICAgICAgICAgICAgbGVmdCA9IGhlYXBbbGVmdEluZGV4XSxcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxLFxuICAgICAgICAgICAgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdO1xuICAgICAgICAgIGlmICgwID4gY29tcGFyZShsZWZ0LCBsYXN0KSlcbiAgICAgICAgICAgIHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgMCA+IGNvbXBhcmUocmlnaHQsIGxlZnQpXG4gICAgICAgICAgICAgID8gKChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgICAgICAoaGVhcFtyaWdodEluZGV4XSA9IGxhc3QpLFxuICAgICAgICAgICAgICAgIChpbmRleCA9IHJpZ2h0SW5kZXgpKVxuICAgICAgICAgICAgICA6ICgoaGVhcFtpbmRleF0gPSBsZWZ0KSxcbiAgICAgICAgICAgICAgICAoaGVhcFtsZWZ0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgICAgKGluZGV4ID0gbGVmdEluZGV4KSk7XG4gICAgICAgICAgZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGFzdCkpXG4gICAgICAgICAgICAoaGVhcFtpbmRleF0gPSByaWdodCksXG4gICAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAgIChpbmRleCA9IHJpZ2h0SW5kZXgpO1xuICAgICAgICAgIGVsc2UgYnJlYWsgYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgICAgIHJldHVybiAwICE9PSBkaWZmID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gICAgICBmb3IgKHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7IG51bGwgIT09IHRpbWVyOyApIHtcbiAgICAgICAgaWYgKG51bGwgPT09IHRpbWVyLmNhbGxiYWNrKSBwb3AodGltZXJRdWV1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSlcbiAgICAgICAgICBwb3AodGltZXJRdWV1ZSksXG4gICAgICAgICAgICAodGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWUpLFxuICAgICAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITE7XG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpXG4gICAgICAgIGlmIChudWxsICE9PSBwZWVrKHRhc2tRdWV1ZSkpXG4gICAgICAgICAgKGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITApLCByZXF1ZXN0SG9zdENhbGxiYWNrKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoXG4gICAgICAgICAgICAgIGhhbmRsZVRpbWVvdXQsXG4gICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZSA8IGZyYW1lSW50ZXJ2YWwgPyAhMSA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKCkge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgfHxcbiAgICAgICAgKChpc01lc3NhZ2VMb29wUnVubmluZyA9ICEwKSwgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IHZvaWQgMDtcbiAgICBpZiAoXG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2UgJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vd1xuICAgICkge1xuICAgICAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlLFxuICAgICAgICBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcbiAgICAgIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgdGFza1F1ZXVlID0gW10sXG4gICAgICB0aW1lclF1ZXVlID0gW10sXG4gICAgICB0YXNrSWRDb3VudGVyID0gMSxcbiAgICAgIGN1cnJlbnRUYXNrID0gbnVsbCxcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gMyxcbiAgICAgIGlzUGVyZm9ybWluZ1dvcmsgPSAhMSxcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITEsXG4gICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITEsXG4gICAgICBsb2NhbFNldFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzZXRUaW1lb3V0ID8gc2V0VGltZW91dCA6IG51bGwsXG4gICAgICBsb2NhbENsZWFyVGltZW91dCA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNsZWFyVGltZW91dCA/IGNsZWFyVGltZW91dCA6IG51bGwsXG4gICAgICBsb2NhbFNldEltbWVkaWF0ZSA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBzZXRJbW1lZGlhdGUgPyBzZXRJbW1lZGlhdGUgOiBudWxsLFxuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSxcbiAgICAgIHRhc2tUaW1lb3V0SUQgPSAtMSxcbiAgICAgIGZyYW1lSW50ZXJ2YWwgPSA1LFxuICAgICAgc3RhcnRUaW1lID0gLTE7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlKVxuICAgICAgdmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICAgICAgfTtcbiAgICBlbHNlIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gICAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gNTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gNDtcbiAgICBleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gMztcbiAgICBleHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IG51bGw7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG4gICAgZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCB8fFxuICAgICAgICBpc1BlcmZvcm1pbmdXb3JrIHx8XG4gICAgICAgICgoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAgICAgMCA+IGZwcyB8fCAxMjUgPCBmcHNcbiAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgICAgIClcbiAgICAgICAgOiAoZnJhbWVJbnRlcnZhbCA9IDAgPCBmcHMgPyBNYXRoLmZsb29yKDFlMyAvIGZwcykgOiA1KTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudW5zdGFibGVfbmV4dCA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uID0gZnVuY3Rpb24gKCkge307XG4gICAgZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcmlvcml0eUxldmVsID0gMztcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrID0gZnVuY3Rpb24gKFxuICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnNcbiAgICAgICAgPyAoKG9wdGlvbnMgPSBvcHRpb25zLmRlbGF5KSxcbiAgICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2Ygb3B0aW9ucyAmJiAwIDwgb3B0aW9uc1xuICAgICAgICAgICAgICA/IGN1cnJlbnRUaW1lICsgb3B0aW9uc1xuICAgICAgICAgICAgICA6IGN1cnJlbnRUaW1lKSlcbiAgICAgICAgOiAob3B0aW9ucyA9IGN1cnJlbnRUaW1lKTtcbiAgICAgIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRpbWVvdXQgPSAyNTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aW1lb3V0ID0gMTA3Mzc0MTgyMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRpbWVvdXQgPSAxZTQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGltZW91dCA9IDVlMztcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBvcHRpb25zICsgdGltZW91dDtcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSB7XG4gICAgICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgc3RhcnRUaW1lOiBvcHRpb25zLFxuICAgICAgICBleHBpcmF0aW9uVGltZTogdGltZW91dCxcbiAgICAgICAgc29ydEluZGV4OiAtMVxuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPiBjdXJyZW50VGltZVxuICAgICAgICA/ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSBvcHRpb25zKSxcbiAgICAgICAgICBwdXNoKHRpbWVyUXVldWUsIHByaW9yaXR5TGV2ZWwpLFxuICAgICAgICAgIG51bGwgPT09IHBlZWsodGFza1F1ZXVlKSAmJlxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCA9PT0gcGVlayh0aW1lclF1ZXVlKSAmJlxuICAgICAgICAgICAgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWRcbiAgICAgICAgICAgICAgPyAobG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksICh0YXNrVGltZW91dElEID0gLTEpKVxuICAgICAgICAgICAgICA6IChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITApLFxuICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIG9wdGlvbnMgLSBjdXJyZW50VGltZSkpKVxuICAgICAgICA6ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSB0aW1lb3V0KSxcbiAgICAgICAgICBwdXNoKHRhc2tRdWV1ZSwgcHJpb3JpdHlMZXZlbCksXG4gICAgICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICAgICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgICAgICgoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKSkpO1xuICAgICAgcmV0dXJuIHByaW9yaXR5TGV2ZWw7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG4gICAgZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHlLQUEwRDtBQUM1RCIsInNvdXJjZXMiOlsiRDpcXE5nb2RzXFxyZXBvZ2l0aHViXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxcZmliZXJcXG5vZGVfbW9kdWxlc1xcc2NoZWR1bGVyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyCollider: () => (/* binding */ AnyCollider),\n/* harmony export */   BallCollider: () => (/* binding */ BallCollider),\n/* harmony export */   CapsuleCollider: () => (/* binding */ CapsuleCollider),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   ConeCollider: () => (/* binding */ ConeCollider),\n/* harmony export */   ConvexHullCollider: () => (/* binding */ ConvexHullCollider),\n/* harmony export */   CuboidCollider: () => (/* binding */ CuboidCollider),\n/* harmony export */   CylinderCollider: () => (/* binding */ CylinderCollider),\n/* harmony export */   HeightfieldCollider: () => (/* binding */ HeightfieldCollider),\n/* harmony export */   InstancedRigidBodies: () => (/* binding */ InstancedRigidBodies),\n/* harmony export */   MeshCollider: () => (/* binding */ MeshCollider),\n/* harmony export */   Physics: () => (/* binding */ Physics),\n/* harmony export */   RapierCollider: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   RapierRigidBody: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RoundConeCollider: () => (/* binding */ RoundConeCollider),\n/* harmony export */   RoundCuboidCollider: () => (/* binding */ RoundCuboidCollider),\n/* harmony export */   RoundCylinderCollider: () => (/* binding */ RoundCylinderCollider),\n/* harmony export */   TrimeshCollider: () => (/* binding */ TrimeshCollider),\n/* harmony export */   euler: () => (/* binding */ euler),\n/* harmony export */   interactionGroups: () => (/* binding */ interactionGroups),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   useAfterPhysicsStep: () => (/* binding */ useAfterPhysicsStep),\n/* harmony export */   useBeforePhysicsStep: () => (/* binding */ useBeforePhysicsStep),\n/* harmony export */   useFixedJoint: () => (/* binding */ useFixedJoint),\n/* harmony export */   useImpulseJoint: () => (/* binding */ useImpulseJoint),\n/* harmony export */   usePrismaticJoint: () => (/* binding */ usePrismaticJoint),\n/* harmony export */   useRapier: () => (/* binding */ useRapier),\n/* harmony export */   useRevoluteJoint: () => (/* binding */ useRevoluteJoint),\n/* harmony export */   useRopeJoint: () => (/* binding */ useRopeJoint),\n/* harmony export */   useSphericalJoint: () => (/* binding */ useSphericalJoint),\n/* harmony export */   useSpringJoint: () => (/* binding */ useSpringJoint),\n/* harmony export */   vec3: () => (/* binding */ vec3)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-cf57b220.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n\n\n\n\n\n\n\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nconst _vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst _matrix4 = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst _rotation = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nconst _scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v[0], v[1], v[2], v[3]);\n  } else {\n    return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Vector3 || v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(callback);\n  const raf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  const lastFrame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cb.current = callback;\n  }, [callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : (0,three_stdlib__WEBPACK_IMPORTED_MODULE_4__.mergeVertices)(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS | _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n    geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"group\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\"));\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = (0,suspend_react__WEBPACK_IMPORTED_MODULE_5__.suspend)(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  const getInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new three__WEBPACK_IMPORTED_MODULE_2__.Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useRigidBodyContext = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const instanceWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, colliderNodes.map((node, index) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9kaXN0L3JlYWN0LXRocmVlLXJhcGllci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUN2QjtBQUNyRTtBQUNvRTtBQUNRO0FBQzVGO0FBQ0s7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUFVO0FBQ2xDLElBQUksd0NBQUs7QUFDVCxxQkFBcUIsMENBQU87QUFDNUIsSUFBSSwyQ0FBUTtBQUNaLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDZDQUFVO0FBQ2hDLG1CQUFtQiwwQ0FBTzs7QUFFMUI7QUFDQTtBQUNBLGFBQWEsMENBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSixlQUFlLDhEQUFTO0FBQ3hCLElBQUk7QUFDSjtBQUNBLGVBQWUsOERBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFZO0FBQzNCLElBQUk7QUFDSixlQUFlLGlFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5ZSIsInNvdXJjZXMiOlsiRDpcXE5nb2RzXFxyZXBvZ2l0aHViXFxub2RlX21vZHVsZXNcXEByZWFjdC10aHJlZVxccmFwaWVyXFxkaXN0XFxyZWFjdC10aHJlZS1yYXBpZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgYXMgVmVjdG9yMyQxLCBRdWF0ZXJuaW9uIGFzIFF1YXRlcm5pb24kMSwgQWN0aXZlRXZlbnRzLCBDb2xsaWRlckRlc2MsIEV2ZW50UXVldWUsIFJpZ2lkQm9keURlc2MgfSBmcm9tICdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0JztcbmV4cG9ydCB7IENvZWZmaWNpZW50Q29tYmluZVJ1bGUsIENvbGxpZGVyIGFzIFJhcGllckNvbGxpZGVyLCBSaWdpZEJvZHkgYXMgUmFwaWVyUmlnaWRCb2R5IH0gZnJvbSAnQGRpbWZvcmdlL3JhcGllcjNkLWNvbXBhdCc7XG5pbXBvcnQgeyB1c2VGcmFtZSwgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCBtZW1vLCB1c2VNZW1vLCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiwgRXVsZXIsIFZlY3RvcjMsIE9iamVjdDNELCBNYXRyaXg0LCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBNYXRoVXRpbHMsIER5bmFtaWNEcmF3VXNhZ2UgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBzdXNwZW5kIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgeyBtZXJnZVZlcnRpY2VzIH0gZnJvbSAndGhyZWUtc3RkbGliJztcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5jb25zdCBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5uZXcgRXVsZXIoKTtcbmNvbnN0IF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcbm5ldyBPYmplY3QzRCgpO1xuY29uc3QgX21hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3Bvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9yb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCB2ZWN0b3JBcnJheVRvVmVjdG9yMyA9IGFyciA9PiB7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IGFycjtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xufTtcbmNvbnN0IHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24gPSAoe1xuICB4LFxuICB5LFxuICB6LFxuICB3XG59KSA9PiBfcXVhdGVybmlvbi5zZXQoeCwgeSwgeiwgdyk7XG5jb25zdCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IgPSB2ID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMkMSh2WzBdLCB2WzFdLCB2WzJdKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyQxKHYsIHYsIHYpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRocmVlVmVjdG9yMyA9IHY7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzJDEodGhyZWVWZWN0b3IzLngsIHRocmVlVmVjdG9yMy55LCB0aHJlZVZlY3RvcjMueik7XG4gIH1cbn07XG5jb25zdCBxdWF0ZXJuaW9uVG9SYXBpZXJRdWF0ZXJuaW9uID0gdiA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uJDEodlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uJDEodi54LCB2LnksIHYueiwgdi53KTtcbiAgfVxufTtcbmNvbnN0IHJpZ2lkQm9keVR5cGVNYXAgPSB7XG4gIGZpeGVkOiAxLFxuICBkeW5hbWljOiAwLFxuICBraW5lbWF0aWNQb3NpdGlvbjogMixcbiAga2luZW1hdGljVmVsb2NpdHk6IDNcbn07XG5jb25zdCByaWdpZEJvZHlUeXBlRnJvbVN0cmluZyA9IHR5cGUgPT4gcmlnaWRCb2R5VHlwZU1hcFt0eXBlXTtcbmNvbnN0IHNjYWxlVmVydGljZXMgPSAodmVydGljZXMsIHNjYWxlKSA9PiB7XG4gIGNvbnN0IHNjYWxlZFZlcnRzID0gQXJyYXkuZnJvbSh2ZXJ0aWNlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgc2NhbGVkVmVydHNbaSAqIDNdICo9IHNjYWxlLng7XG4gICAgc2NhbGVkVmVydHNbaSAqIDMgKyAxXSAqPSBzY2FsZS55O1xuICAgIHNjYWxlZFZlcnRzW2kgKiAzICsgMl0gKj0gc2NhbGUuejtcbiAgfVxuICByZXR1cm4gc2NhbGVkVmVydHM7XG59O1xuY29uc3QgdmVjdG9yVG9UdXBsZSA9IHYgPT4ge1xuICBpZiAoIXYpIHJldHVybiBbMF07XG4gIGlmICh2IGluc3RhbmNlb2YgUXVhdGVybmlvbikge1xuICAgIHJldHVybiBbdi54LCB2LnksIHYueiwgdi53XTtcbiAgfVxuICBpZiAodiBpbnN0YW5jZW9mIFZlY3RvcjMgfHwgdiBpbnN0YW5jZW9mIEV1bGVyKSB7XG4gICAgcmV0dXJuIFt2LngsIHYueSwgdi56XTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIHJldHVybiBbdl07XG59O1xuZnVuY3Rpb24gdXNlQ29uc3QoaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICBpZiAocmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZi5jdXJyZW50ID0ge1xuICAgICAgdmFsdWU6IHR5cGVvZiBpbml0aWFsVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGluaXRpYWxWYWx1ZSgpIDogaW5pdGlhbFZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQudmFsdWU7XG59XG5cbmNvbnN0IHVzZVJhZiA9IGNhbGxiYWNrID0+IHtcbiAgY29uc3QgY2IgPSB1c2VSZWYoY2FsbGJhY2spO1xuICBjb25zdCByYWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGxhc3RGcmFtZSA9IHVzZVJlZigwKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0sIFtjYWxsYmFja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gbm93IC0gbGFzdEZyYW1lLmN1cnJlbnQ7XG4gICAgICByYWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgIGNiLmN1cnJlbnQoZGVsdGEgLyAxMDAwKTtcbiAgICAgIGxhc3RGcmFtZS5jdXJyZW50ID0gbm93O1xuICAgIH07XG4gICAgcmFmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZi5jdXJyZW50KTtcbiAgfSwgW10pO1xufTtcblxuY29uc3QgVXNlRnJhbWVTdGVwcGVyID0gKHtcbiAgb25TdGVwLFxuICB1cGRhdGVQcmlvcml0eVxufSkgPT4ge1xuICB1c2VGcmFtZSgoXywgZHQpID0+IHtcbiAgICBvblN0ZXAoZHQpO1xuICB9LCB1cGRhdGVQcmlvcml0eSk7XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IFJhZlN0ZXBwZXIgPSAoe1xuICBvblN0ZXBcbn0pID0+IHtcbiAgdXNlUmFmKGR0ID0+IHtcbiAgICBvblN0ZXAoZHQpO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgRnJhbWVTdGVwcGVyID0gKHtcbiAgb25TdGVwLFxuICB0eXBlLFxuICB1cGRhdGVQcmlvcml0eVxufSkgPT4ge1xuICByZXR1cm4gdHlwZSA9PT0gXCJpbmRlcGVuZGVudFwiID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmFmU3RlcHBlciwge1xuICAgIG9uU3RlcDogb25TdGVwXG4gIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVXNlRnJhbWVTdGVwcGVyLCB7XG4gICAgb25TdGVwOiBvblN0ZXAsXG4gICAgdXBkYXRlUHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5XG4gIH0pO1xufTtcbnZhciBGcmFtZVN0ZXBwZXIkMSA9IC8qI19fUFVSRV9fKi9tZW1vKEZyYW1lU3RlcHBlcik7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkge1xuICBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307XG4gIHZhciBvLFxuICAgIHIsXG4gICAgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIC0xID09PSB0LmluZGV4T2YobykgJiYge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMiA9IFtcIm1hc3NcIiwgXCJsaW5lYXJEYW1waW5nXCIsIFwiYW5ndWxhckRhbXBpbmdcIiwgXCJ0eXBlXCIsIFwib25Db2xsaXNpb25FbnRlclwiLCBcIm9uQ29sbGlzaW9uRXhpdFwiLCBcIm9uSW50ZXJzZWN0aW9uRW50ZXJcIiwgXCJvbkludGVyc2VjdGlvbkV4aXRcIiwgXCJvbkNvbnRhY3RGb3JjZVwiLCBcImNoaWxkcmVuXCIsIFwiY2FuU2xlZXBcIiwgXCJjY2RcIiwgXCJncmF2aXR5U2NhbGVcIiwgXCJzb2Z0Q2NkUHJlZGljdGlvblwiLCBcInJlZlwiXTtcbmNvbnN0IHNjYWxlQ29sbGlkZXJBcmdzID0gKHNoYXBlLCBhcmdzLCBzY2FsZSkgPT4ge1xuICBjb25zdCBuZXdBcmdzID0gYXJncy5zbGljZSgpO1xuXG4gIC8vIEhlaWdodGZpZWxkIHVzZXMgYSB2ZWN0b3JcbiAgaWYgKHNoYXBlID09PSBcImhlaWdodGZpZWxkXCIpIHtcbiAgICBjb25zdCBzID0gbmV3QXJnc1szXTtcbiAgICBzLnggKj0gc2NhbGUueDtcbiAgICBzLnggKj0gc2NhbGUueTtcbiAgICBzLnggKj0gc2NhbGUuejtcbiAgICByZXR1cm4gbmV3QXJncztcbiAgfVxuXG4gIC8vIFRyaW1lc2ggYW5kIGNvbnZleCBzY2FsZSB0aGUgdmVydGljZXNcbiAgaWYgKHNoYXBlID09PSBcInRyaW1lc2hcIiB8fCBzaGFwZSA9PT0gXCJjb252ZXhIdWxsXCIpIHtcbiAgICBuZXdBcmdzWzBdID0gc2NhbGVWZXJ0aWNlcyhuZXdBcmdzWzBdLCBzY2FsZSk7XG4gICAgcmV0dXJuIG5ld0FyZ3M7XG4gIH1cblxuICAvLyBQcmVwZmlsbCB3aXRoIHNvbWUgZXh0cmFcbiAgY29uc3Qgc2NhbGVBcnJheSA9IFtzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56LCBzY2FsZS54LCBzY2FsZS54XTtcbiAgcmV0dXJuIG5ld0FyZ3MubWFwKChhcmcsIGluZGV4KSA9PiBzY2FsZUFycmF5W2luZGV4XSAqIGFyZyk7XG59O1xuY29uc3QgY3JlYXRlQ29sbGlkZXJGcm9tT3B0aW9ucyA9IChvcHRpb25zLCB3b3JsZCwgc2NhbGUsIGdldFJpZ2lkQm9keSkgPT4ge1xuICBjb25zdCBzY2FsZWRBcmdzID0gc2NhbGVDb2xsaWRlckFyZ3Mob3B0aW9ucy5zaGFwZSwgb3B0aW9ucy5hcmdzLCBzY2FsZSk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZGVzYyA9IENvbGxpZGVyRGVzY1tvcHRpb25zLnNoYXBlXSguLi5zY2FsZWRBcmdzKTtcbiAgcmV0dXJuIHdvcmxkLmNyZWF0ZUNvbGxpZGVyKGRlc2MsIGdldFJpZ2lkQm9keSA9PT0gbnVsbCB8fCBnZXRSaWdpZEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldFJpZ2lkQm9keSgpKTtcbn07XG5jb25zdCBpbW11dGFibGVDb2xsaWRlck9wdGlvbnMgPSBbXCJzaGFwZVwiLCBcImFyZ3NcIl07XG5jb25zdCBtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IgPSBcIlBsZWFzZSBwaWNrIE9OTFkgT05FIG9mIHRoZSBgZGVuc2l0eWAsIGBtYXNzYCBhbmQgYG1hc3NQcm9wZXJ0aWVzYCBvcHRpb25zLlwiO1xuY29uc3Qgc2V0Q29sbGlkZXJNYXNzT3B0aW9ucyA9IChjb2xsaWRlciwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucy5kZW5zaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yKTtcbiAgICB9XG4gICAgY29sbGlkZXIuc2V0RGVuc2l0eShvcHRpb25zLmRlbnNpdHkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yKTtcbiAgICB9XG4gICAgY29sbGlkZXIuc2V0TWFzcyhvcHRpb25zLm1hc3MpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29sbGlkZXIuc2V0TWFzc1Byb3BlcnRpZXMob3B0aW9ucy5tYXNzUHJvcGVydGllcy5tYXNzLCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLmNlbnRlck9mTWFzcywgb3B0aW9ucy5tYXNzUHJvcGVydGllcy5wcmluY2lwYWxBbmd1bGFySW5lcnRpYSwgb3B0aW9ucy5tYXNzUHJvcGVydGllcy5hbmd1bGFySW5lcnRpYUxvY2FsRnJhbWUpO1xuICB9XG59O1xuY29uc3QgbXV0YWJsZUNvbGxpZGVyT3B0aW9ucyA9IHtcbiAgc2Vuc29yOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U2Vuc29yKHZhbHVlKTtcbiAgfSxcbiAgY29sbGlzaW9uR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgc29sdmVyR3JvdXBzOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0U29sdmVyR3JvdXBzKHZhbHVlKTtcbiAgfSxcbiAgZnJpY3Rpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbih2YWx1ZSk7XG4gIH0sXG4gIGZyaWN0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRGcmljdGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgcmVzdGl0dXRpb246IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbih2YWx1ZSk7XG4gIH0sXG4gIHJlc3RpdHV0aW9uQ29tYmluZVJ1bGU6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHZhbHVlKTtcbiAgfSxcbiAgYWN0aXZlQ29sbGlzaW9uVHlwZXM6IChjb2xsaWRlciwgdmFsdWUpID0+IHtcbiAgICBjb2xsaWRlci5zZXRBY3RpdmVDb2xsaXNpb25UeXBlcyh2YWx1ZSk7XG4gIH0sXG4gIGNvbnRhY3RTa2luOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0Q29udGFjdFNraW4odmFsdWUpO1xuICB9LFxuICAvLyBUbyBtYWtlIHN1cmUgdGhlIG9wdGlvbnMgYWxsIG11dGFibGUgb3B0aW9ucyBhcmUgbGlzdGVkXG4gIHF1YXRlcm5pb246ICgpID0+IHt9LFxuICBwb3NpdGlvbjogKCkgPT4ge30sXG4gIHJvdGF0aW9uOiAoKSA9PiB7fSxcbiAgc2NhbGU6ICgpID0+IHt9XG59O1xuY29uc3QgbXV0YWJsZUNvbGxpZGVyT3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG11dGFibGVDb2xsaWRlck9wdGlvbnMpO1xuY29uc3Qgc2V0Q29sbGlkZXJPcHRpb25zID0gKGNvbGxpZGVyLCBvcHRpb25zLCBzdGF0ZXMpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMuZ2V0KGNvbGxpZGVyLmhhbmRsZSk7XG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBfc3RhdGUkd29ybGRQYXJlbnQ7XG4gICAgLy8gVXBkYXRlIGNvbGxpZGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBvYmplY3QncyBwb3NpdGlvblxuICAgIGNvbnN0IHBhcmVudFdvcmxkU2NhbGUgPSBzdGF0ZS5vYmplY3QucGFyZW50LmdldFdvcmxkU2NhbGUoX3ZlY3RvcjMpO1xuICAgIGNvbnN0IHBhcmVudEludmVydGVkV29ybGRNYXRyaXggPSAoX3N0YXRlJHdvcmxkUGFyZW50ID0gc3RhdGUud29ybGRQYXJlbnQpID09PSBudWxsIHx8IF9zdGF0ZSR3b3JsZFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJHdvcmxkUGFyZW50Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG4gICAgc3RhdGUub2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICBfbWF0cml4NC5jb3B5KHN0YXRlLm9iamVjdC5tYXRyaXhXb3JsZCk7XG4gICAgaWYgKHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpIHtcbiAgICAgIF9tYXRyaXg0LnByZW11bHRpcGx5KHBhcmVudEludmVydGVkV29ybGRNYXRyaXgpO1xuICAgIH1cbiAgICBfbWF0cml4NC5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7XG4gICAgaWYgKGNvbGxpZGVyLnBhcmVudCgpKSB7XG4gICAgICBjb2xsaWRlci5zZXRUcmFuc2xhdGlvbldydFBhcmVudCh7XG4gICAgICAgIHg6IF9wb3NpdGlvbi54ICogcGFyZW50V29ybGRTY2FsZS54LFxuICAgICAgICB5OiBfcG9zaXRpb24ueSAqIHBhcmVudFdvcmxkU2NhbGUueSxcbiAgICAgICAgejogX3Bvc2l0aW9uLnogKiBwYXJlbnRXb3JsZFNjYWxlLnpcbiAgICAgIH0pO1xuICAgICAgY29sbGlkZXIuc2V0Um90YXRpb25XcnRQYXJlbnQoX3JvdGF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sbGlkZXIuc2V0VHJhbnNsYXRpb24oe1xuICAgICAgICB4OiBfcG9zaXRpb24ueCAqIHBhcmVudFdvcmxkU2NhbGUueCxcbiAgICAgICAgeTogX3Bvc2l0aW9uLnkgKiBwYXJlbnRXb3JsZFNjYWxlLnksXG4gICAgICAgIHo6IF9wb3NpdGlvbi56ICogcGFyZW50V29ybGRTY2FsZS56XG4gICAgICB9KTtcbiAgICAgIGNvbGxpZGVyLnNldFJvdGF0aW9uKF9yb3RhdGlvbik7XG4gICAgfVxuICAgIG11dGFibGVDb2xsaWRlck9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgbXV0YWJsZUNvbGxpZGVyT3B0aW9uc1trZXldKGNvbGxpZGVyLFxuICAgICAgICAvLyBAdHMtaWdub3JlIE9wdGlvbiBkb2VzIG5vdCB3YW50IHRvIGZpdCBpbnRvIHRoZSBmdW5jdGlvbiwgYnV0IGl0IHdpbGxcbiAgICAgICAgb3B0aW9uLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGhhbmRsZSBtYXNzIHNlcGFyYXRlbHksIGJlY2F1c2UgdGhlIGFzc2lnbm1lbnRzXG4gICAgLy8gYXJlIGV4Y2x1c2l2ZS5cbiAgICBzZXRDb2xsaWRlck1hc3NPcHRpb25zKGNvbGxpZGVyLCBvcHRpb25zKTtcbiAgfVxufTtcbmNvbnN0IHVzZVVwZGF0ZUNvbGxpZGVyT3B0aW9ucyA9IChnZXRDb2xsaWRlciwgcHJvcHMsIHN0YXRlcykgPT4ge1xuICAvLyBUT0RPOiBJbXByb3ZlIHRoaXMsIHNwbGl0IGVhY2ggcHJvcCBpbnRvIGl0cyBvd24gZWZmZWN0XG4gIGNvbnN0IG11dGFibGVQcm9wc0FzRmxhdEFycmF5ID0gdXNlTWVtbygoKSA9PiBtdXRhYmxlQ29sbGlkZXJPcHRpb25LZXlzLmZsYXRNYXAoa2V5ID0+IHtcbiAgICByZXR1cm4gdmVjdG9yVG9UdXBsZShwcm9wc1trZXldKTtcbiAgfSksIFtwcm9wc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gZ2V0Q29sbGlkZXIoKTtcbiAgICBzZXRDb2xsaWRlck9wdGlvbnMoY29sbGlkZXIsIHByb3BzLCBzdGF0ZXMpO1xuICB9LCBbLi4ubXV0YWJsZVByb3BzQXNGbGF0QXJyYXksIGdldENvbGxpZGVyXSk7XG59O1xuY29uc3QgaXNDaGlsZE9mTWVzaENvbGxpZGVyID0gY2hpbGQgPT4ge1xuICBsZXQgZmxhZyA9IGZhbHNlO1xuICBjaGlsZC50cmF2ZXJzZUFuY2VzdG9ycyhhID0+IHtcbiAgICBpZiAoYS51c2VyRGF0YS5yM1JhcGllclR5cGUgPT09IFwiTWVzaENvbGxpZGVyXCIpIGZsYWcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGZsYWc7XG59O1xuY29uc3QgY3JlYXRlQ29sbGlkZXJTdGF0ZSA9IChjb2xsaWRlciwgb2JqZWN0LCByaWdpZEJvZHlPYmplY3QpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjb2xsaWRlcixcbiAgICB3b3JsZFBhcmVudDogcmlnaWRCb2R5T2JqZWN0IHx8IHVuZGVmaW5lZCxcbiAgICBvYmplY3RcbiAgfTtcbn07XG5jb25zdCBhdXRvQ29sbGlkZXJNYXAgPSB7XG4gIGN1Ym9pZDogXCJjdWJvaWRcIixcbiAgYmFsbDogXCJiYWxsXCIsXG4gIGh1bGw6IFwiY29udmV4SHVsbFwiLFxuICB0cmltZXNoOiBcInRyaW1lc2hcIlxufTtcbmNvbnN0IGNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4gPSAoe1xuICBvYmplY3QsXG4gIGlnbm9yZU1lc2hDb2xsaWRlcnM6IF9pZ25vcmVNZXNoQ29sbGlkZXJzID0gdHJ1ZSxcbiAgb3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBjaGlsZENvbGxpZGVyUHJvcHMgPSBbXTtcbiAgb2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgY29uc3QgaW52ZXJ0ZWRQYXJlbnRNYXRyaXhXb3JsZCA9IG9iamVjdC5tYXRyaXhXb3JsZC5jbG9uZSgpLmludmVydCgpO1xuICBjb25zdCBjb2xsaWRlckZyb21DaGlsZCA9IGNoaWxkID0+IHtcbiAgICBpZiAoXCJpc01lc2hcIiBpbiBjaGlsZCkge1xuICAgICAgaWYgKF9pZ25vcmVNZXNoQ29sbGlkZXJzICYmIGlzQ2hpbGRPZk1lc2hDb2xsaWRlcihjaGlsZCkpIHJldHVybjtcbiAgICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBjaGlsZC5nZXRXb3JsZFNjYWxlKF9zY2FsZSk7XG4gICAgICBjb25zdCBzaGFwZSA9IGF1dG9Db2xsaWRlck1hcFtvcHRpb25zLmNvbGxpZGVycyB8fCBcImN1Ym9pZFwiXTtcbiAgICAgIGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIF9tYXRyaXg0LmNvcHkoY2hpbGQubWF0cml4V29ybGQpLnByZW11bHRpcGx5KGludmVydGVkUGFyZW50TWF0cml4V29ybGQpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uRXVsZXIgPSBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbihfcm90YXRpb24sIFwiWFlaXCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcmdzLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBnZXRDb2xsaWRlckFyZ3NGcm9tR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMuY29sbGlkZXJzIHx8IFwiY3Vib2lkXCIpO1xuICAgICAgY29uc3QgY29sbGlkZXJQcm9wcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjbGVhblJpZ2lkQm9keVByb3BzRm9yQ29sbGlkZXIob3B0aW9ucykpLCB7fSwge1xuICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHJvdGF0aW9uOiBbcm90YXRpb25FdWxlci54LCByb3RhdGlvbkV1bGVyLnksIHJvdGF0aW9uRXVsZXIuel0sXG4gICAgICAgIHBvc2l0aW9uOiBbX3Bvc2l0aW9uLnggKyBvZmZzZXQueCAqIHdvcmxkU2NhbGUueCwgX3Bvc2l0aW9uLnkgKyBvZmZzZXQueSAqIHdvcmxkU2NhbGUueSwgX3Bvc2l0aW9uLnogKyBvZmZzZXQueiAqIHdvcmxkU2NhbGUuel0sXG4gICAgICAgIHNjYWxlOiBbd29ybGRTY2FsZS54LCB3b3JsZFNjYWxlLnksIHdvcmxkU2NhbGUuel1cbiAgICAgIH0pO1xuICAgICAgY2hpbGRDb2xsaWRlclByb3BzLnB1c2goY29sbGlkZXJQcm9wcyk7XG4gICAgfVxuICB9O1xuICBpZiAob3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlKSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKGNvbGxpZGVyRnJvbUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3QudHJhdmVyc2VWaXNpYmxlKGNvbGxpZGVyRnJvbUNoaWxkKTtcbiAgfVxuICByZXR1cm4gY2hpbGRDb2xsaWRlclByb3BzO1xufTtcbmNvbnN0IGdldENvbGxpZGVyQXJnc0Zyb21HZW9tZXRyeSA9IChnZW9tZXRyeSwgY29sbGlkZXJzKSA9PiB7XG4gIHN3aXRjaCAoY29sbGlkZXJzKSB7XG4gICAgY2FzZSBcImN1Ym9pZFwiOlxuICAgICAge1xuICAgICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJvdW5kaW5nQm94XG4gICAgICAgIH0gPSBnZW9tZXRyeTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJvdW5kaW5nQm94LmdldFNpemUobmV3IFZlY3RvcjMoKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczogW3NpemUueCAvIDIsIHNpemUueSAvIDIsIHNpemUueiAvIDJdLFxuICAgICAgICAgIG9mZnNldDogYm91bmRpbmdCb3guZ2V0Q2VudGVyKG5ldyBWZWN0b3IzKCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSBcImJhbGxcIjpcbiAgICAgIHtcbiAgICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib3VuZGluZ1NwaGVyZVxuICAgICAgICB9ID0gZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbcmFkaXVzXSxcbiAgICAgICAgICBvZmZzZXQ6IGJvdW5kaW5nU3BoZXJlLmNlbnRlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJ0cmltZXNoXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfY2xvbmVkR2VvbWV0cnkkaW5kZXg7XG4gICAgICAgIGNvbnN0IGNsb25lZEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5jbG9uZSgpIDogbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczogW2Nsb25lZEdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXksIChfY2xvbmVkR2VvbWV0cnkkaW5kZXggPSBjbG9uZWRHZW9tZXRyeS5pbmRleCkgPT09IG51bGwgfHwgX2Nsb25lZEdlb21ldHJ5JGluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2xvbmVkR2VvbWV0cnkkaW5kZXguYXJyYXldLFxuICAgICAgICAgIG9mZnNldDogbmV3IFZlY3RvcjMoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJodWxsXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGcgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IFtnLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXldLFxuICAgICAgICAgIG9mZnNldDogbmV3IFZlY3RvcjMoKVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYXJnczogW10sXG4gICAgb2Zmc2V0OiBuZXcgVmVjdG9yMygpXG4gIH07XG59O1xuY29uc3QgZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzID0gcHJvcHMgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbGxpc2lvbjogISEocHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkNvbGxpc2lvbkVudGVyIHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25Db2xsaXNpb25FeGl0IHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25JbnRlcnNlY3Rpb25FbnRlciB8fCBwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uSW50ZXJzZWN0aW9uRXhpdCksXG4gICAgY29udGFjdEZvcmNlOiAhIShwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uQ29udGFjdEZvcmNlKVxuICB9O1xufTtcbmNvbnN0IHVzZUNvbGxpZGVyRXZlbnRzID0gKGdldENvbGxpZGVyLCBwcm9wcywgZXZlbnRzLFxuLyoqXG4gKiBUaGUgUmlnaWRCb2R5IGNhbiBwYXNzIGRvd24gYWN0aXZlIGV2ZW50cyB0byB0aGUgY29sbGlkZXIgd2l0aG91dCBhdHRhY2hpbmcgdGhlIGV2ZW50IGxpc3RuZXJzXG4gKi9cbmFjdGl2ZUV2ZW50cyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9ID0gcHJvcHM7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29sbGlkZXIgPSBnZXRDb2xsaWRlcigpO1xuICAgIGlmIChjb2xsaWRlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xsaXNpb246IGNvbGxpc2lvbkV2ZW50c0FjdGl2ZSxcbiAgICAgICAgY29udGFjdEZvcmNlOiBjb250YWN0Rm9yY2VFdmVudHNBY3RpdmVcbiAgICAgIH0gPSBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMocHJvcHMpO1xuICAgICAgY29uc3QgaGFzQ29sbGlzaW9uRXZlbnQgPSBjb2xsaXNpb25FdmVudHNBY3RpdmUgfHwgYWN0aXZlRXZlbnRzLmNvbGxpc2lvbjtcbiAgICAgIGNvbnN0IGhhc0NvbnRhY3RGb3JjZUV2ZW50ID0gY29udGFjdEZvcmNlRXZlbnRzQWN0aXZlIHx8IGFjdGl2ZUV2ZW50cy5jb250YWN0Rm9yY2U7XG4gICAgICBpZiAoaGFzQ29sbGlzaW9uRXZlbnQgJiYgaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTIHwgQWN0aXZlRXZlbnRzLkNPTlRBQ1RfRk9SQ0VfRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29sbGlzaW9uRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT0xMSVNJT05fRVZFTlRTKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGFjdEZvcmNlRXZlbnQpIHtcbiAgICAgICAgY29sbGlkZXIuc2V0QWN0aXZlRXZlbnRzKEFjdGl2ZUV2ZW50cy5DT05UQUNUX0ZPUkNFX0VWRU5UUyk7XG4gICAgICB9XG4gICAgICBldmVudHMuc2V0KGNvbGxpZGVyLmhhbmRsZSwge1xuICAgICAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgICAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICAgICAgb25Db250YWN0Rm9yY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNvbGxpZGVyKSB7XG4gICAgICAgIGV2ZW50cy5kZWxldGUoY29sbGlkZXIuaGFuZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbb25Db2xsaXNpb25FbnRlciwgb25Db2xsaXNpb25FeGl0LCBvbkludGVyc2VjdGlvbkVudGVyLCBvbkludGVyc2VjdGlvbkV4aXQsIG9uQ29udGFjdEZvcmNlLCBhY3RpdmVFdmVudHNdKTtcbn07XG5jb25zdCBjbGVhblJpZ2lkQm9keVByb3BzRm9yQ29sbGlkZXIgPSAocHJvcHMgPSB7fSkgPT4ge1xuICBjb25zdCByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQkMik7XG4gIHJldHVybiByZXN0O1xufTtcblxuLy8gVXRpbHNcbmNvbnN0IHVzZU11dGFibGVDYWxsYmFjayA9IGZuID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGZuKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGZuO1xuICB9LCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbi8vIEV4dGVybmFsIGhvb2tzXG4vKipcbiAqIEV4cG9zZXMgdGhlIFJhcGllciBjb250ZXh0LCBhbmQgd29ybGRcbiAqIEBjYXRlZ29yeSBIb29rc1xuICovXG5jb25zdCB1c2VSYXBpZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHJhcGllciA9IHVzZUNvbnRleHQocmFwaWVyQ29udGV4dCk7XG4gIGlmICghcmFwaWVyKSB0aHJvdyBuZXcgRXJyb3IoXCJyZWFjdC10aHJlZS1yYXBpZXI6IHVzZVJhcGllciBtdXN0IGJlIHVzZWQgd2l0aGluIDxQaHlzaWNzIC8+IVwiKTtcbiAgcmV0dXJuIHJhcGllcjtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGJlZm9yZSB0aGUgcGh5c2ljcyBzdGVwXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuY29uc3QgdXNlQmVmb3JlUGh5c2ljc1N0ZXAgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmFkZChyZWYpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmRlbGV0ZShyZWYpO1xuICAgIH07XG4gIH0sIFtdKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBwaHlzaWNzIHN0ZXBcbiAqIEBjYXRlZ29yeSBIb29rc1xuICovXG5jb25zdCB1c2VBZnRlclBoeXNpY3NTdGVwID0gY2FsbGJhY2sgPT4ge1xuICBjb25zdCB7XG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhZnRlclN0ZXBDYWxsYmFja3MuYWRkKHJlZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrcy5kZWxldGUocmVmKTtcbiAgICB9O1xuICB9LCBbXSk7XG59O1xuXG4vLyBJbnRlcm5hbCBob29rc1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgdXNlQ2hpbGRDb2xsaWRlclByb3BzID0gKHJlZiwgb3B0aW9ucywgaWdub3JlTWVzaENvbGxpZGVycyA9IHRydWUpID0+IHtcbiAgY29uc3QgW2NvbGxpZGVyUHJvcHMsIHNldENvbGxpZGVyUHJvcHNdID0gdXNlU3RhdGUoW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9iamVjdCA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChvYmplY3QgJiYgb3B0aW9ucy5jb2xsaWRlcnMgIT09IGZhbHNlKSB7XG4gICAgICBzZXRDb2xsaWRlclByb3BzKGNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4oe1xuICAgICAgICBvYmplY3Q6IHJlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpZ25vcmVNZXNoQ29sbGlkZXJzXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3B0aW9ucy5jb2xsaWRlcnNdKTtcbiAgcmV0dXJuIGNvbGxpZGVyUHJvcHM7XG59O1xuXG5jb25zdCBEZWJ1ZyA9IC8qI19fUFVSRV9fKi9tZW1vKCgpID0+IHtcbiAgY29uc3Qge1xuICAgIHdvcmxkXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgY29uc3QgbWVzaCA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbWVzaCkgcmV0dXJuO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB3b3JsZC5kZWJ1Z1JlbmRlcigpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXJzLnZlcnRpY2VzLCAzKSk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwiY29sb3JcIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXJzLmNvbG9ycywgNCkpO1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIG1lc2guZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVNlZ21lbnRzXCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBmcnVzdHVtQ3VsbGVkOiBmYWxzZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVCYXNpY01hdGVyaWFsXCIsIHtcbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgdmVydGV4Q29sb3JzOiB0cnVlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsIG51bGwpKSk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgdGhhdCB3aWxsIGNyZWF0ZSBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gY2xhc3NcbiAqIHdoZW4gYSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCwgYW5kIG5vdCBiZWZvcmUuXG4gKlxuICogQHJldHVybnMgQSBwcm94eSBhbmQgYSByZXNldCBmdW5jdGlvbiwgc28gdGhhdCB0aGUgaW5zdGFuY2UgY2FuIGNyZWF0ZWQgYWdhaW5cbiAqL1xuY29uc3QgY3JlYXRlU2luZ2xldG9uUHJveHkgPSBjcmVhdGVJbnN0YW5jZSA9PiB7XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgaGFuZGxlciA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldChpbnN0YW5jZSwgcHJvcCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQoaW5zdGFuY2UsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH07XG4gIGNvbnN0IHNldCA9IG5ld0luc3RhbmNlID0+IHtcbiAgICBpbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByb3h5IGFuZCBhIHJlc2V0IGZ1bmN0aW9uXG4gICAqL1xuICByZXR1cm4ge1xuICAgIHByb3h5LFxuICAgIHJlc2V0LFxuICAgIHNldFxuICB9O1xufTtcblxuY29uc3QgcmFwaWVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZSA9ICh0YXJnZXQsIG90aGVyKSA9PiB7XG4gIHZhciBfdGFyZ2V0JGNvbGxpZGVyJHN0YXQsIF90YXJnZXQkcmlnaWRCb2R5JHN0YSwgX290aGVyJGNvbGxpZGVyJHN0YXRlLCBfb3RoZXIkcmlnaWRCb2R5JHN0YXQsIF9vdGhlciRjb2xsaWRlciRzdGF0ZTIsIF9vdGhlciRyaWdpZEJvZHkkc3RhdDI7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB7XG4gICAgICByaWdpZEJvZHk6IHRhcmdldC5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IHRhcmdldC5jb2xsaWRlci5vYmplY3QsXG4gICAgICBjb2xsaWRlck9iamVjdDogKF90YXJnZXQkY29sbGlkZXIkc3RhdCA9IHRhcmdldC5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRjb2xsaWRlciRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JGNvbGxpZGVyJHN0YXQub2JqZWN0LFxuICAgICAgcmlnaWRCb2R5T2JqZWN0OiAoX3RhcmdldCRyaWdpZEJvZHkkc3RhID0gdGFyZ2V0LnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX3RhcmdldCRyaWdpZEJvZHkkc3RhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFyZ2V0JHJpZ2lkQm9keSRzdGEub2JqZWN0XG4gICAgfSxcbiAgICBvdGhlcjoge1xuICAgICAgcmlnaWRCb2R5OiBvdGhlci5yaWdpZEJvZHkub2JqZWN0LFxuICAgICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICAgIGNvbGxpZGVyT2JqZWN0OiAoX290aGVyJGNvbGxpZGVyJHN0YXRlID0gb3RoZXIuY29sbGlkZXIuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRjb2xsaWRlciRzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlLm9iamVjdCxcbiAgICAgIHJpZ2lkQm9keU9iamVjdDogKF9vdGhlciRyaWdpZEJvZHkkc3RhdCA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3RoZXIkcmlnaWRCb2R5JHN0YXQub2JqZWN0XG4gICAgfSxcbiAgICByaWdpZEJvZHk6IG90aGVyLnJpZ2lkQm9keS5vYmplY3QsXG4gICAgY29sbGlkZXI6IG90aGVyLmNvbGxpZGVyLm9iamVjdCxcbiAgICBjb2xsaWRlck9iamVjdDogKF9vdGhlciRjb2xsaWRlciRzdGF0ZTIgPSBvdGhlci5jb2xsaWRlci5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJGNvbGxpZGVyJHN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJGNvbGxpZGVyJHN0YXRlMi5vYmplY3QsXG4gICAgcmlnaWRCb2R5T2JqZWN0OiAoX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9IG90aGVyLnJpZ2lkQm9keS5zdGF0ZSkgPT09IG51bGwgfHwgX290aGVyJHJpZ2lkQm9keSRzdGF0MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJHJpZ2lkQm9keSRzdGF0Mi5vYmplY3RcbiAgfTtcbn07XG5jb25zdCBpbXBvcnRSYXBpZXIgPSBhc3luYyAoKSA9PiB7XG4gIGxldCByID0gYXdhaXQgaW1wb3J0KCdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0Jyk7XG4gIGF3YWl0IHIuaW5pdCgpO1xuICByZXR1cm4gcjtcbn07XG4vKipcbiAqIFRoZSBtYWluIHBoeXNpY3MgY29tcG9uZW50IHVzZWQgdG8gY3JlYXRlIGEgcGh5c2ljcyB3b3JsZC5cbiAqIEBjYXRlZ29yeSBDb21wb25lbnRzXG4gKi9cbmNvbnN0IFBoeXNpY3MgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICBjb2xsaWRlcnMgPSBcImN1Ym9pZFwiLFxuICAgIGNoaWxkcmVuLFxuICAgIHRpbWVTdGVwID0gMSAvIDYwLFxuICAgIHBhdXNlZCA9IGZhbHNlLFxuICAgIGludGVycG9sYXRlID0gdHJ1ZSxcbiAgICB1cGRhdGVQcmlvcml0eSxcbiAgICB1cGRhdGVMb29wID0gXCJmb2xsb3dcIixcbiAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgIGdyYXZpdHkgPSBbMCwgLTkuODEsIDBdLFxuICAgIGFsbG93ZWRMaW5lYXJFcnJvciA9IDAuMDAxLFxuICAgIHByZWRpY3Rpb25EaXN0YW5jZSA9IDAuMDAyLFxuICAgIG51bVNvbHZlckl0ZXJhdGlvbnMgPSA0LFxuICAgIG51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMgPSA0LFxuICAgIG51bUludGVybmFsUGdzSXRlcmF0aW9ucyA9IDEsXG4gICAgbWluSXNsYW5kU2l6ZSA9IDEyOCxcbiAgICBtYXhDY2RTdWJzdGVwcyA9IDEsXG4gICAgY29udGFjdE5hdHVyYWxGcmVxdWVuY3kgPSAzMCxcbiAgICBsZW5ndGhVbml0ID0gMVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJhcGllciA9IHN1c3BlbmQoaW1wb3J0UmFwaWVyLCBbXCJAcmVhY3QtdGhlZS9yYXBpZXJcIiwgaW1wb3J0UmFwaWVyXSk7XG4gIGNvbnN0IHtcbiAgICBpbnZhbGlkYXRlXG4gIH0gPSB1c2VUaHJlZSgpO1xuICBjb25zdCByaWdpZEJvZHlTdGF0ZXMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBjb2xsaWRlclN0YXRlcyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IHJpZ2lkQm9keUV2ZW50cyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNvbGxpZGVyRXZlbnRzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgZXZlbnRRdWV1ZSA9IHVzZUNvbnN0KCgpID0+IG5ldyBFdmVudFF1ZXVlKGZhbHNlKSk7XG4gIGNvbnN0IGJlZm9yZVN0ZXBDYWxsYmFja3MgPSB1c2VDb25zdCgoKSA9PiBuZXcgU2V0KCkpO1xuICBjb25zdCBhZnRlclN0ZXBDYWxsYmFja3MgPSB1c2VDb25zdCgoKSA9PiBuZXcgU2V0KCkpO1xuXG4gIC8qKlxuICAgKiBJbml0aWF0ZSB0aGUgd29ybGRcbiAgICogVGhpcyBjcmVhdGVzIGEgc2luZ2xldG9uIHByb3h5LCBzbyB0aGF0IHRoZSB3b3JsZCBpcyBvbmx5IGNyZWF0ZWQgd2hlblxuICAgKiBzb21ldGhpbmcgd2l0aGluIGl0IGlzIGFjY2Vzc2VkLlxuICAgKi9cbiAgY29uc3Qge1xuICAgIHByb3h5OiB3b3JsZFByb3h5LFxuICAgIHJlc2V0OiByZXNldFdvcmxkUHJveHksXG4gICAgc2V0OiBzZXRXb3JsZFByb3h5XG4gIH0gPSB1c2VDb25zdCgoKSA9PiBjcmVhdGVTaW5nbGV0b25Qcm94eSgoKSA9PiBuZXcgcmFwaWVyLldvcmxkKHZlY3RvckFycmF5VG9WZWN0b3IzKGdyYXZpdHkpKSkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3b3JsZFByb3h5LmZyZWUoKTtcbiAgICAgIHJlc2V0V29ybGRQcm94eSgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBVcGRhdGUgbXV0YWJsZSBwcm9wc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdvcmxkUHJveHkuZ3Jhdml0eSA9IHZlY3RvcjNUb1JhcGllclZlY3RvcihncmF2aXR5KTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1Tb2x2ZXJJdGVyYXRpb25zID0gbnVtU29sdmVySXRlcmF0aW9ucztcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zID0gbnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucztcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5udW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMgPSBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubm9ybWFsaXplZEFsbG93ZWRMaW5lYXJFcnJvciA9IGFsbG93ZWRMaW5lYXJFcnJvcjtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5taW5Jc2xhbmRTaXplID0gbWluSXNsYW5kU2l6ZTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5tYXhDY2RTdWJzdGVwcyA9IG1heENjZFN1YnN0ZXBzO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm5vcm1hbGl6ZWRQcmVkaWN0aW9uRGlzdGFuY2UgPSBwcmVkaWN0aW9uRGlzdGFuY2U7XG4gICAgd29ybGRQcm94eS5sZW5ndGhVbml0ID0gbGVuZ3RoVW5pdDtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5jb250YWN0X25hdHVyYWxfZnJlcXVlbmN5ID0gY29udGFjdE5hdHVyYWxGcmVxdWVuY3k7XG4gIH0sIFt3b3JsZFByb3h5LCAuLi5ncmF2aXR5LCBudW1Tb2x2ZXJJdGVyYXRpb25zLCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zLCBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMsIGFsbG93ZWRMaW5lYXJFcnJvciwgbWluSXNsYW5kU2l6ZSwgbWF4Q2NkU3Vic3RlcHMsIHByZWRpY3Rpb25EaXN0YW5jZSwgbGVuZ3RoVW5pdCwgY29udGFjdE5hdHVyYWxGcmVxdWVuY3ldKTtcbiAgY29uc3QgZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlID0gdXNlQ2FsbGJhY2soaGFuZGxlID0+IHtcbiAgICB2YXIgX2NvbGxpZGVyJHBhcmVudDtcbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkUHJveHkuZ2V0Q29sbGlkZXIoaGFuZGxlKTtcbiAgICBjb25zdCBjb2xFdmVudHMgPSBjb2xsaWRlckV2ZW50cy5nZXQoaGFuZGxlKTtcbiAgICBjb25zdCBjb2xsaWRlclN0YXRlID0gY29sbGlkZXJTdGF0ZXMuZ2V0KGhhbmRsZSk7XG4gICAgY29uc3QgcmlnaWRCb2R5SGFuZGxlID0gY29sbGlkZXIgPT09IG51bGwgfHwgY29sbGlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29sbGlkZXIkcGFyZW50ID0gY29sbGlkZXIucGFyZW50KCkpID09PSBudWxsIHx8IF9jb2xsaWRlciRwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsaWRlciRwYXJlbnQuaGFuZGxlO1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gd29ybGRQcm94eS5nZXRSaWdpZEJvZHkocmlnaWRCb2R5SGFuZGxlKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByYkV2ZW50cyA9IHJpZ2lkQm9keSAmJiByaWdpZEJvZHlIYW5kbGUgIT09IHVuZGVmaW5lZCA/IHJpZ2lkQm9keUV2ZW50cy5nZXQocmlnaWRCb2R5SGFuZGxlKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByaWdpZEJvZHlTdGF0ZSA9IHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gcmlnaWRCb2R5U3RhdGVzLmdldChyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNvdXJjZSA9IHtcbiAgICAgIGNvbGxpZGVyOiB7XG4gICAgICAgIG9iamVjdDogY29sbGlkZXIsXG4gICAgICAgIGV2ZW50czogY29sRXZlbnRzLFxuICAgICAgICBzdGF0ZTogY29sbGlkZXJTdGF0ZVxuICAgICAgfSxcbiAgICAgIHJpZ2lkQm9keToge1xuICAgICAgICBvYmplY3Q6IHJpZ2lkQm9keSxcbiAgICAgICAgZXZlbnRzOiByYkV2ZW50cyxcbiAgICAgICAgc3RhdGU6IHJpZ2lkQm9keVN0YXRlXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IFtzdGVwcGluZ1N0YXRlXSA9IHVzZVN0YXRlKHtcbiAgICBwcmV2aW91c1N0YXRlOiB7fSxcbiAgICBhY2N1bXVsYXRvcjogMFxuICB9KTtcbiAgY29uc3Qgc3RlcCA9IHVzZUNhbGxiYWNrKGR0ID0+IHtcbiAgICBjb25zdCB3b3JsZCA9IHdvcmxkUHJveHk7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgdGltZXN0ZXAgaXMgc3VwcG9zZWQgdG8gYmUgdmFyaWFibGUuIFdlJ2xsIGRvIHRoaXMgaGVyZVxuICAgICAgb25jZSBzbyB3ZSBkb24ndCBoYXZlIHRvIHN0cmluZy1jaGVjayBldmVyeSBmcmFtZS4gKi9cbiAgICBjb25zdCB0aW1lU3RlcFZhcmlhYmxlID0gdGltZVN0ZXAgPT09IFwidmFyeVwiO1xuXG4gICAgLyoqXG4gICAgICogRml4ZWQgdGltZVN0ZXAgc2ltdWxhdGlvbiBwcm9ncmVzc2lvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9nYWZmZXJvbmdhbWVzLmNvbS9wb3N0L2ZpeF95b3VyX3RpbWVzdGVwL1xuICAgICAqL1xuXG4gICAgY29uc3QgY2xhbXBlZERlbHRhID0gTWF0aFV0aWxzLmNsYW1wKGR0LCAwLCAwLjUpO1xuICAgIGNvbnN0IHN0ZXBXb3JsZCA9IGRlbHRhID0+IHtcbiAgICAgIC8vIFRyaWdnZXIgYmVmb3JlU3RlcCBjYWxsYmFja3NcbiAgICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmN1cnJlbnQod29ybGQpO1xuICAgICAgfSk7XG4gICAgICB3b3JsZC50aW1lc3RlcCA9IGRlbHRhO1xuICAgICAgd29ybGQuc3RlcChldmVudFF1ZXVlKTtcblxuICAgICAgLy8gVHJpZ2dlciBhZnRlclN0ZXAgY2FsbGJhY2tzXG4gICAgICBhZnRlclN0ZXBDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmN1cnJlbnQod29ybGQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGltZVN0ZXBWYXJpYWJsZSkge1xuICAgICAgc3RlcFdvcmxkKGNsYW1wZWREZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IHN0ZXAgdGltZSBmb3J3YXJkcyBpZiBwYXVzZWRcbiAgICAgIC8vIEluY3JlYXNlIGFjY3VtdWxhdG9yXG4gICAgICBzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yICs9IGNsYW1wZWREZWx0YTtcbiAgICAgIHdoaWxlIChzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yID49IHRpbWVTdGVwKSB7XG4gICAgICAgIC8vIFNldCB1cCBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAvLyBuZWVkZWQgZm9yIGFjY3VyYXRlIGludGVycG9sYXRpb25zIGlmIHRoZSB3b3JsZCBzdGVwcyBtb3JlIHRoYW4gb25jZVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGUgPSB7fTtcbiAgICAgICAgICB3b3JsZC5mb3JFYWNoUmlnaWRCb2R5KGJvZHkgPT4ge1xuICAgICAgICAgICAgc3RlcHBpbmdTdGF0ZS5wcmV2aW91c1N0YXRlW2JvZHkuaGFuZGxlXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGJvZHkudHJhbnNsYXRpb24oKSxcbiAgICAgICAgICAgICAgcm90YXRpb246IGJvZHkucm90YXRpb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwV29ybGQodGltZVN0ZXApO1xuICAgICAgICBzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yIC09IHRpbWVTdGVwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQWxwaGEgPSB0aW1lU3RlcFZhcmlhYmxlIHx8ICFpbnRlcnBvbGF0ZSB8fCBwYXVzZWQgPyAxIDogc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciAvIHRpbWVTdGVwO1xuXG4gICAgLy8gVXBkYXRlIG1lc2hlc1xuICAgIHJpZ2lkQm9keVN0YXRlcy5mb3JFYWNoKChzdGF0ZSwgaGFuZGxlKSA9PiB7XG4gICAgICBjb25zdCByaWdpZEJvZHkgPSB3b3JsZC5nZXRSaWdpZEJvZHkoaGFuZGxlKTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHJpZ2lkQm9keUV2ZW50cy5nZXQoaGFuZGxlKTtcbiAgICAgIGlmIChldmVudHMgIT09IG51bGwgJiYgZXZlbnRzICE9PSB2b2lkIDAgJiYgZXZlbnRzLm9uU2xlZXAgfHwgZXZlbnRzICE9PSBudWxsICYmIGV2ZW50cyAhPT0gdm9pZCAwICYmIGV2ZW50cy5vbldha2UpIHtcbiAgICAgICAgaWYgKHJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyRvblNsZWVwO1xuICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnRzJG9uU2xlZXAgPSBldmVudHMub25TbGVlcCkgPT09IG51bGwgfHwgX2V2ZW50cyRvblNsZWVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnRzJG9uU2xlZXAuY2FsbChldmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmlnaWRCb2R5LmlzU2xlZXBpbmcoKSAmJiBzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgdmFyIF9ldmVudHMkb25XYWtlO1xuICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnRzJG9uV2FrZSA9IGV2ZW50cy5vbldha2UpID09PSBudWxsIHx8IF9ldmVudHMkb25XYWtlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnRzJG9uV2FrZS5jYWxsKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IHJpZ2lkQm9keS5pc1NsZWVwaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXJpZ2lkQm9keSB8fCByaWdpZEJvZHkuaXNTbGVlcGluZygpICYmICEoXCJpc0luc3RhbmNlZE1lc2hcIiBpbiBzdGF0ZS5vYmplY3QpIHx8ICFzdGF0ZS5zZXRNYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOZXcgc3RhdGVzXG4gICAgICBsZXQgdCA9IHJpZ2lkQm9keS50cmFuc2xhdGlvbigpO1xuICAgICAgbGV0IHIgPSByaWdpZEJvZHkucm90YXRpb24oKTtcbiAgICAgIGxldCBwcmV2aW91c1N0YXRlID0gc3RlcHBpbmdTdGF0ZS5wcmV2aW91c1N0YXRlW2hhbmRsZV07XG4gICAgICBpZiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgICAvLyBHZXQgcHJldmlvdXMgc2ltdWxhdGVkIHdvcmxkIHBvc2l0aW9uXG4gICAgICAgIF9tYXRyaXg0LmNvbXBvc2UocHJldmlvdXNTdGF0ZS5wb3NpdGlvbiwgcmFwaWVyUXVhdGVybmlvblRvUXVhdGVybmlvbihwcmV2aW91c1N0YXRlLnJvdGF0aW9uKSwgc3RhdGUuc2NhbGUpLnByZW11bHRpcGx5KHN0YXRlLmludmVydGVkV29ybGRNYXRyaXgpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgICAgICAvLyBBcHBseSBwcmV2aW91cyB0aWNrIHBvc2l0aW9uXG4gICAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcIm1lc2hcIikge1xuICAgICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5jb3B5KF9wb3NpdGlvbik7XG4gICAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uY29weShfcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBuZXcgcG9zaXRpb25cbiAgICAgIF9tYXRyaXg0LmNvbXBvc2UodCwgcmFwaWVyUXVhdGVybmlvblRvUXVhdGVybmlvbihyKSwgc3RhdGUuc2NhbGUpLnByZW11bHRpcGx5KHN0YXRlLmludmVydGVkV29ybGRNYXRyaXgpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcbiAgICAgIGlmIChzdGF0ZS5tZXNoVHlwZSA9PSBcImluc3RhbmNlZE1lc2hcIikge1xuICAgICAgICBzdGF0ZS5zZXRNYXRyaXgoX21hdHJpeDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gbmV3IHBvc2l0aW9uXG4gICAgICAgIHN0YXRlLm9iamVjdC5wb3NpdGlvbi5sZXJwKF9wb3NpdGlvbiwgaW50ZXJwb2xhdGlvbkFscGhhKTtcbiAgICAgICAgc3RhdGUub2JqZWN0LnF1YXRlcm5pb24uc2xlcnAoX3JvdGF0aW9uLCBpbnRlcnBvbGF0aW9uQWxwaGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZW50UXVldWUuZHJhaW5Db2xsaXNpb25FdmVudHMoKGhhbmRsZTEsIGhhbmRsZTIsIHN0YXJ0ZWQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZTEgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoaGFuZGxlMSk7XG4gICAgICBjb25zdCBzb3VyY2UyID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGhhbmRsZTIpO1xuXG4gICAgICAvLyBDb2xsaXNpb24gRXZlbnRzXG4gICAgICBpZiAoIShzb3VyY2UxICE9PSBudWxsICYmIHNvdXJjZTEgIT09IHZvaWQgMCAmJiBzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCkgfHwgIShzb3VyY2UyICE9PSBudWxsICYmIHNvdXJjZTIgIT09IHZvaWQgMCAmJiBzb3VyY2UyLmNvbGxpZGVyLm9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDEgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UxLCBzb3VyY2UyKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQyID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMiwgc291cmNlMSk7XG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICB3b3JsZC5jb250YWN0UGFpcihzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCwgc291cmNlMi5jb2xsaWRlci5vYmplY3QsIChtYW5pZm9sZCwgZmxpcHBlZCkgPT4ge1xuICAgICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXYsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjIsIF9zb3VyY2UyJHJpZ2lkQm9keSRldiwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MiwgX3NvdXJjZTEkY29sbGlkZXIkZXZlLCBfc291cmNlMSRjb2xsaWRlciRldmUyLCBfc291cmNlMiRjb2xsaWRlciRldmUsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTI7XG4gICAgICAgICAgLyogUmlnaWRCb2R5IGV2ZW50cyAqL1xuICAgICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXYgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjIgPSBfc291cmNlMSRyaWdpZEJvZHkkZXYub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2Mi5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXYyID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2Lm9uQ29sbGlzaW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjIuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgICAgICBtYW5pZm9sZCxcbiAgICAgICAgICAgIGZsaXBwZWRcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAvKiBDb2xsaWRlciBldmVudHMgKi9cbiAgICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTIgPSBfc291cmNlMSRjb2xsaWRlciRldmUub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlMi5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTIgPSBfc291cmNlMiRjb2xsaWRlciRldmUub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlMi5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MywgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MywgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NCwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMywgX3NvdXJjZTEkY29sbGlkZXIkZXZlNCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMywgX3NvdXJjZTIkY29sbGlkZXIkZXZlNDtcbiAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldjMgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRyaWdpZEJvZHkkZXY0ID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2My5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjQuY2FsbChfc291cmNlMSRyaWdpZEJvZHkkZXYzLCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXYzID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NCA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjMub25Db2xsaXNpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXY0LmNhbGwoX3NvdXJjZTIkcmlnaWRCb2R5JGV2MywgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlMyA9IHNvdXJjZTEuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNCA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMub25Db2xsaXNpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmU0LmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlMywgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlMyA9IHNvdXJjZTIuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNCA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMub25Db2xsaXNpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmU0LmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlMywgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZW5zb3IgSW50ZXJzZWN0aW9uc1xuICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKHdvcmxkLmludGVyc2VjdGlvblBhaXIoc291cmNlMS5jb2xsaWRlci5vYmplY3QsIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXY1LCBfc291cmNlMSRyaWdpZEJvZHkkZXY2LCBfc291cmNlMiRyaWdpZEJvZHkkZXY1LCBfc291cmNlMiRyaWdpZEJvZHkkZXY2LCBfc291cmNlMSRjb2xsaWRlciRldmU1LCBfc291cmNlMSRjb2xsaWRlciRldmU2LCBfc291cmNlMiRjb2xsaWRlciRldmU1LCBfc291cmNlMiRjb2xsaWRlciRldmU2O1xuICAgICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXY1ID0gc291cmNlMS5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NiA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldjUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2Ni5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjUsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NSA9IHNvdXJjZTIucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJHJpZ2lkQm9keSRldjYgPSBfc291cmNlMiRyaWdpZEJvZHkkZXY1Lm9uSW50ZXJzZWN0aW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjYuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXY1LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgICAgKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUgPSBzb3VyY2UxLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYgPSBfc291cmNlMSRjb2xsaWRlciRldmU1Lm9uSW50ZXJzZWN0aW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYuY2FsbChfc291cmNlMSRjb2xsaWRlciRldmU1LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgICAgKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUgPSBzb3VyY2UyLmNvbGxpZGVyLmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTYgPSBfc291cmNlMiRjb2xsaWRlciRldmU1Lm9uSW50ZXJzZWN0aW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTYuY2FsbChfc291cmNlMiRjb2xsaWRlciRldmU1LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXY3LCBfc291cmNlMSRyaWdpZEJvZHkkZXY4LCBfc291cmNlMiRyaWdpZEJvZHkkZXY3LCBfc291cmNlMiRyaWdpZEJvZHkkZXY4LCBfc291cmNlMSRjb2xsaWRlciRldmU3LCBfc291cmNlMSRjb2xsaWRlciRldmU4LCBfc291cmNlMiRjb2xsaWRlciRldmU3LCBfc291cmNlMiRjb2xsaWRlciRldmU4O1xuICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjggPSBfc291cmNlMSRyaWdpZEJvZHkkZXY3Lm9uSW50ZXJzZWN0aW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2OC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjcsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY4ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2Ny5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjguY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXY3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU3ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMSRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU3ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU4ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlNy5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTguY2FsbChfc291cmNlMiRjb2xsaWRlciRldmU3LCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXZlbnRRdWV1ZS5kcmFpbkNvbnRhY3RGb3JjZUV2ZW50cyhldmVudCA9PiB7XG4gICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwLCBfc291cmNlMSRjb2xsaWRlciRldmU5LCBfc291cmNlMSRjb2xsaWRlciRldmUxMCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlOSwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMTA7XG4gICAgICBjb25zdCBzb3VyY2UxID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGV2ZW50LmNvbGxpZGVyMSgpKTtcbiAgICAgIGNvbnN0IHNvdXJjZTIgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoZXZlbnQuY29sbGlkZXIyKCkpO1xuXG4gICAgICAvLyBDb2xsaXNpb24gRXZlbnRzXG4gICAgICBpZiAoIShzb3VyY2UxICE9PSBudWxsICYmIHNvdXJjZTEgIT09IHZvaWQgMCAmJiBzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCkgfHwgIShzb3VyY2UyICE9PSBudWxsICYmIHNvdXJjZTIgIT09IHZvaWQgMCAmJiBzb3VyY2UyLmNvbGxpZGVyLm9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDEgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UxLCBzb3VyY2UyKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQyID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMiwgc291cmNlMSk7XG4gICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2OS5vbkNvbnRhY3RGb3JjZSkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MTAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwLmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2OSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgdG90YWxGb3JjZTogZXZlbnQudG90YWxGb3JjZSgpLFxuICAgICAgICB0b3RhbEZvcmNlTWFnbml0dWRlOiBldmVudC50b3RhbEZvcmNlTWFnbml0dWRlKCksXG4gICAgICAgIG1heEZvcmNlRGlyZWN0aW9uOiBldmVudC5tYXhGb3JjZURpcmVjdGlvbigpLFxuICAgICAgICBtYXhGb3JjZU1hZ25pdHVkZTogZXZlbnQubWF4Rm9yY2VNYWduaXR1ZGUoKVxuICAgICAgfSkpO1xuICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXYxMCA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXYxMC5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmU5ID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMSksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmU5ID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmUxMCA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmUxMC5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB3b3JsZC5mb3JFYWNoQWN0aXZlUmlnaWRCb2R5KCgpID0+IHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICB9KTtcbiAgfSwgW3BhdXNlZCwgdGltZVN0ZXAsIGludGVycG9sYXRlLCB3b3JsZFByb3h5XSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmFwaWVyLFxuICAgIHdvcmxkOiB3b3JsZFByb3h5LFxuICAgIHNldFdvcmxkOiB3b3JsZCA9PiB7XG4gICAgICBzZXRXb3JsZFByb3h5KHdvcmxkKTtcbiAgICB9LFxuICAgIHBoeXNpY3NPcHRpb25zOiB7XG4gICAgICBjb2xsaWRlcnMsXG4gICAgICBncmF2aXR5XG4gICAgfSxcbiAgICByaWdpZEJvZHlTdGF0ZXMsXG4gICAgY29sbGlkZXJTdGF0ZXMsXG4gICAgcmlnaWRCb2R5RXZlbnRzLFxuICAgIGNvbGxpZGVyRXZlbnRzLFxuICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MsXG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzLFxuICAgIGlzUGF1c2VkOiBwYXVzZWQsXG4gICAgaXNEZWJ1ZzogZGVidWcsXG4gICAgc3RlcFxuICB9KSwgW3BhdXNlZCwgc3RlcCwgZGVidWcsIGNvbGxpZGVycywgZ3Jhdml0eV0pO1xuICBjb25zdCBzdGVwQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhkZWx0YSA9PiB7XG4gICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgIHN0ZXAoZGVsdGEpO1xuICAgIH1cbiAgfSwgW3BhdXNlZCwgc3RlcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocmFwaWVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZyYW1lU3RlcHBlciQxLCB7XG4gICAgb25TdGVwOiBzdGVwQ2FsbGJhY2ssXG4gICAgdHlwZTogdXBkYXRlTG9vcCxcbiAgICB1cGRhdGVQcmlvcml0eTogdXBkYXRlUHJpb3JpdHlcbiAgfSksIGRlYnVnICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlYnVnLCBudWxsKSwgY2hpbGRyZW4pO1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7XG4gICAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW2VdO1xuICAgICAgZm9yICh2YXIgciBpbiB0KSAoe30pLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKG5bcl0gPSB0W3JdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIE5lZWQgdG8gY2F0Y2ggdGhlIGNhc2Ugd2hlcmUgZm9yd2FyZGVkUmVmIGlzIGEgZnVuY3Rpb24uLi4gaG93IHRvIGRvIHRoYXQ/XG5jb25zdCB1c2VGb3J3YXJkZWRSZWYgPSAoZm9yd2FyZGVkUmVmLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGlubmVyUmVmID0gdXNlUmVmKGRlZmF1bHRWYWx1ZSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBmb3J3YXJkZWQgcmVmIHdoZW4gdGhlIGlubmVyIHJlZiBjaGFuZ2VzXG4gIGlmIChmb3J3YXJkZWRSZWYgJiYgdHlwZW9mIGZvcndhcmRlZFJlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKCFmb3J3YXJkZWRSZWYuY3VycmVudCkge1xuICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbm5lclJlZi5jdXJyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZm9yd2FyZGVkUmVmO1xuICB9XG4gIHJldHVybiBpbm5lclJlZjtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYW4gaW5zdGFuY2UgYW5kIHJldHVybiBhIHNhZmUgZ2V0dGVyXG4gKi9cbmNvbnN0IHVzZUltcGVyYXRpdmVJbnN0YW5jZSA9IChjcmVhdGVGbiwgZGVzdHJveUZuLCBkZXBlbmRlbmN5TGlzdCkgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgcmVmLmN1cnJlbnQgPSBjcmVhdGVGbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gIH0sIGRlcGVuZGVuY3lMaXN0KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTYXZlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIGFuZCBpbnN0YW5jZVxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0SW5zdGFuY2UoKTtcbiAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4gZGVzdHJveUZuKGluc3RhbmNlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVzdHJveSgpO1xuICAgICAgcmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSwgW2dldEluc3RhbmNlXSk7XG4gIHJldHVybiBnZXRJbnN0YW5jZTtcbn07XG5cbmNvbnN0IHJpZ2lkQm9keURlc2NGcm9tT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICB2YXIgX29wdGlvbnMkY2FuU2xlZXA7XG4gIGNvbnN0IHR5cGUgPSByaWdpZEJvZHlUeXBlRnJvbVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnR5cGUpIHx8IFwiZHluYW1pY1wiKTtcbiAgY29uc3QgZGVzYyA9IG5ldyBSaWdpZEJvZHlEZXNjKHR5cGUpO1xuXG4gIC8vIEFwcGx5IGltbXV0YWJsZSBvcHRpb25zXG4gIGRlc2MuY2FuU2xlZXAgPSAoX29wdGlvbnMkY2FuU2xlZXAgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FuU2xlZXApICE9PSBudWxsICYmIF9vcHRpb25zJGNhblNsZWVwICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYW5TbGVlcCA6IHRydWU7XG4gIHJldHVybiBkZXNjO1xufTtcbmNvbnN0IGNyZWF0ZVJpZ2lkQm9keVN0YXRlID0gKHtcbiAgcmlnaWRCb2R5LFxuICBvYmplY3QsXG4gIHNldE1hdHJpeCxcbiAgZ2V0TWF0cml4LFxuICB3b3JsZFNjYWxlLFxuICBtZXNoVHlwZTogX21lc2hUeXBlID0gXCJtZXNoXCJcbn0pID0+IHtcbiAgb2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgY29uc3QgaW52ZXJ0ZWRXb3JsZE1hdHJpeCA9IG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBvYmplY3QsXG4gICAgcmlnaWRCb2R5LFxuICAgIGludmVydGVkV29ybGRNYXRyaXgsXG4gICAgc2V0TWF0cml4OiBzZXRNYXRyaXggPyBzZXRNYXRyaXggOiBtYXRyaXggPT4ge1xuICAgICAgb2JqZWN0Lm1hdHJpeC5jb3B5KG1hdHJpeCk7XG4gICAgfSxcbiAgICBnZXRNYXRyaXg6IGdldE1hdHJpeCA/IGdldE1hdHJpeCA6IG1hdHJpeCA9PiBtYXRyaXguY29weShvYmplY3QubWF0cml4KSxcbiAgICBzY2FsZTogd29ybGRTY2FsZSB8fCBvYmplY3QuZ2V0V29ybGRTY2FsZShfc2NhbGUpLmNsb25lKCksXG4gICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgbWVzaFR5cGU6IF9tZXNoVHlwZVxuICB9O1xufTtcbmNvbnN0IGltbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMgPSBbXCJhcmdzXCIsIFwiY29sbGlkZXJzXCIsIFwiY2FuU2xlZXBcIl07XG5jb25zdCBtdXRhYmxlUmlnaWRCb2R5T3B0aW9ucyA9IHtcbiAgZ3Jhdml0eVNjYWxlOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0R3Jhdml0eVNjYWxlKHZhbHVlLCB0cnVlKTtcbiAgfSxcbiAgYWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnMocmIsIHZhbHVlKSB7XG4gICAgcmIuc2V0QWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnModmFsdWUpO1xuICB9LFxuICBsaW5lYXJEYW1waW5nOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0TGluZWFyRGFtcGluZyh2YWx1ZSk7XG4gIH0sXG4gIGFuZ3VsYXJEYW1waW5nOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0QW5ndWxhckRhbXBpbmcodmFsdWUpO1xuICB9LFxuICBkb21pbmFuY2VHcm91cDogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLnNldERvbWluYW5jZUdyb3VwKHZhbHVlKTtcbiAgfSxcbiAgZW5hYmxlZFJvdGF0aW9uczogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRFbmFibGVkUm90YXRpb25zKHgsIHksIHosIHRydWUpO1xuICB9LFxuICBlbmFibGVkVHJhbnNsYXRpb25zOiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldEVuYWJsZWRUcmFuc2xhdGlvbnMoeCwgeSwgeiwgdHJ1ZSk7XG4gIH0sXG4gIGxvY2tSb3RhdGlvbnM6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5sb2NrUm90YXRpb25zKHZhbHVlLCB0cnVlKTtcbiAgfSxcbiAgbG9ja1RyYW5zbGF0aW9uczogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmxvY2tUcmFuc2xhdGlvbnModmFsdWUsIHRydWUpO1xuICB9LFxuICBhbmd1bGFyVmVsb2NpdHk6IChyYiwgW3gsIHksIHpdKSA9PiB7XG4gICAgcmIuc2V0QW5ndmVsKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgelxuICAgIH0sIHRydWUpO1xuICB9LFxuICBsaW5lYXJWZWxvY2l0eTogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRMaW52ZWwoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGNjZDogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmVuYWJsZUNjZCh2YWx1ZSk7XG4gIH0sXG4gIHNvZnRDY2RQcmVkaWN0aW9uOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0U29mdENjZFByZWRpY3Rpb24odmFsdWUpO1xuICB9LFxuICB1c2VyRGF0YTogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLnVzZXJEYXRhID0gdmFsdWU7XG4gIH0sXG4gIHR5cGUocmIsIHZhbHVlKSB7XG4gICAgcmIuc2V0Qm9keVR5cGUocmlnaWRCb2R5VHlwZUZyb21TdHJpbmcodmFsdWUpLCB0cnVlKTtcbiAgfSxcbiAgcG9zaXRpb246ICgpID0+IHt9LFxuICByb3RhdGlvbjogKCkgPT4ge30sXG4gIHF1YXRlcm5pb246ICgpID0+IHt9LFxuICBzY2FsZTogKCkgPT4ge31cbn07XG5jb25zdCBtdXRhYmxlUmlnaWRCb2R5T3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG11dGFibGVSaWdpZEJvZHlPcHRpb25zKTtcbmNvbnN0IHNldFJpZ2lkQm9keU9wdGlvbnMgPSAocmlnaWRCb2R5LCBvcHRpb25zLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyA9IHRydWUpID0+IHtcbiAgaWYgKCFyaWdpZEJvZHkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMuZ2V0KHJpZ2lkQm9keS5oYW5kbGUpO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodXBkYXRlVHJhbnNsYXRpb25zKSB7XG4gICAgICBzdGF0ZS5vYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgICAgX21hdHJpeDQuY29weShzdGF0ZS5vYmplY3QubWF0cml4V29ybGQpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcbiAgICAgIHJpZ2lkQm9keS5zZXRUcmFuc2xhdGlvbihfcG9zaXRpb24sIGZhbHNlKTtcbiAgICAgIHJpZ2lkQm9keS5zZXRSb3RhdGlvbihfcm90YXRpb24sIGZhbHNlKTtcbiAgICB9XG4gICAgbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG11dGFibGVSaWdpZEJvZHlPcHRpb25zW2tleV0ocmlnaWRCb2R5LCBvcHRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuY29uc3QgdXNlVXBkYXRlUmlnaWRCb2R5T3B0aW9ucyA9IChnZXRSaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyA9IHRydWUpID0+IHtcbiAgLy8gVE9ETzogSW1wcm92ZSB0aGlzLCBzcGxpdCBlYWNoIHByb3AgaW50byBpdHMgb3duIGVmZmVjdFxuICBjb25zdCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSA9IHVzZU1lbW8oKCkgPT4gbXV0YWJsZVJpZ2lkQm9keU9wdGlvbktleXMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiB2ZWN0b3JUb1R1cGxlKHByb3BzW2tleV0pO1xuICB9KSwgW3Byb3BzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gZ2V0UmlnaWRCb2R5KCk7XG4gICAgc2V0UmlnaWRCb2R5T3B0aW9ucyhyaWdpZEJvZHksIHByb3BzLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyk7XG4gIH0sIG11dGFibGVQcm9wc0FzRmxhdEFycmF5KTtcbn07XG5jb25zdCB1c2VSaWdpZEJvZHlFdmVudHMgPSAoZ2V0UmlnaWRCb2R5LCBwcm9wcywgZXZlbnRzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvbldha2UsXG4gICAgb25TbGVlcCxcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSB7XG4gICAgb25XYWtlLFxuICAgIG9uU2xlZXAsXG4gICAgb25Db2xsaXNpb25FbnRlcixcbiAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICBvbkludGVyc2VjdGlvbkV4aXQsXG4gICAgb25Db250YWN0Rm9yY2VcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByaWdpZEJvZHkgPSBnZXRSaWdpZEJvZHkoKTtcbiAgICBldmVudHMuc2V0KHJpZ2lkQm9keS5oYW5kbGUsIGV2ZW50SGFuZGxlcnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMuZGVsZXRlKHJpZ2lkQm9keS5oYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvbldha2UsIG9uU2xlZXAsIG9uQ29sbGlzaW9uRW50ZXIsIG9uQ29sbGlzaW9uRXhpdCwgb25JbnRlcnNlY3Rpb25FbnRlciwgb25JbnRlcnNlY3Rpb25FeGl0LCBvbkNvbnRhY3RGb3JjZV0pO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBvYmplY3QgcmVzZW1ibGluZyBhIFZlY3RvcjMgYW5kIHJldHVycyBhIFRocmVlLlZlY3RvcjNcbiAqIEBjYXRlZ29yeSBNYXRoIGhlbHBlcnNcbiAqL1xuY29uc3QgdmVjMyA9ICh7XG4gIHgsXG4gIHksXG4gIHpcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDBcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBvYmplY3QgcmVzZW1ibGluZyBhIFF1YXRlcm5pb24gYW5kIHJldHVycyBhIFRocmVlLlF1YXRlcm5pb25cbiAqIEBjYXRlZ29yeSBNYXRoIGhlbHBlcnNcbiAqL1xuY29uc3QgcXVhdCA9ICh7XG4gIHgsXG4gIHksXG4gIHosXG4gIHdcbn0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHo6IDAsXG4gIHc6IDFcbn0pID0+IHtcbiAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHgsIHksIHosIHcpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBvYmplY3QgcmVzZW1ibGluZyBhbiBFdWxlciBhbmQgcmV0dXJzIGEgVGhyZWUuRXVsZXJcbiAqIEBjYXRlZ29yeSBNYXRoIGhlbHBlcnNcbiAqL1xuY29uc3QgZXVsZXIgPSAoe1xuICB4LFxuICB5LFxuICB6XG59ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwXG59KSA9PiB7XG4gIHJldHVybiBuZXcgRXVsZXIoeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIEEgY29sbGlkZXIgaXMgYSBzaGFwZSB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHJpZ2lkIGJvZHkgdG8gZGVmaW5lIGl0cyBwaHlzaWNhbCBwcm9wZXJ0aWVzLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFueUNvbGxpZGVyID0gLyojX19QVVJFX18qL21lbW8ocHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgcG9zaXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgcXVhdGVybmlvbixcbiAgICBzY2FsZSxcbiAgICBuYW1lXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHdvcmxkLFxuICAgIGNvbGxpZGVyRXZlbnRzLFxuICAgIGNvbGxpZGVyU3RhdGVzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmlnaWRCb2R5Q29udGV4dCA9IHVzZVJpZ2lkQm9keUNvbnRleHQoKTtcbiAgY29uc3QgY29sbGlkZXJSZWYgPSB1c2VGb3J3YXJkZWRSZWYocHJvcHMucmVmKTtcbiAgY29uc3Qgb2JqZWN0UmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIFdlIHNwcmVhZCB0aGUgcHJvcHMgb3V0IGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZiBpcyB1cGRhdGVkIHdoZW4gdGhlIHByb3BzIGNoYW5nZS5cbiAgY29uc3QgaW1tdXRhYmxlUHJvcEFycmF5ID0gaW1tdXRhYmxlQ29sbGlkZXJPcHRpb25zLmZsYXRNYXAoa2V5ID0+XG4gIC8vIEFycmF5LmlzQXJyYXkocHJvcHNba2V5XSkgPyBbLi4ucHJvcHNba2V5XV0gOiBwcm9wc1trZXldXG4gIEFycmF5LmlzQXJyYXkocHJvcHNba2V5XSkgPyBwcm9wc1trZXldIDogW3Byb3BzW2tleV1dKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2UgPSB1c2VJbXBlcmF0aXZlSW5zdGFuY2UoKCkgPT4ge1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBvYmplY3RSZWYuY3VycmVudC5nZXRXb3JsZFNjYWxlKHZlYzMoKSk7XG4gICAgY29uc3QgY29sbGlkZXIgPSBjcmVhdGVDb2xsaWRlckZyb21PcHRpb25zKHByb3BzLCB3b3JsZCwgd29ybGRTY2FsZSwgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0LmdldFJpZ2lkQm9keSk7XG4gICAgaWYgKHR5cGVvZiBwcm9wcy5yZWYgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwcm9wcy5yZWYoY29sbGlkZXIpO1xuICAgIH1cbiAgICBjb2xsaWRlclJlZi5jdXJyZW50ID0gY29sbGlkZXI7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9LCBjb2xsaWRlciA9PiB7XG4gICAgaWYgKHdvcmxkLmdldENvbGxpZGVyKGNvbGxpZGVyLmhhbmRsZSkpIHtcbiAgICAgIHdvcmxkLnJlbW92ZUNvbGxpZGVyKGNvbGxpZGVyLCB0cnVlKTtcbiAgICB9XG4gIH0sIFsuLi5pbW11dGFibGVQcm9wQXJyYXksIHJpZ2lkQm9keUNvbnRleHRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xsaWRlciA9IGdldEluc3RhbmNlKCk7XG4gICAgY29sbGlkZXJTdGF0ZXMuc2V0KGNvbGxpZGVyLmhhbmRsZSwgY3JlYXRlQ29sbGlkZXJTdGF0ZShjb2xsaWRlciwgb2JqZWN0UmVmLmN1cnJlbnQsIHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5yZWYuY3VycmVudCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb2xsaWRlclN0YXRlcy5kZWxldGUoY29sbGlkZXIuaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbZ2V0SW5zdGFuY2VdKTtcbiAgY29uc3QgbWVyZ2VkUHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlcihyaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQub3B0aW9ucykpLCBwcm9wcyk7XG4gIH0sIFtwcm9wcywgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnNdKTtcbiAgdXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zKGdldEluc3RhbmNlLCBtZXJnZWRQcm9wcywgY29sbGlkZXJTdGF0ZXMpO1xuICB1c2VDb2xsaWRlckV2ZW50cyhnZXRJbnN0YW5jZSwgbWVyZ2VkUHJvcHMsIGNvbGxpZGVyRXZlbnRzLCBnZXRBY3RpdmVDb2xsaXNpb25FdmVudHNGcm9tUHJvcHMocmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnMpKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgcmVmOiBvYmplY3RSZWYsXG4gICAgbmFtZTogbmFtZVxuICB9LCBjaGlsZHJlbik7XG59KTtcbi8qKlxuICogQSBjdWJvaWQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ3Vib2lkQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHNoYXBlOiBcImN1Ym9pZFwiLFxuICAgIHJlZjogcmVmXG4gIH0pKTtcbn0pO1xuQ3Vib2lkQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkN1Ym9pZENvbGxpZGVyXCI7XG4vKipcbiAqIEEgcm91bmQgY3Vib2lkIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ3Vib2lkQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJyb3VuZEN1Ym9pZFwiLFxuICByZWY6IHJlZlxufSkpKTtcblJvdW5kQ3Vib2lkQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ3Vib2lkQ29sbGlkZXJcIjtcbi8qKlxuICogQSBiYWxsIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IEJhbGxDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImJhbGxcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5CYWxsQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkJhbGxDb2xsaWRlclwiO1xuLyoqXG4gKiBBIGNhcHN1bGUgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ2Fwc3VsZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY2Fwc3VsZVwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNhcHN1bGVDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ2Fwc3VsZUNvbGxpZGVyXCI7XG4vKipcbiAqIEEgaGVpZ2h0ZmllbGQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgSGVpZ2h0ZmllbGRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImhlaWdodGZpZWxkXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuSGVpZ2h0ZmllbGRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiSGVpZ2h0ZmllbGRDb2xsaWRlclwiO1xuLyoqXG4gKiBBIHRyaW1lc2ggY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgVHJpbWVzaENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwidHJpbWVzaFwiLFxuICByZWY6IHJlZlxufSkpKTtcblRyaW1lc2hDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiVHJpbWVzaENvbGxpZGVyXCI7XG4vKipcbiAqIEEgY29uZSBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBDb25lQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjb25lXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ29uZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDb25lQ29sbGlkZXJcIjtcbi8qKlxuICogQSByb3VuZCBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBSb3VuZENvbmVDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ29uZVwiLFxuICByZWY6IHJlZlxufSkpKTtcblJvdW5kQ29uZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJSb3VuZENvbmVDb2xsaWRlclwiO1xuLyoqXG4gKiBBIGN5bGluZGVyIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IEN5bGluZGVyQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJjeWxpbmRlclwiLFxuICByZWY6IHJlZlxufSkpKTtcbkN5bGluZGVyQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkN5bGluZGVyQ29sbGlkZXJcIjtcbi8qKlxuICogQSByb3VuZCBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBSb3VuZEN5bGluZGVyQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJyb3VuZEN5bGluZGVyXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ3lsaW5kZXJDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiUm91bmRDeWxpbmRlckNvbGxpZGVyXCI7XG4vKipcbiAqIEEgY29udmV4IGh1bGwgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ29udmV4SHVsbENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY29udmV4SHVsbFwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNvbnZleEh1bGxDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ29udmV4SHVsbENvbGxpZGVyXCI7XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wicmVmXCIsIFwiY2hpbGRyZW5cIiwgXCJ0eXBlXCIsIFwicG9zaXRpb25cIiwgXCJyb3RhdGlvblwiLCBcInNjYWxlXCIsIFwicXVhdGVybmlvblwiLCBcInRyYW5zZm9ybVN0YXRlXCJdO1xuY29uc3QgUmlnaWRCb2R5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCB1c2VSaWdpZEJvZHlDb250ZXh0ID0gKCkgPT4gdXNlQ29udGV4dChSaWdpZEJvZHlDb250ZXh0KTtcbi8qKlxuICogQSByaWdpZCBib2R5IGlzIGEgcGh5c2ljYWwgb2JqZWN0IHRoYXQgY2FuIGJlIHNpbXVsYXRlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAY2F0ZWdvcnkgQ29tcG9uZW50c1xuICovXG5jb25zdCBSaWdpZEJvZHkgPSAvKiNfX1BVUkVfXyovbWVtbyhwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIHJlZixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgdHlwZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcm90YXRpb24sXG4gICAgICBzY2FsZSxcbiAgICAgIHF1YXRlcm5pb24sXG4gICAgICB0cmFuc2Zvcm1TdGF0ZVxuICAgIH0gPSBwcm9wcyxcbiAgICBvYmplY3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJpZ2lkQm9keVJlZiA9IHVzZUZvcndhcmRlZFJlZihyZWYpO1xuICBjb25zdCB7XG4gICAgd29ybGQsXG4gICAgcmlnaWRCb2R5U3RhdGVzLFxuICAgIHBoeXNpY3NPcHRpb25zLFxuICAgIHJpZ2lkQm9keUV2ZW50c1xuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBoeXNpY3NPcHRpb25zKSwgcHJvcHMpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LCBbcGh5c2ljc09wdGlvbnMsIHByb3BzXSk7XG4gIGNvbnN0IGltbXV0YWJsZVByb3BBcnJheSA9IGltbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1lcmdlZE9wdGlvbnNba2V5XSkgPyBbLi4ubWVyZ2VkT3B0aW9uc1trZXldXSA6IG1lcmdlZE9wdGlvbnNba2V5XTtcbiAgfSk7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3RSZWYsIG1lcmdlZE9wdGlvbnMpO1xuXG4gIC8vIFByb3ZpZGUgYSB3YXkgdG8gZWFnZXJseSBjcmVhdGUgcmlnaWRib2R5XG4gIGNvbnN0IGdldFJpZ2lkQm9keSA9IHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IHJpZ2lkQm9keURlc2NGcm9tT3B0aW9ucyhtZXJnZWRPcHRpb25zKTtcbiAgICBjb25zdCByaWdpZEJvZHkgPSB3b3JsZC5jcmVhdGVSaWdpZEJvZHkoZGVzYyk7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVmKHJpZ2lkQm9keSk7XG4gICAgfVxuICAgIHJpZ2lkQm9keVJlZi5jdXJyZW50ID0gcmlnaWRCb2R5O1xuICAgIHJldHVybiByaWdpZEJvZHk7XG4gIH0sIHJpZ2lkQm9keSA9PiB7XG4gICAgaWYgKHdvcmxkLmdldFJpZ2lkQm9keShyaWdpZEJvZHkuaGFuZGxlKSkge1xuICAgICAgd29ybGQucmVtb3ZlUmlnaWRCb2R5KHJpZ2lkQm9keSk7XG4gICAgfVxuICB9LCBpbW11dGFibGVQcm9wQXJyYXkpO1xuXG4gIC8vIE9ubHkgcHJvdmlkZSBhIG9iamVjdCBzdGF0ZSBhZnRlciB0aGUgcmVmIGhhcyBiZWVuIHNldFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IGdldFJpZ2lkQm9keSgpO1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlUmlnaWRCb2R5U3RhdGUoe1xuICAgICAgcmlnaWRCb2R5LFxuICAgICAgb2JqZWN0OiBvYmplY3RSZWYuY3VycmVudFxuICAgIH0pO1xuICAgIHJpZ2lkQm9keVN0YXRlcy5zZXQocmlnaWRCb2R5LmhhbmRsZSwgcHJvcHMudHJhbnNmb3JtU3RhdGUgPyBwcm9wcy50cmFuc2Zvcm1TdGF0ZShzdGF0ZSkgOiBzdGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJpZ2lkQm9keVN0YXRlcy5kZWxldGUocmlnaWRCb2R5LmhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICB1c2VVcGRhdGVSaWdpZEJvZHlPcHRpb25zKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5U3RhdGVzKTtcbiAgdXNlUmlnaWRCb2R5RXZlbnRzKGdldFJpZ2lkQm9keSwgbWVyZ2VkT3B0aW9ucywgcmlnaWRCb2R5RXZlbnRzKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogb2JqZWN0UmVmLFxuICAgICAgZ2V0UmlnaWRCb2R5OiBnZXRSaWdpZEJvZHksXG4gICAgICBvcHRpb25zOiBtZXJnZWRPcHRpb25zXG4gICAgfTtcbiAgfSwgW2dldFJpZ2lkQm9keV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlnaWRCb2R5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBvYmplY3RSZWZcbiAgfSwgb2JqZWN0UHJvcHMsIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgc2NhbGU6IHNjYWxlXG4gIH0pLCBjaGlsZHJlbiwgY2hpbGRDb2xsaWRlclByb3BzLm1hcCgoY29sbGlkZXJQcm9wcywgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBpbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKSk7XG59KTtcblJpZ2lkQm9keS5kaXNwbGF5TmFtZSA9IFwiUmlnaWRCb2R5XCI7XG5cbi8qKlxuICogQSBtZXNoIGNvbGxpZGVyIGlzIGEgY29sbGlkZXIgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIHRoZSBnZW9tZXRyeSBvZiB0aGUgY2hpbGRyZW4uXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IE1lc2hDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9tZW1vKHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIHR5cGVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgcGh5c2ljc09wdGlvbnNcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBvYmplY3QgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zXG4gIH0gPSB1c2VSaWdpZEJvZHlDb250ZXh0KCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBoeXNpY3NPcHRpb25zKSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICAgICAgY29sbGlkZXJzOiB0eXBlXG4gICAgfSk7XG4gIH0sIFtwaHlzaWNzT3B0aW9ucywgb3B0aW9uc10pO1xuICBjb25zdCBjaGlsZENvbGxpZGVyUHJvcHMgPSB1c2VDaGlsZENvbGxpZGVyUHJvcHMob2JqZWN0LCBtZXJnZWRPcHRpb25zLCBmYWxzZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIHtcbiAgICByZWY6IG9iamVjdCxcbiAgICB1c2VyRGF0YToge1xuICAgICAgcjNSYXBpZXJUeXBlOiBcIk1lc2hDb2xsaWRlclwiXG4gICAgfVxuICB9LCBjaGlsZHJlbiwgY2hpbGRDb2xsaWRlclByb3BzLm1hcCgoY29sbGlkZXJQcm9wcywgaW5kZXgpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBpbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKTtcbn0pO1xuTWVzaENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJNZXNoQ29sbGlkZXJcIjtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wicmVmXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIiwgXCJpbnN0YW5jZXNcIiwgXCJjb2xsaWRlck5vZGVzXCIsIFwicG9zaXRpb25cIiwgXCJyb3RhdGlvblwiLCBcInF1YXRlcm5pb25cIiwgXCJzY2FsZVwiXTtcbmNvbnN0IEluc3RhbmNlZFJpZ2lkQm9kaWVzID0gLyojX19QVVJFX18qL21lbW8oX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgICByZWZcbiAgICB9ID0gX3JlZixcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICBjb25zdCByaWdpZEJvZGllc1JlZiA9IHVzZUZvcndhcmRlZFJlZihyZWYsIFtdKTtcbiAgY29uc3Qgb2JqZWN0UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpbnN0YW5jZVdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICAgIC8vIGluc3RhbmNlZCBwcm9wc1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBpbnN0YW5jZXMsXG4gICAgICBjb2xsaWRlck5vZGVzID0gW10sXG4gICAgICAvLyB3cmFwcGVyIG9iamVjdCBwcm9wc1xuICAgICAgcG9zaXRpb24sXG4gICAgICByb3RhdGlvbixcbiAgICAgIHF1YXRlcm5pb24sXG4gICAgICBzY2FsZVxuXG4gICAgICAvLyByaWdpZCBib2R5IHNwZWNpZmljIHByb3BzLCBhbmQgcjNmLW9iamVjdCBwcm9wc1xuICAgIH0gPSBwcm9wcyxcbiAgICByaWdpZEJvZHlQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkMik7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3RSZWYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICB9KSk7XG4gIGNvbnN0IGdldEluc3RhbmNlZE1lc2ggPSAoKSA9PiB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGluc3RhbmNlV3JhcHBlclJlZi5jdXJyZW50LmNoaWxkcmVuWzBdO1xuICAgIGlmIChmaXJzdENoaWxkICYmIFwiaXNJbnN0YW5jZWRNZXNoXCIgaW4gZmlyc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IGdldEluc3RhbmNlZE1lc2goKTtcbiAgICBpZiAoaW5zdGFuY2VkTWVzaCkge1xuICAgICAgaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2VkUmlnaWRCb2RpZXMgZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCwgd2hpY2ggbXVzdCBiZSBhbiBJbnN0YW5jZWRNZXNoXCIpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFVwZGF0ZSB0aGUgUmlnaWRCb2R5U3RhdGVzIHdoZW5ldmVyIHRoZSBpbnN0YW5jZXMgY2hhbmdlXG4gIGNvbnN0IGFwcGx5SW5zdGFuY2VkU3RhdGUgPSAoc3RhdGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IGdldEluc3RhbmNlZE1lc2goKTtcbiAgICBpZiAoaW5zdGFuY2VkTWVzaCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzdGF0ZSksIHt9LCB7XG4gICAgICAgIGdldE1hdHJpeDogbWF0cml4ID0+IHtcbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLmdldE1hdHJpeEF0KGluZGV4LCBtYXRyaXgpO1xuICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE1hdHJpeDogbWF0cml4ID0+IHtcbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGluZGV4LCBtYXRyaXgpO1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBtZXNoVHlwZTogXCJpbnN0YW5jZWRNZXNoXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IG9iamVjdFJlZlxuICB9LCByaWdpZEJvZHlQcm9wcywge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICBzY2FsZTogc2NhbGVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHJlZjogaW5zdGFuY2VXcmFwcGVyUmVmXG4gIH0sIGNoaWxkcmVuKSwgaW5zdGFuY2VzID09PSBudWxsIHx8IGluc3RhbmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSaWdpZEJvZHksIF9leHRlbmRzKHt9LCByaWdpZEJvZHlQcm9wcywgaW5zdGFuY2UsIHtcbiAgICByZWY6IGJvZHkgPT4ge1xuICAgICAgcmlnaWRCb2RpZXNSZWYuY3VycmVudFtpbmRleF0gPSBib2R5O1xuICAgIH0sXG4gICAgdHJhbnNmb3JtU3RhdGU6IHN0YXRlID0+IGFwcGx5SW5zdGFuY2VkU3RhdGUoc3RhdGUsIGluZGV4KVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvbGxpZGVyTm9kZXMubWFwKChub2RlLCBpbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHtcbiAgICBrZXk6IGluZGV4XG4gIH0sIG5vZGUpKSwgY2hpbGRDb2xsaWRlclByb3BzLm1hcCgoY29sbGlkZXJQcm9wcywgY29sbGlkZXJJbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGNvbGxpZGVySW5kZXhcbiAgfSwgY29sbGlkZXJQcm9wcykpKSkpKSk7XG59KTtcbkluc3RhbmNlZFJpZ2lkQm9kaWVzLmRpc3BsYXlOYW1lID0gXCJJbnN0YW5jZWRSaWdpZEJvZGllc1wiO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCB1c2VJbXB1bHNlSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBwYXJhbXMpID0+IHtcbiAgY29uc3Qge1xuICAgIHdvcmxkXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3Qgam9pbnRSZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgdXNlSW1wZXJhdGl2ZUluc3RhbmNlKCgpID0+IHtcbiAgICBpZiAoYm9keTEuY3VycmVudCAmJiBib2R5Mi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBuZXdKb2ludCA9IHdvcmxkLmNyZWF0ZUltcHVsc2VKb2ludChwYXJhbXMsIGJvZHkxLmN1cnJlbnQsIGJvZHkyLmN1cnJlbnQsIHRydWUpO1xuICAgICAgam9pbnRSZWYuY3VycmVudCA9IG5ld0pvaW50O1xuICAgICAgcmV0dXJuIG5ld0pvaW50O1xuICAgIH1cbiAgfSwgam9pbnQgPT4ge1xuICAgIGlmIChqb2ludCkge1xuICAgICAgam9pbnRSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh3b3JsZC5nZXRJbXB1bHNlSm9pbnQoam9pbnQuaGFuZGxlKSkge1xuICAgICAgICB3b3JsZC5yZW1vdmVJbXB1bHNlSm9pbnQoam9pbnQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gam9pbnRSZWY7XG59O1xuXG4vKipcbiAqIEEgZml4ZWQgam9pbnQgZW5zdXJlcyB0aGF0IHR3byByaWdpZC1ib2RpZXMgZG9uJ3QgbW92ZSByZWxhdGl2ZSB0byBlYWNoIG90aGVyLlxuICogRml4ZWQgam9pbnRzIGFyZSBjaGFyYWN0ZXJpemVkIGJ5IG9uZSBsb2NhbCBmcmFtZSAocmVwcmVzZW50ZWQgYnkgYW4gaXNvbWV0cnkpIG9uIGVhY2ggcmlnaWQtYm9keS5cbiAqIFRoZSBmaXhlZC1qb2ludCBtYWtlcyB0aGVzZSBmcmFtZXMgY29pbmNpZGUgaW4gd29ybGQtc3BhY2UuXG4gKlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cbmNvbnN0IHVzZUZpeGVkSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkxTG9jYWxGcmFtZSwgYm9keTJBbmNob3IsIGJvZHkyTG9jYWxGcmFtZV0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCByYXBpZXIuSm9pbnREYXRhLmZpeGVkKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24oYm9keTFMb2NhbEZyYW1lKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSwgcXVhdGVybmlvblRvUmFwaWVyUXVhdGVybmlvbihib2R5MkxvY2FsRnJhbWUpKSk7XG59O1xuXG4vKipcbiAqIFRoZSBzcGhlcmljYWwgam9pbnQgZW5zdXJlcyB0aGF0IHR3byBwb2ludHMgb24gdGhlIGxvY2FsLXNwYWNlcyBvZiB0d28gcmlnaWQtYm9kaWVzIGFsd2F5cyBjb2luY2lkZSAoaXQgcHJldmVudHMgYW55IHJlbGF0aXZlXG4gKiB0cmFuc2xhdGlvbmFsIG1vdGlvbiBhdCB0aGlzIHBvaW50cykuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgdG8gc2ltdWxhdGUgcmFnZG9sbHMgYXJtcywgcGVuZHVsdW1zLCBldGMuXG4gKiBUaGV5IGFyZSBjaGFyYWN0ZXJpemVkIGJ5IG9uZSBsb2NhbCBhbmNob3Igb24gZWFjaCByaWdpZC1ib2R5LiBFYWNoIGFuY2hvciByZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAqIHBvaW50cyB0aGF0IG5lZWQgdG8gY29pbmNpZGUgb24gdGhlIGxvY2FsLXNwYWNlIG9mIGVhY2ggcmlnaWQtYm9keS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlU3BoZXJpY2FsSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHJhcGllci5Kb2ludERhdGEuc3BoZXJpY2FsKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MkFuY2hvcikpKTtcbn07XG5cbi8qKlxuICogVGhlIHJldm9sdXRlIGpvaW50IHByZXZlbnRzIGFueSByZWxhdGl2ZSBtb3ZlbWVudCBiZXR3ZWVuIHR3byByaWdpZC1ib2RpZXMsIGV4Y2VwdCBmb3IgcmVsYXRpdmVcbiAqIHJvdGF0aW9ucyBhbG9uZyBvbmUgYXhpcy4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBzaW11bGF0ZSB3aGVlbHMsIGZhbnMsIGV0Yy5cbiAqIFRoZXkgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBhcyB3ZWxsIGFzIG9uZSBsb2NhbCBheGlzIG9uIGVhY2ggcmlnaWQtYm9keS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlUmV2b2x1dGVKb2ludCA9IChib2R5MSwgYm9keTIsIFtib2R5MUFuY2hvciwgYm9keTJBbmNob3IsIGF4aXMsIGxpbWl0c10pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IHBhcmFtcyA9IHJhcGllci5Kb2ludERhdGEucmV2b2x1dGUodmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGF4aXMpKTtcbiAgaWYgKGxpbWl0cykge1xuICAgIHBhcmFtcy5saW1pdHNFbmFibGVkID0gdHJ1ZTtcbiAgICBwYXJhbXMubGltaXRzID0gbGltaXRzO1xuICB9XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBUaGUgcHJpc21hdGljIGpvaW50IHByZXZlbnRzIGFueSByZWxhdGl2ZSBtb3ZlbWVudCBiZXR3ZWVuIHR3byByaWdpZC1ib2RpZXMsIGV4Y2VwdCBmb3IgcmVsYXRpdmUgdHJhbnNsYXRpb25zIGFsb25nIG9uZSBheGlzLlxuICogSXQgaXMgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgYW5jaG9yIGFzIHdlbGwgYXMgb25lIGxvY2FsIGF4aXMgb24gZWFjaCByaWdpZC1ib2R5LiBJbiAzRCwgYW4gb3B0aW9uYWxcbiAqIGxvY2FsIHRhbmdlbnQgYXhpcyBjYW4gYmUgc3BlY2lmaWVkIGZvciBlYWNoIHJpZ2lkLWJvZHkuXG4gKlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cbmNvbnN0IHVzZVByaXNtYXRpY0pvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgYXhpcywgbGltaXRzXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5wcmlzbWF0aWModmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKSwgdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGF4aXMpKTtcbiAgaWYgKGxpbWl0cykge1xuICAgIHBhcmFtcy5saW1pdHNFbmFibGVkID0gdHJ1ZTtcbiAgICBwYXJhbXMubGltaXRzID0gbGltaXRzO1xuICB9XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBUaGUgcm9wZSBqb2ludCBsaW1pdHMgdGhlIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBib2RpZXMuXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuY29uc3QgdXNlUm9wZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgbGVuZ3RoXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgdkJvZHkxQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKTtcbiAgY29uc3QgdkJvZHkyQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5yb3BlKGxlbmd0aCwgdkJvZHkxQW5jaG9yLCB2Qm9keTJBbmNob3IpO1xuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogVGhlIHNwcmluZyBqb2ludCBhcHBsaWVzIGEgZm9yY2UgcHJvcG9ydGlvbmFsIHRvIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cbmNvbnN0IHVzZVNwcmluZ0pvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgcmVzdExlbmd0aCwgc3RpZmZuZXNzLCBkYW1waW5nXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgdkJvZHkxQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKTtcbiAgY29uc3QgdkJvZHkyQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5zcHJpbmcocmVzdExlbmd0aCwgc3RpZmZuZXNzLCBkYW1waW5nLCB2Qm9keTFBbmNob3IsIHZCb2R5MkFuY2hvcik7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGFuIEludGVyYWN0aW9uR3JvdXAgYml0bWFzayBmb3IgdXNlIGluIHRoZSBgY29sbGlzaW9uR3JvdXBzYCBvciBgc29sdmVyR3JvdXBzYFxuICogcHJvcGVydGllcyBvZiBSaWdpZEJvZHkgb3IgQ29sbGlkZXIgY29tcG9uZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IHJlcHJlc2VudHMgYSBsaXN0IG9mXG4gKiBncm91cHMgdGhlIGVudGl0eSBpcyBpbiAoZXhwcmVzc2VkIGFzIG51bWJlcnMgZnJvbSAwIHRvIDE1KS4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGxpc3RcbiAqIG9mIGdyb3VwcyB0aGF0IHdpbGwgYmUgZmlsdGVyZWQgYWdhaW5zdC4gV2hlbiBpdCBpcyBvbWl0dGVkLCBhbGwgZ3JvdXBzIGFyZSBmaWx0ZXJlZCBhZ2FpbnN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cCAwIGFuZCB3aWxsIGNvbGxpZGUgd2l0aCBldmVyeXRoaW5nIGZyb20gZ3JvdXBzIDAgYW5kIDE6XG4gKlxuICogYGBgdHN4XG4gKiA8UmlnaWRCb2R5IGNvbGxpc2lvbkdyb3Vwcz17aW50ZXJhY3Rpb25Hcm91cHMoWzBdLCBbMCwgMV0pfSAvPlxuICogYGBgXG4gKlxuICogQSBSaWdpZEJvZHkgdGhhdCBpcyBtZW1iZXIgb2YgZ3JvdXBzIDAgYW5kIDEgYW5kIHdpbGwgY29sbGlkZSB3aXRoIGV2ZXJ5dGhpbmcgZWxzZTpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMCwgMV0pfSAvPlxuICogYGBgXG4gKlxuICogQSBSaWdpZEJvZHkgdGhhdCBpcyBtZW1iZXIgb2YgZ3JvdXBzIDAgYW5kIDEgYW5kIHdpbGwgbm90IGNvbGxpZGUgd2l0aCBhbnl0aGluZzpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMCwgMV0sIFtdKX0gLz5cbiAqIGBgYFxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgUmFwaWVyIG5lZWRzIGludGVyYWN0aW9uIGZpbHRlcnMgdG8gZXZhbHVhdGUgdG8gdHJ1ZSBiZXR3ZWVuIF9ib3RoXyBjb2xsaWRpbmdcbiAqIGVudGl0aWVzIGZvciBjb2xsaXNpb24gZXZlbnRzIHRvIHRyaWdnZXIuXG4gKlxuICogQHBhcmFtIG1lbWJlcnNoaXBzIEdyb3VwcyB0aGUgY29sbGlkZXIgaXMgYSBtZW1iZXIgb2YuIChWYWx1ZXMgY2FuIHJhbmdlIGZyb20gMCB0byAxNS4pXG4gKiBAcGFyYW0gZmlsdGVycyBHcm91cHMgdGhlIGludGVyYWN0aW9uIGdyb3VwIHNob3VsZCBmaWx0ZXIgYWdhaW5zdC4gKFZhbHVlcyBjYW4gcmFuZ2UgZnJvbSAwIHRvIDE1LilcbiAqIEByZXR1cm5zIEFuIEludGVyYWN0aW9uR3JvdXAgYml0bWFzay5cbiAqL1xuY29uc3QgaW50ZXJhY3Rpb25Hcm91cHMgPSAobWVtYmVyc2hpcHMsIGZpbHRlcnMpID0+IChiaXRtYXNrKG1lbWJlcnNoaXBzKSA8PCAxNikgKyAoZmlsdGVycyAhPT0gdW5kZWZpbmVkID8gYml0bWFzayhmaWx0ZXJzKSA6IDBiMTExMTExMTExMTExMTExMSk7XG5jb25zdCBiaXRtYXNrID0gZ3JvdXBzID0+IFtncm91cHNdLmZsYXQoKS5yZWR1Y2UoKGFjYywgbGF5ZXIpID0+IGFjYyB8IDEgPDwgbGF5ZXIsIDApO1xuXG5leHBvcnQgeyBBbnlDb2xsaWRlciwgQmFsbENvbGxpZGVyLCBDYXBzdWxlQ29sbGlkZXIsIENvbmVDb2xsaWRlciwgQ29udmV4SHVsbENvbGxpZGVyLCBDdWJvaWRDb2xsaWRlciwgQ3lsaW5kZXJDb2xsaWRlciwgSGVpZ2h0ZmllbGRDb2xsaWRlciwgSW5zdGFuY2VkUmlnaWRCb2RpZXMsIE1lc2hDb2xsaWRlciwgUGh5c2ljcywgUmlnaWRCb2R5LCBSb3VuZENvbmVDb2xsaWRlciwgUm91bmRDdWJvaWRDb2xsaWRlciwgUm91bmRDeWxpbmRlckNvbGxpZGVyLCBUcmltZXNoQ29sbGlkZXIsIGV1bGVyLCBpbnRlcmFjdGlvbkdyb3VwcywgcXVhdCwgdXNlQWZ0ZXJQaHlzaWNzU3RlcCwgdXNlQmVmb3JlUGh5c2ljc1N0ZXAsIHVzZUZpeGVkSm9pbnQsIHVzZUltcHVsc2VKb2ludCwgdXNlUHJpc21hdGljSm9pbnQsIHVzZVJhcGllciwgdXNlUmV2b2x1dGVKb2ludCwgdXNlUm9wZUpvaW50LCB1c2VTcGhlcmljYWxKb2ludCwgdXNlU3ByaW5nSm9pbnQsIHZlYzMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js\n");

/***/ })

};
;